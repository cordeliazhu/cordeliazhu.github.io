<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Control Theory and Application in CS</title>
    <url>/2019/09/08/Control/control-theory-in-cs/</url>
    <content><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Control theory provides a <strong>systetmatic approach</strong> to design feedback loops that are stable and settle quickly to their steady state values.</p>
<p>In many computing systems, control theory is used widely in problem such as adjusting scheduling priorites, memory allocations, and network bandwith allocation and flow control and TCP/IP</p>
<h2 id="control-theoty-fundamentals">Control Theoty Fundamentals</h2>
<blockquote>
<p>The magic of feedback: create a system that perform well from components that perform poorly.</p>
<p>​ — Karl Astrom</p>
</blockquote>
<a id="more"></a>
<h3 id="notions">Notions</h3>
<p>Because we are talking about computer system, so the time is discrete. Here are some symbols</p>
<ul>
<li>time: <span class="math inline">\(k\)</span></li>
<li>reference input: <span class="math inline">\(r(k)\)</span>, the desired value of measured output</li>
<li>control error: <span class="math inline">\(e(k)\)</span>, the difference between reference input and the measured output</li>
<li>control output <span class="math inline">\(u(k)\)</span>, the output of controller. <strong>This is a parameter in the target system</strong></li>
<li>disturbance input <span class="math inline">\(d(k)\)</span>, any changes that affects the way in which the <span class="math inline">\(u(k)\)</span> influences the measured output</li>
<li>measured output <span class="math inline">\(y(k)\)</span></li>
<li>noise input <span class="math inline">\(n(k)\)</span> changes the measured output produced by the target system</li>
</ul>
<h3 id="purpose">Purpose</h3>
<ul>
<li>regulatory control: ensure the measured output is close to the reference input</li>
<li>disturbance rejection</li>
<li>optimization: obtain the best value of the measured output</li>
</ul>
<h3 id="good-properties">Good Properties</h3>
<p><strong>SASO</strong></p>
<ul>
<li>stable</li>
<li>accurate</li>
<li>short settling time</li>
<li>no overshoot</li>
</ul>
<h2 id="example-1-ibm-lotus-domino-server">Example 1 IBM Lotus Domino Server</h2>
<p>Goal: Control <em>RIS</em> in the server</p>
<ol type="1">
<li><p>Model how <em>MaxUsers</em> (output of the controller) affects <em>RIS</em></p>
<p>Construct the model by applying <strong>least squares regression</strong> to the data obtained from off-line experiments <strong>data</strong>. And the resulting model is <span class="math display">\[
y(k)=0.43 y(k-1)+0.47 u(k-1)
\]</span> Then use Z-transform to get the transfer function <span class="math display">\[
G(z)=\frac{0.47}{z-0.43}
\]</span></p></li>
<li><p>Construct a controller, we want to the whole system’s transfer function has following properties:</p>
<ul>
<li>the pole of transfer function close to 0</li>
<li>the stead state gain to be 1</li>
</ul></li>
</ol>
]]></content>
      <categories>
        <category>Control</category>
      </categories>
      <tags>
        <tag>control</tag>
      </tags>
  </entry>
  <entry>
    <title>Apple&#39;s 3D Face ID Tech</title>
    <url>/2019/07/29/Life/apple-3d-face/</url>
    <content><![CDATA[<h2 id="overview">Overview</h2>
<p>Apple use Face ID as an unlocking method first in iPhone X, it use a bunch of technology to improve its performance.</p>
<ul>
<li>Front facing <strong>depth-camera</strong></li>
<li><strong>infrared camera</strong></li>
<li><strong>Deep learning</strong></li>
</ul>
<p>I was so interested in this tech especially how can Apple apply deep learning with little data and limited compute resource in mobile phone.</p>
<a id="more"></a>
<h2 id="how-it-works">How it Works?</h2>
<p>Apple release a whitepaper about Face ID, so we can learn something from it.</p>
<p>The whole security system is called <strong>TrueDepth camera system</strong></p>
<ul>
<li><strong>map the geometry</strong> of your face</li>
<li><strong>confirms attention</strong> by detecting the direction of your gaze</li>
</ul>
<p>As for users, they need to do something similar to Touch ID:</p>
<ol type="1">
<li>Register users’ face
<ol type="1">
<li>Look at the phone</li>
<li>slowly rotate the head</li>
</ol></li>
<li>DONE!</li>
</ol>
<p>As we can see, the process is pretty simple and quick.</p>
<hr />
<p>The problem here for <strong>normal classification</strong> procedure are</p>
<ul>
<li>The raw data is limited</li>
<li>Computing resource is limited</li>
<li>Lack of negative samples</li>
</ul>
<p>So I think Apple use another method to solve this problem</p>
<h2 id="possible-way">Possible Way</h2>
<p>Above all, I think <strong>extracting features</strong> on faces is the very first thing to do. In this way, device can get a <strong>small vector</strong> rather than a huge image to <strong>train</strong> some classification or neural networks <strong>in a short time</strong></p>
<p><strong>siamese-like convolutional neural network</strong> might be a good way to do the job</p>
<blockquote>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/siamese-neural-network.png" /></p>
<p>Two network share the weights</p>
<p>The main purpose of this work is to value the <strong>similarity of two input</strong></p>
</blockquote>
<p>So Apple can</p>
<ol type="1">
<li><strong>pre-train</strong> such a model that can detect different feature in users’ face</li>
<li>Get users’ face when they register Face ID and set it as <em>input 1</em></li>
<li>When users need to unlock their devices or use Face ID to purchase something, the camera get a image as <em>input 2</em></li>
<li>Calculate the similarity between <em>input 1</em> and <em>input 2</em></li>
</ol>
<h2 id="ref">Ref</h2>
<p><a href="https://towardsdatascience.com/how-i-implemented-iphone-xs-faceid-using-deep-learning-in-python-d5dbaa128e1d">Towards Data Science Blog</a></p>
<p><a href="https://images.apple.com/business/docs/FaceID_Security_Guide.pdf">Face ID White Paper</a></p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>skills</tag>
        <tag>apple</tag>
      </tags>
  </entry>
  <entry>
    <title>艺术概论</title>
    <url>/2018/07/05/Life/art-intro/</url>
    <content><![CDATA[<h2 id="美的起源">1 美的起源</h2>
<p>美是一种拯救. 在经历挫折之后, 面对困惑迷茫, 美使人反省, 有思考. 渴望, 向往和悲悯</p>
<p>花是美吗? 意义丰富, 喜? 哀? 很复杂</p>
<p>从植物的生长可以看到自己的成长, 这是美的喜悦(看自己)</p>
<a id="more"></a>
<h2 id="艺术的起源">2 艺术的起源</h2>
<p>写诗, 画画, 奏乐, 歌舞统称为<em>艺术</em></p>
<p><em>艺字</em>, 起源于农业, 在春秋战国变为各种<em>技能</em>, <em>技术</em></p>
<p>原始的石具, 是技术, 也是<em>艺</em>(起源于劳动)</p>
<p>后来逐渐转变为休闲, 好玩, 对自然的模仿</p>
<p>为人生而艺术? 为艺术而艺术?</p>
<h2 id="艺术的特质">3 艺术的特质</h2>
<p>艺术的创作中, <em>观念的发明</em>--智者, <em>手工技巧的执行者</em>--巧者</p>
<p>在古代, 两者趋向于统一, 而近当代, 两者分到, 变成了 <em>艺术家/匠人</em></p>
<p>中西例子:</p>
<ul>
<li>王维, 文人画, 画中有诗, 诗中有画, 文以载道</li>
<li>托尔斯泰，主张艺术以道德作为基础</li>
</ul>
<p>他们都有深刻的思想，动人的情操</p>
<h2 id="艺术的类别">4 艺术的类别</h2>
<p>在历史中，逐渐从<em>技术</em><span class="math inline">\(\to\)</span><em>心灵</em></p>
<p>在通俗艺术和自由艺术的影响下，18世纪，西方提出美的艺术</p>
<p>泛指一切为<em>美</em>的目的存在的人类活动</p>
<ol type="1">
<li>文字艺术：文学的诗、散文。将文字转化为思想，情感</li>
<li>视觉艺术
<ul>
<li>书法</li>
<li>绘画，写实、抽象，有丰富的表现</li>
<li>雕塑，对不朽的追求，希腊人体，古中国玉器，青铜器，石刻</li>
<li>建筑，崇高、庄严的感动，节奏与秩序</li>
</ul></li>
<li>听觉艺术
<ul>
<li>中方：八音、金石、丝、竹</li>
<li>西方：古典音乐，交响乐，给人以震撼</li>
</ul></li>
<li>表演艺术：舞蹈，表现情感。戏剧：综合</li>
<li>电影艺术：蒙太奇、剪切，导演：综合表达信仰，思想</li>
</ol>
<h2 id="艺术的材料">5 艺术的材料</h2>
<p>物质也是美学的元素，在物质中发现生命，赋予物质生命</p>
<p>材料的发现，也是一种审美的过程</p>
<h2 id="艺术的内容">6 艺术的内容</h2>
<p>指的是主题或者说描述的对象</p>
<p>大部分都是将大自然的感动（生命内在的经验、记忆、理想）转化为一种<em>形式</em>存留，<strong>道法自然</strong></p>
<p>中西方也有不同</p>
<ul>
<li>西方艺术：关心现实，介入生活，比较世俗（无贬义）</li>
<li>中国艺术：走向个人内心，寻找世界</li>
<li>超现实：探索诡异的内心世界</li>
</ul>
<h2 id="艺术的形式">7 艺术的形式</h2>
<p>美术的形式，是对澎湃的情感加以疏浚、引导</p>
<p>形式是由大众共同创作、总结出来的</p>
<p>中国艺术形式</p>
<ul>
<li>诗经，双音节，平稳而对称，象征着古典派的理性、分析、节制</li>
<li>初次：多音节，<em>三</em>的跌宕，夸张，激发内心，象征着浪漫派的对情感、激情、放纵的喜欢</li>
</ul>
<p>西方艺术形式</p>
<ul>
<li>写实，描绘社会</li>
<li>后印象派：不满足于写实对人生的观察</li>
</ul>
<p>形式是不同的，生命在寻找规律的同时又渴望叛逆规矩</p>
<h2 id="艺术的创作">8 艺术的创作</h2>
<p>艺术的功能？ 教化？谋生？</p>
<p>艺术创作真正的意义，几乎就是<em>生命活着的意义</em></p>
<ul>
<li>延长、扩大自己，是精神的生殖</li>
<li>学习艺术创作，享受和体验人生</li>
</ul>
<h2 id="艺术的欣赏">9 艺术的欣赏</h2>
<p>艺术能够让我们从无穷的理智中“逃避”</p>
<p>艺术的欣赏是个人生命经验的一次释放</p>
<p>生命是艰难的，我们需要向生命致敬，也就是欣赏艺术</p>
<p>越是伟大的作品与艺术，越有能力使人对现实进行不断地思考和反思</p>
<p>欣赏地过程中我们要做到包容、同情与悲悯，不以脸谱化的善恶评价人</p>
<h2 id="艺术的批评">10 艺术的批评</h2>
<p>这里所说的批评，并非通俗意义上的评价、贬损</p>
<p>深入了解一件作品的细节，让我们有更深的理解</p>
<p>以艺术史为基础，冷静客观地分析</p>
<p>艺术史</p>
<ul>
<li>史料：鉴别历史，利用分析技术C14，这个步骤史枯燥的，与感动无关</li>
<li>史观：研究其内在的发展规律，应是多元化的思考</li>
<li>美学：以“美”为主题，为核心</li>
</ul>
<p>本质是什么？是生命的启发，是美的思考</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>art</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币工作原理</title>
    <url>/2019/07/10/Life/bitcoin/</url>
    <content><![CDATA[<h2 id="overview">Overview</h2>
<p>比特币利用了区块链技术，从发展和技术角度来理解比特币</p>
<h2 id="发展过程">发展过程</h2>
<h3 id="账本">1 账本</h3>
<p>基本规则</p>
<ol type="1">
<li>每个人都能向账本添加信息</li>
<li>月底统一结算</li>
</ol>
<p>问题：添加信息时无法保证信息准确</p>
<a id="more"></a>
<h3 id="加密账本">2 加密账本</h3>
<p>使用数字加密技术，利用公钥+密钥，解决信用问题</p>
<ul>
<li><p>产生的256位签名是根据内容和私钥，签名的验证是根据内容、签名和公钥 <span class="math display">\[
Sign (Message, sk) = Signature
\]</span></p>
<p><span class="math display">\[
Verify (Message, Signature, pk) =\mathrm{T} / \mathrm{F}
\]</span></p>
<p>所以要伪造签名是很难的</p></li>
</ul>
<p>问题：虽然签名很难伪造，但是可以将同一个信息复制好几遍，这样就能达到修改账本又不需要私钥的效果</p>
<p>解决：对每笔交易进行编号，就是把编号信息加入到信息中，这样每次都会要求新的签名</p>
<h3 id="有启动金的加密账本">3 有启动金的加密账本</h3>
<p>为了防止有的人只花钱不还钱，所以再加上一条规则</p>
<ol type="1">
<li>每个人都能向账本添加信息</li>
<li>月底统一结算</li>
<li>不允许<strong>会产生欠款</strong>的交易</li>
</ol>
<h3 id="去中心的有启动金的加密账本">4 去中心的有启动金的加密账本</h3>
<p>之前的加密账本只有一个，可能在一个网站上，那么要怎么信任这个网站呢？</p>
<ul>
<li>每个人都有这个账本</li>
<li>在修改账单时向周围广播这个新的交易</li>
</ul>
<p>问题：<strong>顺序</strong>很重要，如何保证其他人以相同的顺序获取新的信息</p>
<p>解决：选择信任<strong>消耗最多计算资源</strong>的那份账本</p>
<p>主要工具：加密哈希方程SHA256，使得伪造信息所需要的计算资源大到无法承受</p>
<p>:star:<strong>对账本的设计</strong>：</p>
<ul>
<li>将账单分成多个区块，包含了一系列交易信息和工作量证明
<ul>
<li>工作量证明就是一个特别数字满足<strong>其哈希值以一系列0开头</strong></li>
</ul></li>
<li>为了保证账单是正确顺序的，规定前一区块的哈希值要加入到当前区块的头部信息中
<ul>
<li>这样的话，如果要改变某一区块的信息，就要重新寻找<strong>工作量证明</strong></li>
</ul></li>
<li>如果交易者收取到两个完全不同的账单，<strong>选取工作量证明较大的那个</strong>
<ul>
<li>如果有两份长不多的，就都保留，直到一条区块链相比另一条要短得多</li>
<li>除非伪造者拥有多余全部计算资源的<span class="math inline">\(50\%\)</span>，不然很难长时间伪造数据</li>
</ul></li>
</ul>
<p>使用步骤</p>
<ol start="0" type="1">
<li><p>某人广播了一笔账单</p></li>
<li><p><strong>矿工</strong>听到了账单，开始寻找一个数，加到账本末尾，计算整个账本的SHA256值，使得其<strong>满足以一系列0开头的要求</strong></p>
<ul>
<li>因为有很多人同时在找，所以要比谁算的快</li>
</ul></li>
<li><p>广播新的区块</p></li>
<li><p><strong>矿工</strong>获得奖励，<strong>普通交易者</strong>将听到的新区块加入到现存的账单上</p></li>
</ol>
<p>使用书记</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>skills</tag>
        <tag>bitcoin</tag>
      </tags>
  </entry>
  <entry>
    <title>灯具选择</title>
    <url>/2020/02/22/Life/choose-light/</url>
    <content><![CDATA[<h2 id="重要参数">重要参数</h2>
<p>流明 Lumen: 表明灯的亮度, 一般以Lumen/Watt来表示某个灯的效率</p>
<p>显色度 Ra: 显色度越高越好, 越能显示出物体本身的颜色. 因为人眼需要分辨物体, 所以如果显色度比较低会导致人眼疲劳. 因此会有显色度越高越能保护视力的说法</p>
<h2 id="常见灯具种类">常见灯具种类</h2>
<ol type="1">
<li><p>白炽灯 Halogen Incandescents</p>
<p>通过给钨丝通电发光发热来产生光. 根据填充的卤素气体不同而可以展现出不同的颜色, 但是效率较低, 大部分能量转化为了热能. 寿命较短</p></li>
<li><p>节能灯 Compact fluorescent lamps (CFLs)</p>
<p>长条状荧光灯的卷曲版本, 同等亮度下功耗为白炽灯的<span class="math inline">\(\frac{1}{3}\)</span></p></li>
<li><p>LED灯 Light emitting diodes</p>
<p>发光半导体将大部分电能转化为光能, 功耗比节能灯还略低一些. 寿命大幅度提高</p>
<p>虽然目前价格略贵, 但考虑到省电和寿命, 依然是目前最好的选择</p>
<a id="more"></a></li>
</ol>
<h2 id="led灯">LED灯</h2>
<p>因为LED灯目前最常用, 所以具体介绍一下LED</p>
<p>相比白炽灯和节能灯. LED主要有以下特点:</p>
<ul>
<li>尺寸小, 通常由RGB三种颜色的灯组成来混合发出白光</li>
<li>方向单一: 只会在某一个方向上散发光, 因为减少了能量损失</li>
<li>转换率高: 辐射了很少的热量</li>
</ul>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>skills</tag>
      </tags>
  </entry>
  <entry>
    <title>怎样学习某件事/如何向别人说明某件事</title>
    <url>/2020/03/13/Life/how-to-learn/</url>
    <content><![CDATA[<h2 id="动机">动机</h2>
<p>生活中, 学习中, 我经常会碰到新的知识, 但我从来没有思考过我学习一件事的思维过程是怎样的. 最近碰巧在做毕业设计, 需要学习许多新知识, 再加上一些生活中和别人交流过程中由于思维方式不同造成的误解, 催使我进行深入的思考, 我们到底要怎么说明一件事, 表明自己的观点, 更加有条理地学习一件事</p>
<a id="more"></a>
<h2 id="分析">分析</h2>
<p>当我了解到一件事情(通过感官, 大部分是视觉, 听觉, 暂时只考虑这两种情况), 大脑将这件事转化成一种描述. 为了避免歧义, 将要讨论的<strong>这件事</strong>定义为<strong>A</strong>.</p>
<p>当我看到A或者听到A时, A可能存在以下几种情况</p>
<ul>
<li>图像</li>
<li>声音(描述)</li>
<li>文本描述</li>
</ul>
<p>为了能够准确地知道A是什么, 我首先要通过搜索资料或者询问他人等方式知道A在语言中的定义是什么(暂时不考虑人类语言中还没定义的事物), 比如看到一种没见过的水果, 通过询问他人或者查询资料得知是<strong>A<span class="math inline">\(\to\)</span>西瓜</strong>. 或者我们先在书中看到或者听别人说了西瓜, 然后通过查询资料得知了西瓜的形态<strong>西瓜<span class="math inline">\(\to\)</span>A</strong></p>
<p>在这一步, 实际上已经完成了一种映射, 就是抽象概念和具体事物的映射, <strong>A<span class="math inline">\(\leftrightarrow\)</span>西瓜</strong>, 而所谓的具体事物, 也是一些A的基本属性, 我习惯于将A的图像属性作为第一印象.</p>
<p>无论A是以什么形式被我们所感知到, 我认为首先要知道的是一个<strong>定义</strong>, 因为有了定义我们才能获取更多的资料来了解它.</p>
<hr />
<p>在上一步中, 我们将得到了A的定义和A的形态. 接下来是收集资料的过程, 所谓的手机资料, 就是了解关于A的描述, 并判断描述的可靠程度. 在这里为了避免歧义, 将<strong>关于A的描述</strong>定义为<strong>S</strong></p>
<p>以我个人的思考习惯, 我收集的S顺序如下</p>
<ol type="1">
<li><p>是什么, 在这一步将A划分到不同的类中, 常见的种类有</p>
<ul>
<li>静态(文学数学范畴, 通过语言给事物赋予定义)
<ul>
<li>①自然存在的实体, 比如西瓜</li>
<li>②人类定义的一些概念或构建的东西, 这些概念脱离了人就变得没什么意义, 比如三角形, 国家, 汽车</li>
</ul></li>
<li>动态(应用科学范畴, 学习规律并应用规律)
<ul>
<li>③自然界中的现象, 描述了静态物体的规律, 比如西瓜成熟, 下雨</li>
<li>④人类创造的流程, 描述了人类由驱动力<strong>Q</strong>而所做的操作, 比如三角变换, 建立国家, 造汽车</li>
</ul></li>
</ul>
<p><em>我认为A是有不同层次的, 是先有①③才能<span class="math inline">\(\to\)</span>②④, 不同种类的A所要收集的S也不同, 因为最近④涉及的比较多, 就以④为例讲讲之后的S收集顺序</em></p>
<p>我觉得④中的A都可以描述为一个函数 <span class="math display">\[
output=Function(input...)
\]</span> 第一步相当于先了解<span class="math inline">\(output\)</span>是什么, 因为这是④的外在表现形式</p></li>
<li><p>为什么, 这一步要了解<span class="math inline">\(output\)</span>在全局中的作用, 我们为什么要这个<span class="math inline">\(output\)</span>, 有什么目的, 好处是什么. 不过这个问题可以一直问下去, 最后得到的答案将是虚无, 所以<strong>为什么</strong>这个问题要适可而止</p></li>
<li><p><span class="math inline">\(input\)</span>, 了解我们需要什么才得出<span class="math inline">\(output\)</span></p></li>
<li><p><span class="math inline">\(Function\)</span>, <span class="math inline">\(Function\)</span>可以分解成一小步一小步, 每一步中都包含了③②①甚至更小的④, 所以这一步一般是最花费时间的, 所幸大部分时候我们不需要做到这一步</p></li>
</ol>
<hr />
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>skills</tag>
      </tags>
  </entry>
  <entry>
    <title>日本简史</title>
    <url>/2017/04/10/Life/japan-history/</url>
    <content><![CDATA[<h2 id="概况">概况</h2>
<h3 id="地理情况">地理情况</h3>
<ul>
<li>由北海道、本州、四国、九州 四个大岛和7000多个小岛组成，领土面积为中国的<span class="math inline">\(\frac{1}{25}\)</span>，四岛中<em>本州</em>最大，占<span class="math inline">\(60\%\)</span></li>
<li>表日本面向太平洋， 多雨，多工业区</li>
<li>里日本风雪较大，被称为“雪国”，多为农业区，人口稀少</li>
<li>火山多，活火山占全世界<span class="math inline">\(10\%\)</span></li>
</ul>
<a id="more"></a>
<h3 id="中日关系">中日关系</h3>
<ol type="1">
<li>公元前3世纪-公元3世纪：躲避战乱的中国人到日本农耕，畜牧的<em>弥生文化</em>提到了渔猎、采集的<em>绳文文化</em></li>
<li>600-894：以华为师，吸收隋唐先进文化</li>
<li>两宋、元、明：通过僧人传播文化</li>
<li>甲午战争后：日本文化对中国的逆向输出</li>
</ol>
<h2 id="简史">简史</h2>
<h3 id="日本人的起源">1 日本人的起源</h3>
<ul>
<li><p>旧石器时代：2-3万年前，冲绳出现了“山下町洞人”</p></li>
<li><p>绳文时代：磨石，陶器，原始部落</p></li>
<li><p>弥生时代：公元前3世纪，因为发现于弥生町；</p>
<p>水稻农业普及，身高150-160cm，外来人</p></li>
<li><p>邪马台国：部落联盟，阶级社会，大陆王朝册封</p></li>
<li><p>古坟时代：倭国，前方后圆坟。大和政权</p></li>
</ul>
<h3 id="律令国家">2 律令国家</h3>
<ul>
<li>律令国家：大和政权危机（589隋统一中国），强化中央集权，以天皇为中心</li>
<li>奈良时代：迁都京都（仿长安），出现了钱币，这个时期疆域扩大，经济发展</li>
<li>庄园、摄关政治：庄园、土地国有，开始出现纳税。天皇年幼“摄制”，长“关白”<span class="math inline">\(\to\)</span>“摄关”，藤原</li>
<li>武士、院政政治：武士为了保护庄园利益，天皇为了拜托控制，设置了“院厅”，院政</li>
<li>唐风文化：遣唐使，频繁来往，深受大唐文化影响</li>
</ul>
<h3 id="武人政权">3 武人政权</h3>
<ul>
<li>镰仓幕府：在镰仓设立了武家政权<em>幕府</em>，御家人（武士）</li>
<li>元军征日：两次征日均因为台风而失败，幕府衰退，文化受宋影响</li>
<li>南北朝：幕府灭亡，建立武新政。后被罢，于是向南逃，北边又建立了<em>室町幕府</em></li>
<li>室町幕府：公家政治丧失，余武家。基于守护邻国制，民间贸易频繁</li>
<li>文化演变：朱子学；佛教；禅宗；北山文化“金阁”；茶山文化“银阁”</li>
</ul>
<h3 id="前近代社会">4 前近代社会</h3>
<ul>
<li>战国大名：幕府丧失统治，各国大名建国，推动经济发展</li>
<li>织车时代：<em>织田信长</em>灭室町幕府，统一大半日本；赐姓<em>丰臣秀吉</em>，统一日本</li>
<li>早期德川幕府：秀吉死后，关原之战，德川家康于江户（东京）设幕府，幕藩制</li>
<li>后期德川幕府：亨保改革，稳定农村，抑制商品经济，幕府衰退</li>
<li>思想与文化：国学，兰学（西学，荷兰人），松尾芭蕉，绯句，歌舞伎，浮世绘</li>
</ul>
<h3 id="民治维新">5 民治维新</h3>
<ul>
<li>内外危机：封建制度位机，被（美）被迫开国，出现了阶级矛盾</li>
<li>王政复古运动：武士尊王攘夷，倒幕，天皇宣布废幕府</li>
<li>新政权的改革：江户改为东京；中央集权，废身份制度，经济改革</li>
<li>民治宪法体制：民族主义，立宪政治（天皇君主专制），工业革命</li>
</ul>
<h3 id="对外侵略扩张">6 对外侵略扩张</h3>
<ul>
<li>甲午战争：朝鲜半岛危机，李鸿章签马关条约，刺激了侵略扩张</li>
<li>日俄战争：争夺朝鲜半岛，重工业革命，出现财阀（三菱、三井、住友）</li>
<li>第一次护宪运动：工人运动发展，大正政变，反对军事扩张</li>
<li>参加一战：侵略山东，经济迅速发展，巴黎和会，凡尔赛条约</li>
<li>城市化及其影响：向西方学习，教育发展，大众传播媒体发展</li>
</ul>
<h3 id="变革与战争">7 变革与战争</h3>
<ul>
<li>各种社会运动：工农运动，女性争取解放，部落民运动</li>
<li>各种社会思想：民主主义，法西斯主义（对内军统，对外扩张）</li>
<li>政党政治：普选宪法（女性无权），出兵山东，经济危机</li>
<li>中日战争：侵占东北，政权法西斯化，1937.7.7 全面爆发</li>
<li>太平洋战争：日美对立，偷袭珍珠港，无条件投降</li>
</ul>
<h3 id="占领与战后体制">8 占领与战后体制</h3>
<ul>
<li>占领及改革：盟军进驻日本，改宪，象征天皇，放弃战争，废封建</li>
<li>政治与社会：建立政党，自由党，进步党，协同党</li>
<li>走向媾和：道奇计划（稳定经济9原则）</li>
<li>两党体制：自由党、社会党</li>
<li>民族主义：政治优先内阁。，反安保（日美安全保障条约）斗争</li>
</ul>
<h3 id="经济大国">9 经济大国</h3>
<ul>
<li>经济的季节： 官僚主导政治决策，经济高速发展，工业也是高速发展，变成发达国家</li>
<li>佐藤长期政权： 刺激经济，68年成为第二；社会矛盾突出，向往和平</li>
<li>田中角荣政权：中日邦交正常化，受石油危机影响物价上涨</li>
<li>政权的混乱：三足鼎立
<ul>
<li>保守：自民党</li>
<li>中道：公民党</li>
<li>革新：社会党</li>
</ul></li>
<li>稳定增长：克服石油危机，稳中上升</li>
</ul>
<h3 id="改革的年代">10 改革的年代</h3>
<ul>
<li>新保守主义改革：中曾根内阁，国企民营化；减少社会福利，加强教育</li>
<li>政治改革的启动：里库路特案；出兵海外法案；自民党下台</li>
<li>联合政权：选举、政治资金、助党；泡沫经济崩溃</li>
<li>桥本内阁政权：刺激经济，政界分化组成。民主党和自民党对立</li>
<li>结构改革：91-01经济低迷，民族主义思潮</li>
</ul>
<h3 id="漂流的国度">11 漂流的国度</h3>
<ul>
<li>短命的自民党内阁：三界政权暗淡无色，经济再陷入危机，外交平衡</li>
<li>混乱的民主党政权：政局不稳，天灾人祸，摇摆的外交</li>
<li>再次翻盘的大选：频繁更换首相，2012年大选，12个政党</li>
<li>第二次安倍政权：安倍经济学，安保法案，加入TPP</li>
<li>停滞的社会：少子化，老龄化；收入差距加大</li>
</ul>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>history</tag>
      </tags>
  </entry>
  <entry>
    <title>社会心理学</title>
    <url>/2018/05/06/Life/social-psychology/</url>
    <content><![CDATA[<h2 id="导读">0 导读</h2>
<p>学科分类:应用学科,基础学科:遵循实证研究、证据的科学方法</p>
<p>作:科学性,人性。社会学研究起步晚,很多方面继可作解答:新态度,说服/彼此伤害、帮助/冲突 本书结构</p>
<ol type="1">
<li>研究方法: 重要思想</li>
<li>社会思维: 如何看待自己和他人</li>
<li>社会影响: 文化,从众,说服,影响。</li>
<li>人际关系: 偏见,协攻击,吸引帮助</li>
<li>在生活中的应用</li>
</ol>
<a id="more"></a>
<h2 id="社会心理学导论">1 社会心理学导论</h2>
<h3 id="什么是社会心理学">什么是社会心理学:</h3>
<p>研究周围情境的力量, 如何看待, 影响他人</p>
<ul>
<li><p>重要问题:行为与脑,人性。这是为了助人助己?</p></li>
<li><p>重要观点:构建社会:社会直觉(无意识),态度性格决定行为.</p>
<p>社会行为<span class="math inline">\(\to\)</span>生物性行为.信念</p></li>
<li><p>相关学科:社会学(注重团体)人格心理学:关注个体差异</p></li>
</ul>
<h3 id="人类价值观">人类价值观</h3>
<p>回答的策略。知觉为预期所左右。是,应该是,道德的鸿沟</p>
<p>是常识吗? 知道事实后才意识到其的存在。所以不太算常识</p>
<ul>
<li><strong>谚语存在矛盾</strong>,我们需要区分真正的预测和事后清葛</li>
</ul>
<h3 id="研究方法">研究方法</h3>
<ul>
<li>假设.验证: 理论,假设,(证伪,规律,可预测)</li>
<li>相关研究: 不同变量对结果的影响</li>
<li><strong>因果</strong>,相关: 需要找到因果关系,<strong>相关无法解释因果</strong></li>
<li>调查研究: 随机取样。问题的顺序, 答案的编制, 问题的措辞都会影响</li>
</ul>
<p>用批判的思维制约查觉,用判断力提纯情感,用理解替代幻想</p>
<h2 id="社会中的自我">2 社会中的自我</h2>
<p>绪论: 人总高估自己的影响(焦点效应),自利, 自我关注, 界定自我</p>
<h3 id="自我概念-我是谁">自我概念: 我是谁</h3>
<ul>
<li><p>核心:自我感觉:对自己的判定(学者?运动员)</p></li>
<li><p>社会自我的发展:在不同环境中,比较带来烦恼;他人的评价</p></li>
<li><p>自我与文化:个人、集体,文化对人思维方式的影响.如何定义自己</p></li>
<li><p>自我认识:解释行为(被影响)预测未来时应先回望过去</p>
<p>控制的过程是很复杂的,难解释,无意识</p></li>
</ul>
<h3 id="感知到的自我控制">感知到的自我控制</h3>
<ul>
<li>自我效能:对自己能カ与效率的乐观信念可似获得很大回报</li>
<li>控制点:发生的事是自己还是受外部环境控制?</li>
<li>习得性无助,当努力无法改变境况时。促进个人控制, 成功的体验给人更大的效能</li>
</ul>
<h3 id="自尊">自尊</h3>
<ul>
<li>动机:高自尊(维持自己的价值)因为人际关系有导向意义,需要他肯定</li>
<li>阴暗面:自尊受威胁时,打压他人,建立在外貌, 金钱, 别人赞美</li>
</ul>
<h4 id="存在自我偏见">存在自我偏见:</h4>
<ul>
<li><p>对事件的解释:成功源于能力、失败归于运气。</p></li>
<li><p>高于平均水平? 把自己擅长的归于重要的,不擅长的归于不重要</p></li>
<li><p>盲目的乐观:增加了我们的脆弱性,而不去采取明智措施</p>
<p>防御性悲观主义:卖弱</p></li>
<li><p>虚假普遍性:获得的样本太少,不能得出正确的结果</p></li>
</ul>
<p>这些情况的解释是: 都是在寻求自我确认,希望提升自我形象</p>
<p>反思:这些是虚伪, 我们应该有真正的谦卑</p>
<h3 id="自我展示">自我展示</h3>
<p>自我妨碍: 给自己创造失败的理由</p>
<p>印象管理: 自我监控, 他人印象</p>
<h2 id="社会信念与判断">3 社会信念与判断</h2>
<h3 id="我们如何解释他人">我们如何解释他人</h3>
<p>使事情可理解</p>
<ul>
<li>归因:个人?环境?同时考虑内因外因</li>
<li>经常犯的错误: 归因错误:低估环境的影响</li>
<li>为什么犯错,: 身份不同, 行动者,观察者。观点的变化, 文化差异</li>
</ul>
<h3 id="社会信念">社会信念</h3>
<p>预先判断,信念固着。修正记忆, 重构经历</p>
<p>选择性注意,解释某事</p>
<h3 id="怎样做出正确判断">怎样做出正确判断</h3>
<p>真觉的力量。避免过度自信(即时反馈,考虑偏差)</p>
<p>考虑情绪, 错觉</p>
<h3 id="信念倾向于自我实现吗">信念倾向于自我实现吗</h3>
<p>信念有产生重要作用,认为自己很强</p>
<h3 id="结论-思维存在不足">结论: 思维存在不足</h3>
<blockquote>
<p>应该要: 批判而不愤世嫉俗,好奇而不受蒙蔽</p>
</blockquote>
<h2 id="行为和态度">4 行为和态度</h2>
<h3 id="态度决定行为吗">态度决定行为吗?</h3>
<p>态度不能很好预测行为(言行不一)</p>
<p>态度,行为受多因素影响。</p>
<h3 id="行为何时决定态度">行为何时决定态度</h3>
<ul>
<li>角色扮演,邪恶行为、社会运动</li>
<li>坚持自己相信的,相信自己坚持的</li>
</ul>
<p>为什么会这样呢? 这是自我展示的需要, 通过让自己言行合一来减少不适感</p>
<blockquote>
<p><strong>我们可以通过行为来改变自己</strong></p>
</blockquote>
<h2 id="基因文化和性别">5 基因、文化和性别</h2>
<h3 id="自然天性文化多样性的影响">自然天性、文化多样性的影响</h3>
<p>基因上大致相同,人类是文化规范的产物, 存在有普遍的社会规范</p>
<h3 id="如何解释性别">如何解释性别</h3>
<p>个体差异远超性別差异,平均水平上有所差异</p>
<h3 id="进化与性别什么样的行为是天生的">进化与性别:什么样的行为是天生的</h3>
<p>进化学派(自然造成:生殖能力地位)但无法解释文差异。</p>
<h3 id="文化与性别行为受文化影响吗">文化与性别:行为受文化影响吗</h3>
<p>文化影响性别角色。时代表化。通过同伴的影响。</p>
<h3 id="结论">结论</h3>
<p>文化在生物因素的基础上对个体施加影响。</p>
<blockquote>
<p>如何看待自己与社会</p>
<ul>
<li>避免专断:他人自由:自己受影响</li>
<li>自我效能:把自己看作自由, 默认他人受环境束缚</li>
</ul>
</blockquote>
<h2 id="从众">6 从众</h2>
<h3 id="什么是从众">什么是从众?</h3>
<p>和其他两个概念区分开来</p>
<ul>
<li>服从(顺从), 奖励惩罚</li>
<li>接纳,共同价值观</li>
</ul>
<h3 id="经典从众理论">经典从众理论</h3>
<p>由于群体压力或信念。他人判断影响自己判断</p>
<h3 id="什么因素可以预测从众">什么因素可以预测从众</h3>
<p>群体特征:人数、地位</p>
<p>事先有无做出过承诺</p>
<h3 id="为什么会从众">为什么会从众</h3>
<ul>
<li>规范影响:人们希望获得别人的接纳</li>
<li>信息影响:其他人为自己提供事实证据</li>
</ul>
<h3 id="谁会从众">谁会从众</h3>
<p>不是个人的,而是社会所共有的。社会敏感性</p>
<blockquote>
<p>如何抵制压力, 有逆反心理, 意识到自己的与众不同</p>
</blockquote>
<h2 id="说服">7 说服</h2>
<p>轻信和盲从,仍是支配人类心灵的弱点</p>
<h3 id="说服的途径有哪些">说服的途径有哪些</h3>
<p>注意<span class="math inline">\(\to\)</span>理解<span class="math inline">\(\to\)</span>记住<span class="math inline">\(\to\)</span>行动: 中心途径</p>
<p>外部线索<span class="math inline">\(\to\)</span>提示: 外围途径</p>
<h3 id="说明的要素">说明的要素</h3>
<p>谁用什么方法将什么信息传递给了谁。</p>
<ul>
<li>发言者:语气果断,语速较快,直视听众眼睛.</li>
<li>说了什么:情绪好时更易接受他人, 要搞笑</li>
<li>沟通渠道:面对面-书面-大众传媒</li>
</ul>
<h3 id="邪教如何进行精神灌输">邪教如何进行精神灌输</h3>
<p>行为承诺的强调、运用说明原则,将人孤立在思想</p>
<h3 id="如何抵制被说服">如何抵制被说服</h3>
<p>预先公布自己的立场。温和地攻击。</p>
<p><strong>人是否有观点?</strong></p>
<blockquote>
<p>开明但不要天真<span class="math inline">\(\to\)</span>是否经得起推敲 遇到的每个人都可以充当我们的老师</p>
</blockquote>
<h2 id="群体影响">8 群体影响</h2>
<h3 id="什么是群体">什么是群体</h3>
<p>互动并影响</p>
<h3 id="社会助长作用怎样受他人在场影响">社会助长作用:怎样受他人在场影响</h3>
<p>观察者在场时,会提高简单任务的成绩。评价顾忌</p>
<h3 id="社会懈怠个人在群体中会减少投入吗">社会懈怠:个人在群体中会减少投入吗?</h3>
<p>当完成集体任务而个人努カ无法评价时,会消极</p>
<h3 id="去个体化何时失去自我感">去个体化:何时失去自我感</h3>
<p>匿名性:自我约束减弱。放弃道德约束</p>
<h3 id="群体极化群体会强化我们的观点吗">群体极化:群体会强化我们的观点吗</h3>
<p>交流会强化观点, 要多和别人交流</p>
<h3 id="群体思维群体会阻碍还是促进好的决策">群体思维:群体会阻碍还是促进好的决策:</h3>
<p>对<strong>一致</strong>的渴望要求压倒真实评价。需要洞察力。</p>
<h3 id="少数张影响个体如何影响群体">少数张影响:个体如何影响群体。</h3>
<p>当少数派具有一致性并且自信地坚持自信鼓舞他人.</p>
<p>群体可以很好也可以很坏。更紧张, 压制思维</p>
<p>但人是群居动物,为了生活资料、支持和安全感</p>
<hr />
<p><strong>社会关系篇</strong></p>
<h2 id="偏见不喜欢他人">9 偏见:不喜欢他人</h2>
<p>本质是<strong>喜欢自己的群体</strong></p>
<h3 id="偏见的本质">偏见的本质</h3>
<p>一种预判性的负面态度,刻板化的信息、潜伏</p>
<h3 id="偏见的社会根源">偏见的社会根源</h3>
<p>为自己的地位做辩解、家庭社会制度助长</p>
<h3 id="偏见的动机根源">偏见的动机根源</h3>
<p>挫折滋生效意,希望自己所在群体更加优越的愿望。</p>
<h3 id="偏见的认知根源">偏见的认知根源</h3>
<p>我们简化世界,夸大了群体内的一致性和差异性,将他人行为归结于内在品质。</p>
<h3 id="偏见的后果">偏见的后果</h3>
<p>刻板印象一旦形成, 就越趋向于永久存在,通过自我实现创造对应的现实</p>
<p>改变: 我们应该谋求更加平等的合作关系, 通过法律要求而非歧视</p>
<h2 id="攻击行为">10 攻击行为</h2>
<p>人类可以非常残忍</p>
<h3 id="什么是攻击行为">什么是攻击行为</h3>
<ol type="1">
<li>敌意性攻击</li>
<li>工具性攻击</li>
</ol>
<p>来源于</p>
<ul>
<li>本能</li>
<li>挫败(自我期望与现实)</li>
<li>习得(观察,可以获得好处)</li>
</ul>
<h3 id="攻击行为的影响因素">攻击行为的影响因素</h3>
<ul>
<li>挫折、不适、锻炼、性刺激会转化为愤怒</li>
<li>电视节目、游戏、色情会扭曲社会认知</li>
<li>群体的影响</li>
</ul>
<h3 id="如何减少攻击">如何减少攻击</h3>
<p>(宣泄会更多地引发攻击)</p>
<p>通过减少令人厌恶的刺激,奖励和塑造非攻击行为</p>
<blockquote>
<p>法律和执行法固然有用,改变文化才是根本</p>
</blockquote>
<h2 id="吸引和亲密喜欢他人和爱他人">11 吸引和亲密:喜欢他人和爱他人</h2>
<p>我们有“归属需要”,与他人建立持续而亲密关系的需要</p>
<h3 id="什么造就了友谊和吸引">什么造就了友谊和吸引</h3>
<ul>
<li>接近性</li>
<li>决定吸引力一外表, 与喜欢我们的人建立友谊(原因:利</li>
<li>态度,价值观的相似性。</li>
<li>与喜欢我们的人建立友谊(原因:利</li>
</ul>
<h3 id="什么是爱情.">什么是爱情.</h3>
<p>亲密,激请、承诺,在浪漫环境中,任何刺激造成的唤醒水平都可以称为激情</p>
<h3 id="促进亲密关系的因素">促进亲密关系的因素</h3>
<p>依恋、亲密的自我表露。付出与回报成比例伴侣之爱,持久亲密关系的结束:积极的,非对抗的沟通方式</p>
<p>婚姻关系, 幸福生活, 当代亲密而持久的婚姻关系正在减少</p>
<h2 id="利他-帮助他人">12 利他: 帮助他人</h2>
<h3 id="我们为什么有帮助行为">我们为什么有帮助行为</h3>
<p>社会交换理论:代价小,收益大,帮助他人,消除内疚,维护形象</p>
<p>社会规范理论:互惠规范</p>
<p>进化心理学:帮助近亲或互利关系,自私的多,因此鼓励无私. 真正的共情的利他主义]</p>
<h3 id="何时会帮助">何时会帮助</h3>
<p>观察到其他人的帮助行为,时间不太紧的时候</p>
<p>旁观者增加将抑制利他主义</p>
<h3 id="如何增加帮助行为">如何增加帮助行为</h3>
<p>诱导:产生吸引力, 增加责任感、激起内疚感</p>
<p>强制行善会减少自发之爱。</p>
<blockquote>
<p>将社会心理学应用于生活</p>
</blockquote>
<h2 id="冲突和和解">13 冲突和和解</h2>
<h3 id="什么会引起冲突">什么会引起冲突</h3>
<ul>
<li><p>将个人利益看得更重,出现很多困境。因此立法限制利已</p>
<p>划分较小的社会群体以使人有更多责任感</p></li>
<li><p>为稀缺资源竞争,受到不公平对待、误解对方造成冲突</p></li>
</ul>
<h3 id="怎么获得和平">怎么获得和平</h3>
<ul>
<li>接触:平等地位的接触减少敌意</li>
<li>合作:为实现同一个超级目标</li>
<li>直接谈判:将非输即赢逻辑变成“双赢”取向</li>
</ul>
<p>个人权利和公共权利之间的冲突</p>
<ul>
<li>个人主义, 共产主义各有弊端</li>
<li>要思考如何做好个人与公共权利之间的平衡</li>
</ul>
<hr />
<p>应用社会心理学篇</p>
<h2 id="社会心理学在临床领域中的应用">14 社会心理学在临床领域中的应用</h2>
<h3 id="什么导致了临床诊断的偏差">什么导致了临床诊断的偏差</h3>
<p>事后聪明导致判断的过分自信,错误误的诊断往往自我证实</p>
<p>治疗师倾向于问那些能肯定他们假设的问题</p>
<h3 id="伴随行为问题的认知过程">伴随行为问题的认知过程</h3>
<p>抑郁的人更消极的解释,回忆,对未来不抱希望。</p>
<p>积极的归因风格是有益的</p>
<h3 id="社会心理的治疗方法">社会心理的治疗方法</h3>
<ol type="1">
<li>外在行为的改变</li>
<li>改变思维方式</li>
<li>自信</li>
<li>他人帮助</li>
</ol>
<h3 id="社会关系如何促进健康与幸福感">社会关系如何促进健康与幸福感</h3>
<p>社会认知,社会关系影响健康和幸福</p>
<p>提升幸福感的方法:</p>
<ol type="1">
<li>幸福不来源于金钱。没有它使人痛苦,拥有但不一定幸福</li>
<li>设立目标,控制时间</li>
<li>表现出幸福。</li>
<li>寻找合适的工作,使技能得以发挥。</li>
<li>参加运动</li>
<li>保证足够睡眠</li>
<li>优先考虑亲密的人际关系</li>
<li>帮助他人</li>
<li>记录感恩日记</li>
<li>照顾精神自我, 信念</li>
</ol>
<h2 id="社会心理学在司法领域中的应用">15 社会心理学在司法领域中的应用</h2>
<h3 id="目击者的证词可靠吗">目击者的证词可靠吗</h3>
<p>目击者的心理记录仪<em>不会犯大错</em></p>
<p>但当构建和复述所观察到的事时,错误就潜入了</p>
<h3 id="影响陪审团判断的其他因素">影响陪审团判断的其他因素</h3>
<ul>
<li>事实足够时,判决偏向于公正。</li>
<li>证据模糊时,倾向于先入为主的偏见</li>
</ul>
<h3 id="什么影响了个体陪审员">什么影响了个体陪审员</h3>
<p>个人因素,法官指示、构思一个可以解释的故事</p>
<h3 id="群体因素对陪审员的影响">群体因素对陪审员的影响。</h3>
<p>说服性论证,群体极化、信息交换。</p>
<blockquote>
<p>更聪明地思考</p>
<ul>
<li>知识受直觉,偏见的控制</li>
<li>做出判断不要依赖直觉,要科学分析、测试自己的预测和偏见</li>
</ul>
</blockquote>
<h2 id="社会心理学与可持续发展的未来">16 社会心理学与可持续发展的未来</h2>
<h3 id="什么是全球危机及如何应对">什么是全球危机及如何应对</h3>
<p>人口增长,消耗过多。要建立可持续发展的未来</p>
<h3 id="社会心理学中的物质主义和财富">社会心理学中的物质主义和财富</h3>
<p>财富带来更强烈的幸福感,但越来越多的钱带来边际效应</p>
<blockquote>
<p>个体在现代世界中要承担自己的责任</p>
</blockquote>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>psychology</tag>
      </tags>
  </entry>
  <entry>
    <title>皮肤变黑与变白</title>
    <url>/2019/08/22/Life/sunburn-repair/</url>
    <content><![CDATA[<h2 id="背景">0 背景</h2>
<p>最近去海滩边玩耍，因为没有做好足够的防晒措施，所以回来之后变黑了许多。</p>
<p>想来之前也没有研究过相关的知识，也想让皮肤变白一些，所以索性乘这个机会研究一下。</p>
<p>因为不相信网上流传的一些信息，所以选择一些论文内的信息来进行学习。本文主要基于的论文是一篇硕士论文，类似于综述，主要的内容有</p>
<ul>
<li>皮肤颜色的生理基础，也就是皮肤变黑的机理</li>
<li>常见美白活性物质及作用机理</li>
<li>功效与安全性评估试验</li>
</ul>
<a id="more"></a>
<h2 id="皮肤相关的预备知识">1 皮肤相关的预备知识</h2>
<p>皮肤分为表皮、真皮及皮下组织</p>
<p>决定肤色的主要因素</p>
<ul>
<li>皮肤内各类色素的含量与分布
<ul>
<li><strong>黑色素</strong>（Melanins）：主要因素中的主要因素</li>
<li>胡萝卜素</li>
<li>血红蛋白</li>
</ul></li>
<li>光线照射情况：灯光打得好，肤色没烦恼</li>
</ul>
<h3 id="黑色素">黑色素</h3>
<p>可以看到，黑色素是主要需要研究的对象，所以看看黑色素的产生及性质：</p>
<p><strong>产生过程</strong>：当皮肤暴露在紫外线下时，表皮内的细胞被刺激释放了一些细胞因子，刺激黑素细胞中的<strong>高尔基体</strong>经过一些列化学反应产生黑色素并转运到表皮。之后被降解</p>
<blockquote>
<p>因为不同地区的人们环境与基因不同，所以黑色素的降解过程不一样，导致不同人种的不同肤色。</p>
</blockquote>
<p><strong>晒黑机理</strong>：黑色素细胞是保护皮肤不受太阳射线伤害的特殊细胞，因此在人受到多于平时的太阳辐射时，肌肤产生更多的黑色素来进行保护皮肤</p>
<h3 id="解决方案">解决方案</h3>
<p>根据黑色素的产生过程，如下图</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/melanins-mechanics.png" /></p>
<p>切断<strong>酪氨酸(由高尔基体中的氨基酸变的)到多巴</strong>的过程比较直接，也就是说要</p>
<ul>
<li><strong>抑制酪氨酸酶</strong>:star:</li>
</ul>
<h2 id="常见美白物及其机理">2 常见美白物及其机理</h2>
<p>目标：抑制酪氨酸酶活性</p>
<ul>
<li>对苯二酚：分解黑色素，美白效果很强，但是毒性也很强</li>
<li>熊果苷：资生堂提取的，破坏、分解黑色素细胞，效果较好，<span class="math inline">\(\alpha-\)</span>熊果苷效果好</li>
<li>果酸：会破坏皮肤表层角质</li>
<li>L-乳酸钠与乳酸：抑制酪氨酸酶</li>
</ul>
<h2 id="功效及安全性实验">3 功效及安全性实验</h2>
<ul>
<li>测试指标：用前与用后的皮肤黑色素含量</li>
<li>实验组：…</li>
<li>实验对象：20-45岁的健康女性</li>
<li>实验方法：实验试剂用胶带贴于实验对象背部24小时，记录反应结果</li>
<li>实验结论：L-乳酸<span class="math inline">\(+\alpha-\)</span>熊果苷 的效果较好</li>
</ul>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>skill</tag>
      </tags>
  </entry>
  <entry>
    <title>提高打字速度</title>
    <url>/2019/08/22/Life/type-fast/</url>
    <content><![CDATA[<h2 id="标准指法">标准指法</h2>
<p><a href="https://www.typingclub.com">typingclub</a>练习标准指法的网站，网站做的很好看，界面互动很优秀.</p>
<p>键盘上的<code>F</code>,<code>J</code>上面有一个横杠，这两个是用来定位的，将两只手的食指放在那两个键位上</p>
<p>主要思路是让手养成<strong>肌肉记忆</strong>，用最短的路径去拼写单词</p>
<ul>
<li>多次、重复的练习</li>
</ul>
<p><strong>我的经验：先在这个网站上学习标准指法，即各个按键应该用哪个手指按，大概是87课左右</strong></p>
<h2 id="如何提高打字速度">如何提高打字速度</h2>
<p><a href="https://www.keybr.com/">keybr</a>一个练习打字的网站</p>
<p>这个网站提高打字速度的思路：</p>
<ol type="1">
<li><p>先练习一些常用单词的拼写</p></li>
<li><p>keybr会记录拼写这些单词的时间来评估你的速度</p></li>
<li><p>拼写更多更难的单词</p></li>
</ol>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>skill</tag>
      </tags>
  </entry>
  <entry>
    <title>Cognitive Science&#39;s Brief History</title>
    <url>/2019/09/09/Philosophy/cognitive-history/</url>
    <content><![CDATA[<h2 id="overview">Overview</h2>
<p>This article is a note I wrote while reading the post in <a href="https://www.nature.com/articles/s41562-019-0626-2">nature</a></p>
<p>The are mainly 6 fields in the cognitive science community</p>
<ul>
<li>Psychology</li>
<li>Linguistics</li>
<li>Artificial Intelligence</li>
<li>Anthropology</li>
<li>Philosophy</li>
<li>Neuroscience</li>
</ul>
<a id="more"></a>
<p>Cognitive science has a short history if we check out the creation of the flagship journal in this fiel—<em>Cognitive Science</em>—is in1977.</p>
<p>In the post, author use <strong>bibliometric indicators</strong> and <strong>socio-institutional indicators</strong> to analyze the development of cognitive science</p>
<h2 id="the-challenge">The Challenge</h2>
<p>The difficulties from the beginning was achieving <strong>interdisciplinary</strong></p>
<p>Howard Gardner wrote an influential book <em>Mind‘s New Science</em>. In the book, Howard characterized some essnetial original features of the cognitive science</p>
<ul>
<li>it’s necessary to speak about mental representations and separate from biological</li>
<li>“the faith that central to any understanding of the human mind is the electronic computer.” — ragard brain as a device like computer</li>
</ul>
<p>So in 1970s and 1980s, it’s hard for the community to give a defintion that can won the support of a majority of cognitive scientist</p>
<p>In 1990s, the challenge became even harder since new frameworks such as</p>
<ul>
<li>‘connectionism’ challenged the basic assumption that the mind performed computations <strong>serially</strong></li>
<li>‘distrtibutied cognition’ argued that cognition does not reside in <strong>individuals</strong>’s head but among enviroments</li>
<li>‘embodied cognition’ advanced the theory that cognition is grounded in bodily features rather than <strong>amodal representations</strong></li>
<li>…</li>
</ul>
<p>All in all, cognitive science has been <strong>multidiscipinary</strong> from its birth.</p>
<ul>
<li>Multidiscipinarity: just like control theory, draws on knowledge from different disciplines but stays within their boundaries. So you can find people do the related research in different fields, but using the same tools—cognitive science or control science etc.</li>
<li>Interdisciplinarity: synthesizes and harmonizes links between disciplines into a coordinated and coherent whole. There would be new theory invented by researchers rather than using the old tools.</li>
</ul>
<h2 id="the-situation">The Situation</h2>
<p>Most of the researcher in cognitive science focus on Psychology(about 60%)</p>
<h3 id="training">Training</h3>
<p>The doctoral training for an academic field is critical.</p>
<p>Only 4 universities offered doctoral program for exactly “Cognitive Science”</p>
<ul>
<li>JHU</li>
<li>RPI</li>
<li>UCSD</li>
<li>CEU</li>
</ul>
]]></content>
      <tags>
        <tag>tips</tag>
        <tag>cs</tag>
      </tags>
  </entry>
  <entry>
    <title>共产党宣言概括</title>
    <url>/2018/04/12/Philosophy/comm-intro/</url>
    <content><![CDATA[<h2 id="历史背景">历史背景</h2>
<ol type="1">
<li>阶级条件:资本阶级的迅猛发展,无产阶级壮大了</li>
<li>社会条件:社会矛盾日益激烈。私人占有制与资本主义的矛盾</li>
<li>经济方面:经济危机暴发,资本主义弊端显露</li>
<li>理论条件:马克思唯物辩证观,历史唯物主义,剩余价值</li>
</ol>
<h2 id="内容概要">内容概要</h2>
<h3 id="资产者与无产者">1 资产者与无产者</h3>
<p><em>分析了资产阶级,无产阶级的产生、发展和斗争过程</em></p>
<p>目前为止社会的历史是阶级斗争的历史</p>
<p>资产阶级来源于早期城市居民、革命生产工具,生产关系</p>
<p>推动生产カ发展,但由于私有制和社会化生产的矛盾,必然导致经济危机。</p>
<p>无产阶级会反抗,消灭一切剥削制度,解放全人类</p>
<a id="more"></a>
<h3 id="无产者和共产党人">2 无产者和共产党人</h3>
<p><em>谈共产党的性质,特点纲领和路线</em></p>
<p>革命的最近目的是夺取政权,最高纲领,消灭私有, 实现共产。</p>
<p>批判了反对者的诬蔑,自由(消灭资本的自由, 消灭奴役他人的权力)懒惰(生产不会停止)</p>
<p>工人没有祖国,首先要建立无产阶级政权,消灭剥削(人与人之间), 进而消除民族与民族之间的剥削</p>
<h3 id="共产主义的文献和社会主义">3 共产主义的文献和社会主义</h3>
<p><em>批判与科学社会主义对立的假社会主义</em></p>
<ol type="1">
<li><p>反动的社会主义</p>
<p>封建, 小资产阶级, 德国的或"真正的"社会主义</p></li>
<li><p>保守的, 资产阶级的社会主义</p>
<p>用改良来缓和矛盾, 维护统治</p></li>
<li><p>空想主义</p>
<p>认识问题不够深刻造成</p></li>
</ol>
<p>真正的共产主义</p>
<ul>
<li>维护无产者的利益</li>
<li>财产公有代替私有</li>
<li>用暴力消除私有</li>
</ul>
<h2 id="共产党人对各种反对党派的态度">4 共产党人对各种反对党派的态度</h2>
<p>阐述无产阶级的征值斗争的基本原理</p>
<p>为了短期目标, 和非无产阶级联合, 目前实际还不够成熟</p>
<blockquote>
<p>全世界无产者, 联合起来</p>
</blockquote>
]]></content>
      <categories>
        <category>Philosophy</category>
      </categories>
      <tags>
        <tag>psychology</tag>
      </tags>
  </entry>
  <entry>
    <title>What is Philosophy</title>
    <url>/2019/06/15/Philosophy/edi-intro/</url>
    <content><![CDATA[<h2 id="what-is-philosophy">What is philosophy</h2>
<p>This is a course note for the <a href="https://www.coursera.org/learn/philosophy/home/welcome">Introduction to Philosophy</a> provided by University of Edinburgh hold on Coursera.</p>
<p>definition:</p>
<p><span class="math inline">\(the\ activity\ of\ working\ out\ the\ right\ way\ of\ thinking\ about\ things.\)</span></p>
<p>So we need to <strong>stick in and do it</strong> to understand philosophy</p>
<a id="more"></a>
<h3 id="relation-with-other-subject">relation with other subject</h3>
<p>we need to do philosophy by the challenges or results that other subjects throw up</p>
<p>e.g.</p>
<ul>
<li>Physics
<ul>
<li>Normal physics: getting the way subject move</li>
<li>philosophy of physics: asking questions to change the way how we think physics, like “What is physical reality”</li>
</ul></li>
<li>Medicine
<ul>
<li>Normal medicine: how to heal people according to current best medical theories</li>
<li>philosophy of medicine: “what health and sickness is”</li>
</ul></li>
</ul>
<h2 id="philosophy-is-difficult-but-important">Philosophy is Difficult but Important</h2>
<p>Philosophy question is raised anywhere because we can <strong>always</strong> step back and think about <span class="math inline">\(Why\)</span> and try to <strong>answer</strong> the questions.</p>
<p>Most philosophy aims at <em>thinking clearly about the things that matter most to us</em>.</p>
<ul>
<li>Our current thinking might be wrong, so we need to <strong>step back</strong> and examine our thinking.</li>
</ul>
<h2 id="how-to-do-philosophy">How to do Philosophy</h2>
<p>Trying to think about things in the right way is something we do <strong>all the time.</strong></p>
<h3 id="think-about-arguments-do-a-good-job-of-establishing-their-conclusion">Think about arguments do a good job of establishing their conclusion</h3>
<p>e.g. Should I go to the cinema tonight? what we should do to make decision?</p>
<ul>
<li>Looking for evidence</li>
<li>Thinking about the evidence gives you reasons to do or not</li>
<li>Coming to a conclusion</li>
</ul>
<p>Valid argument: if the premises are true, the conclusion <strong>have</strong> to be true</p>
<p>Sound argument: valid argument with true premises</p>
<hr />
<p>Philosophy needs vision and argument</p>
<ul>
<li>We need to keep a big picture in mind
<ul>
<li>do we free will? We should not only focus the conclusion given by the premises, but try to understand what it means for us when we say “free will”</li>
</ul></li>
<li>Not only arguments,</li>
</ul>
<h2 id="how-do-we-know-philosophy-works">How do we know Philosophy works?</h2>
<h3 id="humes-idea">Hume’s idea</h3>
<p>The most important constrain: the way world works should be the same as we think</p>
<p>Our experience tells us much less about the world than we usually think</p>
<ul>
<li>Causation, we just see a series of things</li>
<li>Ourselves, we just feel some feelings or emotions</li>
</ul>
<p>So we can not find answer to questions that related to the term above</p>
<h3 id="kants-idea">Kant’s idea</h3>
<p>We need to <strong>prove</strong> that philosophical thinking could put us in touch with the world</p>
<p>He thinks Causation are true in our mind and true in real world</p>
<p>If the world is not work in this way, we can not image in such way either.</p>
]]></content>
      <categories>
        <category>Philosophy</category>
      </categories>
      <tags>
        <tag>Philosophy</tag>
        <tag>introduction</tag>
      </tags>
  </entry>
  <entry>
    <title>Political Philosophy</title>
    <url>/2019/06/16/Philosophy/edi-law/</url>
    <content><![CDATA[<h2 id="overview">Overview</h2>
<p>Do we have an obligation to obey laws?</p>
<p>Political Philosophy is examine philosophical questions about</p>
<ul>
<li>the <strong>relationship between states and its citizen</strong></li>
<li><strong>relations between states</strong></li>
<li><strong>political obligation</strong></li>
</ul>
<a id="more"></a>
<h2 id="problem-of-political-obligation">Problem of Political Obligation</h2>
<p>State make demands to us</p>
<ul>
<li>Taxes, Army</li>
</ul>
<p>The <strong>problem </strong>is Why should we obey the laws</p>
<blockquote>
<p>Note: $Obeying = Complying $</p>
<ul>
<li>Comply: do what the law commands, or they will be punished</li>
<li>Obey: do what the law commands because the law commands it</li>
</ul>
</blockquote>
<h2 id="the-grounds-of-political-obligation">The Grounds of Political Obligation</h2>
<ul>
<li><p><strong>benefit</strong> theory, can be divided in 2 parts</p>
<ul>
<li><p>people benefit from state—clear</p></li>
<li><p>people have to obey the law—not clear,because:</p>
<ul>
<li><p>does being benefited always <strong>generate obligations</strong>?</p>
<p>No, if I do something for others, I get a “Thank you”, it’s not obligations</p></li>
<li><p>does being benefited generate obligations <strong>to obey</strong>?</p></li>
</ul></li>
</ul></li>
<li><p><strong>Consent</strong> theory: we've consented to the state and to having such obligations to it. Problem:</p>
<ul>
<li>Insufficient people have given consent
<ul>
<li>Reply: <strong>Expressed</strong> and <strong>tacit</strong> (vote  using public services) consent</li>
</ul></li>
<li>it only generates obligation if one is able to withhold consent</li>
<li>Too easy to avoid
<ul>
<li>Reply, it’s not easy to avoid tacit cosent
<ul>
<li>Re:Reply, many people have no effective alternative to remaining within their state</li>
</ul></li>
</ul></li>
</ul></li>
<li><p><strong>Fairness</strong> theory: Citizens are a part of cooperative enterprises that are mutually beneficial and fair.</p>
<ul>
<li>We’re born in states</li>
<li>We’re limited in our ability to leave the state</li>
</ul></li>
</ul>
<h2 id="what-if-the-problem-cant-be-solved">What if the Problem can’t be solved</h2>
<p>We should reconsider states</p>
]]></content>
      <categories>
        <category>Philosophy</category>
      </categories>
      <tags>
        <tag>Philosophy</tag>
        <tag>introduction</tag>
      </tags>
  </entry>
  <entry>
    <title>About Morality</title>
    <url>/2019/06/16/Philosophy/edi-mora/</url>
    <content><![CDATA[<h2 id="overview">Overview</h2>
<p>We live with some sense of what is good or bad, better or worse.</p>
<p>So what is all the morality about?</p>
<p>Focus on the <strong>status</strong> of daily morality. , That is:</p>
<ul>
<li>are we talking about objective things?</li>
<li>or our habbit</li>
<li>something exist in the universe?</li>
</ul>
<p>There are 3 theories :</p>
<ol type="1">
<li>objective, we are representing some object</li>
<li>relative, describe some kind of culture or personal approach</li>
<li>emotion</li>
</ol>
<a id="more"></a>
]]></content>
      <categories>
        <category>Philosophy</category>
      </categories>
      <tags>
        <tag>Philosophy</tag>
        <tag>introduction</tag>
      </tags>
  </entry>
  <entry>
    <title>Neuroscience and Aritificial Intelligence</title>
    <url>/2019/09/11/Philosophy/neuro-ai/</url>
    <content><![CDATA[<h2 id="overview">Overview</h2>
<p>Neuroscience-Inspired Artificial Intelligence, a <a href="https://www.cell.com/neuron/fulltext/S0896-6273(17)30509-3">paper</a> released by <em>DeepMind</em> in <em>Cell</em></p>
<p>Why neuroscience is important for AI?</p>
<ul>
<li>inspiration</li>
<li>validation</li>
</ul>
<p>But in practical, biological plausibility is just a guide, not a strict requirement.</p>
<p>What can we do? Marr and Poggio stated that there are 3 layers of analysis</p>
<ol type="1">
<li><strong>top level</strong>: the goal of the system</li>
<li><strong>mid level</strong>: the process and computations, also called algorithmic level</li>
<li>bottom level: how to implement the system physically</li>
</ol>
<p>What DeepMind do is focusing the top 2 level of the analysis</p>
<a id="more"></a>
<h2 id="some-history">Some History</h2>
<h3 id="deep-learning">Deep Learning</h3>
<p>The origin of deep learning lies directly in neuroscience</p>
<p>Some key timestamp:</p>
<ol type="1">
<li><p>Construction of neural networks —McCulloch and Pitts, 1943</p>
<p>later other researcher add feedback for improvment</p></li>
<li><p>Backpropagation algorithm allowed learning multiple layers —Rumelhart et al., 1985, Werbos, 1974</p></li>
<li><p>back that time, most AI researchers was focused on building logical processing systems based on <strong>serial computation</strong> inspired by symbolic. <strong>Parallel distributed processing(PDP)</strong> is a very important tools used then. And many ideas had a sustained influence on AI research such as NLP and CV or dropout</p>
<p>But stochastic and highly parallelized information processing makes pure symbolic method not practical</p></li>
</ol>
<h3 id="reinforcement-learning">Reinforcement Learning</h3>
<p>RL methods address the problem of how to maximize future reward by mapping states in the environment to actions and are among the most widely used tools in AI research. —Sutton and Barto, 1998</p>
<p>RL methods were originally inspired by research into animal learning. In paticular, the development of <strong>temporal-difference</strong>(TD) methods, was intertwine with research into animal behavior in conditioning experiments</p>
<h2 id="nowadays">Nowadays</h2>
<h3 id="attention">Attention</h3>
<p>Biological brains are modular, with distinct but interacting <strong>subsystems</strong> playing key functions such as memory, languga, and cognitive control—Anderson et al., 2004/ Shallice, 1988</p>
<p>Most CNN models worked directly on entire images or video frames. But primate visual system works differently.</p>
<p>Visual <strong>attention shifts</strong> strategically among locations and objects, <strong>centering processing resources</strong> and representational coordinates on a series regions in turn.</p>
<p>In practical, the attention approach were subsequently shown to produce impressive performance at difficult multi-object recognition taks both in terms of <strong>accuracy</strong> and <strong>computational efficiency</strong></p>
<h3 id="episodic-memory">Episodic Memory</h3>
<p>A well known theme in neuroscience: intelligent behavior relies on <strong>multiple memory systems</strong></p>
<ul>
<li>reinforcement-based mechanisms: long-term memory</li>
<li>instance-based mechanisms: episodic memory</li>
</ul>
]]></content>
      <tags>
        <tag>tips</tag>
        <tag>cs</tag>
      </tags>
  </entry>
  <entry>
    <title>科学哲学导论</title>
    <url>/2020/04/29/Philosophy/philosophy-of-science/</url>
    <content><![CDATA[<h2 id="science-past-and-present">Science: Past and Present</h2>
<p>科学家如何获取知识? 怎么验证他们获得的知识是可靠的?</p>
<p>目前国家和机构花了很多钱在科研上, 那么科研的产出是什么呢?</p>
<ul>
<li>物理</li>
</ul>
<p>有多种多样的问题, 这些问题的共性是什么呢? 我们只有科研的方式才能解决这些问题吗?</p>
<h3 id="例1进化论">例1:进化论</h3>
<p>生物方面</p>
<h3 id="例2-宇宙时间">例2: 宇宙时间</h3>
<p>爱因斯坦, 宇宙扩张, NASA天文观察, 这是一个很大的工程项目</p>
<h3 id="例3-气候变化">例3: 气候变化</h3>
<h3 id="例4-大脑理论">例4: 大脑理论</h3>
<p>我们如何进行推理? 成年人和儿童的大脑工作方式. 就算我们有了一个结果, 我们如何解释也是一个很大的问题</p>
<hr />
<p>不同的领域研究(时间)是非常不同的. 显然也不会有一种特别通用的方法能够适用于所有的领域, <strong>但是</strong>他们还是包含了一些共性</p>
<ul>
<li>都需要通过非常复杂的观察</li>
<li>都需要做实验</li>
<li>都是不同人用了很多不同的观测方式, 得出了类似的结果</li>
<li>一项研究都是慢慢积累的</li>
</ul>
]]></content>
      <tags>
        <tag>Philosophy</tag>
      </tags>
  </entry>
  <entry>
    <title>政治经济学序言</title>
    <url>/2018/04/12/Philosophy/politics-econo/</url>
    <content><![CDATA[<h2 id="历史背景">历史背景</h2>
<p>19世纪三四十年代,无产阶级作为政治力量登上历史舞台,革命实践迫切需要理论指导。马克思考察大量文献,总结自己的研究。序言是在整理手稿时写下,对唯物史观作了说明.</p>
<h2 id="内容概要">内容概要</h2>
<h3 id="马克斯研究政治经济学的动因">1 马克斯研究政治经济学的动因</h3>
<p>要对利益发表意见,迫使他正视社会现实。</p>
<p>要批判空想社会主义</p>
<a id="more"></a>
<h3 id="研究的经过">2 研究的经过</h3>
<p>唯物史观的确立<span class="math inline">\(\to\)</span>以此来分析政治经济学</p>
<h3 id="唯物史观的概括">3 唯物史观的概括</h3>
<ul>
<li>人们在自己生活的社会生产中发生一定的,必然的,不以他们的意志为转移的关系,即同他们的物质生产力的一定发展阶段相适应的生产关系。</li>
<li>生产关系的总和构成社会的经济结构,即有法律和政治的上层建筑竖立其上, 并有一定的社会意识形态与互相适应的现实基础。</li>
<li>物质生活的生产方式制约着整个社会生活、政治生活和精神生活的过程</li>
</ul>
<h2 id="唯物史观的基本结论">4 唯物史观的基本结论</h2>
<ol type="1">
<li>社会存在决定社会意识, 将社会关系归结于生产关系, 把生产关系归结于生产力</li>
<li>生产力决定生产关系, 经济基础决定上层建筑</li>
<li>物质生产力的发展是社会变革的终极原因</li>
</ol>
]]></content>
      <categories>
        <category>Philosophy</category>
      </categories>
      <tags>
        <tag>psychology</tag>
      </tags>
  </entry>
  <entry>
    <title>机器人与社会</title>
    <url>/2020/03/14/Philosophy/robot-society/</url>
    <content><![CDATA[<h2 id="动机">0 动机</h2>
<p>机器人不仅是一门有趣的综合学科, 更是对社会有着巨大影响力的高效工具. 在学习技术与理论之余, 我觉得机器人以及人工智能这类模仿人类的技术会对人类造成怎样的影响也是我们应该要关注的.</p>
<p>我觉得问题本质是技术的发展速度超前了人类的发展水平. 理想情况应该是机器完成大部分重复劳动, 包括体力和脑力上的, 而人类则从事更加具有创造性的工作以及追求个人理想.</p>
<p>然而现实情况是机器人技术发展迅速, 不同种类不同形态不同目的的机器人都在迅速丰富, 从面向生产的工业机器人, 到面向服务的服务机器人, 还有面向简单脑力活动的机器学习,机器视觉等. 各个国家也都有推动机器人发展的规划, 比如中国的2025, 德国的工业4.0, 都是在加快机器人的实际应用. 但目前的人类发展教育水平远远不足, 大部分人依然从事的是简单重复的工作.</p>
<p>比如说, 自动化的流水线会对普通工人有哪些影响? 如果所有的简单重复劳动都被机器人所取代, 那缺少一技之长的人应该如何应对? 一个人缺少足够的知识去完成更加高层次的工作, 那么他将无法养活自己与家人? 似乎在物质生产极大丰富之前这类人的生活需要就成了一个值得考虑的伦理问题, 那就是提高生产效率以及个人发展之间的矛盾. 在这样的矛盾下, 我们是否应该继续落实机器人技术? 如果要落实, 那么失业者要怎么办呢.</p>
<a id="more"></a>
<h2 id="他山之石">1 他山之石</h2>
<p>以下内容总结于Nils J. Nilson的<a href="https://www.aaai.org/ojs/index.php/aimagazine/article/view/433/369">Artificial Intelligence, Employment and Income</a></p>
<h3 id="常见观点">1.1 常见观点</h3>
<p>一正一反</p>
<ul>
<li>机器人技术就像其他的工程学科如电子电力/控制工程/机械工程一样虽然消灭了一些岗位但同时也了<strong>大量的就业机会</strong>(比如将现有的一些操作自动化), 并且大大提高人类的效率. 但是也要注意由机器人所创造的财富成果要合适地<strong>分配给需要财富的人</strong>(<em>存疑</em>), 这样才能促进消费和市场
<ul>
<li>举例: 发达国家用机器更多, 失业率比落后国家更低</li>
<li>一项研究(Levin and Rumberger) 表明技术发展其实带来的是工作难度的降低, 比如编程的工作难度相较以前是降低的</li>
<li>作者对这种观点表示悲观, 他认为机器人技术没有那么大的潜力</li>
</ul></li>
<li>机器人技术发展十分迅速, 即使机器人创造了一些岗位, 这些岗位的工作<strong>也能够被机器人所完成</strong>. 除此之外, 历史表明每次技术的革新都会带来失业率曲线的整体上移</li>
</ul>
<p>某样工作是否会被机器人取代主要是由经济/政治/社会决定的</p>
<ul>
<li>经济上来说, 主要的考量就是人工与机器完成同样的工作哪一个更加<strong>便宜</strong>
<ul>
<li>相比以前的机器来说, 机器人(泛人工智能)技术不算很贵, 未来也会更加便宜</li>
<li>根据经济学中的比较优势法则, 企业会同时使用两种劳动力. 但是这样如何保证工人的工资又是另一个问题了
<ul>
<li>诺贝尔经济学奖得主研究(Simon, 1977)的模型表明, 引入高效的机器会引起实际工资会上涨</li>
</ul></li>
</ul></li>
<li>社会上来说, 我们要考虑到某一个时代的人, 让他们有一些<strong>实际</strong>的工作可以去做. 虽然很多工作是不必要的, 但是为了一些人能够养活自己, 可能会出现一些不必要(对于社会来说)的工作岗位. 这些岗位只是为了工作而工作
<ul>
<li>人类在社会中既是<strong>生产者</strong>, 也是<strong>消费者</strong>
<ul>
<li>对于消费来说, 人作为消费的最终对象, 随着时间/技术/宣传的不同, <strong>需求</strong>实际上也是有着很多变化的, 比如有的东西之前很重要, 像钢铁, 但如果发明了新型塑料材料可以代替钢铁, 那么原来的钢铁需求就消失了. Vice versa. 但也要考虑到人类的需求是<strong>有极限</strong>的</li>
<li>对于生产来说, 生产的每个环节都包含了人力/资本/物质材料. 对于企业来说, 人力成本要减少的, 随着技术发展, 这样的趋势也是无法避免的. 这种趋势已经在(美国)农业中得到体现</li>
</ul></li>
<li>我们应该多创造一些"不能被自动化"的行业, 比如说护理, 教育, 婚姻咨询等. 但总体来看, 能够防止自动化的还是还是不够多</li>
</ul></li>
</ul>
<h3 id="为啥要避免失业">1.2 为啥要避免失业</h3>
<p>上面的讨论都是在围绕着就业和失业来展开的, 为什么要如此重视失业呢? 主要是有以下两点担忧</p>
<ul>
<li><p><strong>财富分配</strong>. 没有收入, 人们将没有工作来获取收入, 但是物质确实丰富的, 如何分配物质财富? 这样的困境就好像"所有人都在天堂中挨饿". 可能的解决办法</p>
<ul>
<li><p>憨憨:阻止技术发展? No way, 总有国家会采用技术的</p></li>
<li><p>简单的实现: 创造没必要的工作.</p></li>
<li><p>社会主意好: 转移支付. 涉及到公平</p></li>
<li><p><strong>未曾设想过的道路</strong>: 人人都是资本家. 大家都从资本投资中获取收入, 扩大所有制, 鼓励创建新企业, 禁止家庭资本聚集(<em>不太懂</em>).</p>
<ul>
<li><p>这样的方式会对人类已经形成的<strong>文化</strong>造成<strong>剧烈冲击</strong></p>
<blockquote>
<p>很有意思的想法, 值得思考</p>
</blockquote></li>
</ul></li>
</ul></li>
<li><p>人类的<strong>心理需求</strong>. 人类要在空闲时间做些什么, 什么样的工作能给人带来像工作一样的成就感和回报? 工作除了能给人们带来收入, 还能让人感受到满足, 获得认同感, 成长与学习的机会(当然这些也可以从其他的地方获得)</p></li>
</ul>
<h3 id="干嘛要讨论这个问题">1.3 干嘛要讨论这个问题</h3>
<p>有人认为机器取代人类还为时尚早, 我们不需要现在就讨论这个问题. 但是有以下一些理由让我们应该现在就思考</p>
<ul>
<li>技术的发展速度是越来越快的, 下一个时间节点可能比想象中的早</li>
<li>如果讨论清楚, 我们就不需要在发展技术上有所迟疑</li>
<li>社会的转变是缓慢的, 我们需要几代人的迭代来换成各个方面的变化</li>
<li>对于已经收到影响的行业, 现在开始讨论能够减轻压力(舆论?)</li>
</ul>
<h2 id="我的想法">2 我的想法</h2>
<p>Nilsson的这篇文章写于1984年, 可能在那个年代, 人工智能技术的发展确实加速发生的, 但站在2020年这个时间节点回望过去机器人与人工智能的发展, 似乎在理论基础研究上并没有特别大的进步, 更多的是其他行业(芯片/机械/驱动器/传感器等)的进步推动了这方面的发展, 人工智能本身的研究也更多的属于灌水. 设想的强人工智能(能让我们思考生命本质的强)似乎还是遥遥无期.</p>
<p>经过思考, 我觉得我之前的对于人类就业问题的担忧可能是不存在的. 机器人领域的发展速度还是相对缓慢的, 并没有那种会在一夜之间改变世界生产格局的技术出现. 所以在那种技术到来之前, 人类会逐渐适应机器人与人工智能在生产生活中的出现, 由于成本的原因, 人工成本会逐渐降低, 从事简单劳动的人口会逐渐减少. 社会上会(应该)出现新的培训行业, 引导人们从事更加创造性的工作. 这个渐进式的演变我认为会是比较平缓的, 当然这个平缓也是相对的. 相对于过去的生活方式, 这样的变换依然是非常显著的.</p>
<p>但是另外方面的担忧增加了, 那就是技术发展的不均衡的问题, 世界上不是只有发达国家, 很多发展中国家的技术水平与领先的技术水平之间的差距只会越来越大, 由于应用技术而导致的效率还会进一步拉大差距. 我感觉如今的世界经济一体化程度虽然高, 但是在政治上, 民族上, 隔阂却在越来越重. 我觉得要让领先者主动将技术分享给落后者显然是不可能的, 世界大同终究只是一个梦罢了.</p>
<p>Nilsson的文章还讨论到了机器人技术极大发展后的设想, 我觉得是一个非常有意思的话题, 涉及到了很多人类社会中的根本问题, 包括公平/人权/人类关系等, 之后可以单独写一篇文章讨论.</p>
]]></content>
      <categories>
        <category>Philosophy</category>
      </categories>
      <tags>
        <tag>society</tag>
      </tags>
  </entry>
  <entry>
    <title>Vision Based SLAM a review</title>
    <url>/2019/01/06/Robotics/Robotics-ORB-SLAM/</url>
    <content><![CDATA[<h2 id="introduction">1 Introduction</h2>
<p>SLAM builds a map and localize the sensor in the map with a strong focus on <strong>real-time operation</strong>.</p>
<p>Camera: cheap and provide rich information of the environment.</p>
<ul>
<li>Monocular camera, cheapest and smallest camera
<ul>
<li>depth is not observable</li>
<li>scale drift and mail fail if performing pure rotations</li>
</ul></li>
<li>RGB-D camera, all these issue can be solved.
<ul>
<li>Outdoor performance is not good. Usually used in indoor environment</li>
</ul></li>
</ul>
<a id="more"></a>
<h3 id="main-idea">1.1 Main Idea</h3>
<blockquote>
<p>At its heart, SLAM is an <strong>optimization problem</strong>, where the goal is to compute the best configuration of camera poses and point positions in order to <strong>minimize reprojection error</strong> (the difference between a point's tracked location and where it is expected to be given the camera pose estimate, over all points). —from <a href="https://www.kudan.io/post/an-introduction-to-simultaneous-localisation-and-mapping">Kudan</a></p>
</blockquote>
<p>The optimization method: Bundle adjustment, iteratively approaches the minimum error for the whole system.</p>
<ul>
<li>Problem: time consuming to find the best solution</li>
<li>But with the help of multi-core machine, this problem was solved</li>
</ul>
<p>Another essential technique: relocalization</p>
<h3 id="how-it-works">1.2 How it Works</h3>
<ol type="1">
<li>Read sensor data</li>
<li>Front end: VO</li>
<li>Back end: Optimization</li>
<li>Loop Closing: Correct the trajactory</li>
<li>Mapping</li>
</ol>
<h2 id="slam-type">2 SLAM type</h2>
<h3 id="slam-framework">2.0 SLAM Framework</h3>
<ul>
<li>Front end: Vision odometry, estimate camera’s motion based on 2 frame
<ul>
<li>Stereo</li>
<li>Double</li>
<li>RGB-D</li>
</ul></li>
<li>Back end: Optimization and calculate the map
<ul>
<li>Filter: KF EKF</li>
<li>Optimization : graph, g2o..</li>
</ul></li>
</ul>
<h3 id="stereo-slam">2.1 Stereo SLAM</h3>
<p>Most modern stereo SLAM systems are <strong>keyframe-based</strong> and perform <strong>BA optimization</strong></p>
<h3 id="rgb-d-slam">2.2 RGB-D SLAM</h3>
<p>KinectFusion is the earliest RGB-D SLAM system. This method track the camera pose using <strong>ICP</strong></p>
<p>Endres’ open-source system is a feature-based system.</p>
<ul>
<li>Front end: compute frame to frame motion by feature matching ICP</li>
<li>Back end: pose-graph optimization</li>
</ul>
<p>calculate pose by <em>solvepnp</em></p>
<ul>
<li>objectPoints - 世界坐标系下的控制点的坐标，vector<Point3f>的数据类型在这里可以使用</li>
<li>imagePoints - 在图像坐标系下对应的控制点的坐标。vector<Point2f>在这里可以使用</li>
</ul>
]]></content>
      <categories>
        <category>Robotics</category>
      </categories>
      <tags>
        <tag>ov</tag>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>SLAM-14讲 读书笔记 数学基础篇</title>
    <url>/2019/04/28/Robotics/Robotics-SLAM14-math/</url>
    <content><![CDATA[<h2 id="前言">1 前言</h2>
<p>全书分为两部分</p>
<ol type="1">
<li>数学基础，涉及到SLAM概述、矩阵知识、李群知识、非线性优化</li>
<li>SLAM技术，实践视觉里程计（特征点法、直接法），后端优化，回环检测</li>
</ol>
<a id="more"></a>
<h2 id="slam概述">2 SLAM概述</h2>
<h3 id="slam框架各模块及任务">2.1 SLAM框架各模块及任务</h3>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/salm-framework.png" /></p>
<ul>
<li>VO：视觉里程计，和计算机视觉研究领域相关。根据两张图片确定旋转了多少度、平移了多少厘米。通过VO计算两帧之间的移动，再累加。问题是会有<strong>累计漂移</strong>，需要后端优化和回环检测</li>
<li>后端优化：降噪，估计整个系统的状态。主要是滤波和非线性优化算法，<strong>优化轨迹</strong></li>
<li>回环检测：解决累计漂移问题，让机器人<strong>具有识别曾经到达过的场景的能力</strong></li>
<li>建图，现在常用的是<strong>度量地图</strong>，拓扑地图有待研究
<ul>
<li>稀疏：仅表达重要物体，即路标，<strong><em>对定位来说，稀疏地图就够了</em></strong></li>
<li>稠密：建模所有东西，用于导航ls</li>
</ul></li>
</ul>
<h3 id="编程环境">2.2 编程环境</h3>
<p>Ubuntu14.04</p>
<p>CMake</p>
<p>g++</p>
<h3 id="库">2.3 库</h3>
<p>C++工程中，只有带main函数的文件才会生成可执行程序，另外的代码供其他程序应用。叫做<strong>库</strong></p>
<ul>
<li>静态库：.a作为后缀名，每次被调用都会产生一个副本</li>
<li>共享库：.so作为后缀名，只有一个副本，更省空间</li>
</ul>
<p>一个库往往是许多算法、程序的集合。如果只有二进制库，不方便使用，所以提供头文件，方便调用。</p>
<p>如果可执行程序想要调用库中的函数，需要参考头文件，并把可执行程序链接到库文件上。</p>
<h3 id="cmake基本用法">2.4 cmake基本用法</h3>
<p>cmake处理了工程文件之间的关系，make调用g++编译程序</p>
<p>所以维护CMakeLists.txt降低了维护难度</p>
<h2 id="三维空间刚体运动">3 三维空间刚体运动</h2>
<h3 id="运动描述方式">3.1 运动描述方式</h3>
<p>旋转矩阵<span class="math inline">\(S O(n)\)</span>是特殊正交群的意思（Special Orthogonal Group），定义如下 <span class="math display">\[
S O(n)=\left\{\boldsymbol{R} \in \mathbb{R}^{n \times n} | \boldsymbol{R} \boldsymbol{R}^{T}=\boldsymbol{I}, \operatorname{det}(\boldsymbol{R})=1\right\}
\]</span></p>
<p><span class="math display">\[
\boldsymbol{R}^{-1}=\boldsymbol{R}^T
\]</span></p>
<p>可以用来<strong>描述相机的旋转</strong></p>
<hr />
<p>如果是<strong>旋转加上平移</strong>，那就要用<span class="math inline">\(SE(n)\)</span>来表示，意思是特殊欧式群（Special Euclidean Group），定义如下 <span class="math display">\[
S E(3)=\left\{T=\left[ \begin{array}{cc}{\boldsymbol{R}} &amp; {\boldsymbol{t}} \\ {\mathbf{0}^{T}} &amp; {1}\end{array}\right] \in \mathbb{R}^{4 \times 4} | \boldsymbol{R} \in S O(3), \boldsymbol{t} \in \mathbb{R}^{3}\right\}
\]</span></p>
<p><span class="math display">\[
\boldsymbol{T}^{-1}=\left[ \begin{array}{cc}{\boldsymbol{R}^{T}} &amp; {-\boldsymbol{R}^{T} \boldsymbol{t}} \\ {\mathbf{0}^{T}} &amp; {1}\end{array}\right]
\]</span></p>
<hr />
<p>上述的表示方法缺点是有冗余的变量表达，且旋转矩阵自身带有约束</p>
<p>改进：用2个三维向量表示</p>
<ul>
<li><p>一个是旋转向量，方向与旋转轴一致，长度与旋转角一直</p>
<p>旋转向量和旋转矩阵的转换由罗德里格斯公式表明</p></li>
<li><p>另一个是平移向量</p></li>
</ul>
<hr />
<p>旋转向量对人来说不好理解，所以可以用欧拉角来表示，但是欧拉角表示会存在万向节死锁问题。</p>
<hr />
<p>虽然旋转向量和欧拉角都是紧凑的，但是具有<strong>奇异性</strong></p>
<p>因此引入<strong>四元数</strong>，类似于表示三维空间旋转的复数</p>
<h3 id="eigen库使用">3.2 Eigen库使用</h3>
<h2 id="李群与李代数">4 李群与李代数</h2>
<p>知道了三维空间中刚体的运动方式，而我们需要解决<strong>什么样的相机位姿最符合当前观测数据</strong>这样的问题，可以抽象为一个优化问题，求解最优的<span class="math inline">\(R,t\)</span>，使得误差最小化</p>
<h3 id="基本概念">4.1 基本概念</h3>
<p>对于只有一个运算(比如<span class="math inline">\(*\)</span>)的集合，我们把它叫做<strong>群</strong>，也就是说群是定义在<strong>一种集合加上一种运算</strong>的基础上的，比如<span class="math inline">\(SO(n),SE(n)\)</span></p>
<p>李群是指具有连续（光滑）性质的群，<span class="math inline">\(SO(n),SE(n)\)</span></p>
<hr />
<p>李代数描述了李群的局部性质</p>
<p>李群通过<strong>对数映射</strong>得到李代数</p>
<p>李代数通过<strong>指数映射</strong>得到李群</p>
<h3 id="bch近似">4.2 BCH近似</h3>
<p>使用李代数的动机是为了优化</p>
<p>对李代数来说<span class="math inline">\(\ln (\exp (\boldsymbol{A}) \exp(\boldsymbol{B}))=\boldsymbol{A}+\boldsymbol{B}\)</span> 在矩阵时不成立</p>
<p>因此使用BCH（Baker-Campbell-Hausdorff）近似</p>
<h3 id="扰动模型">4.3 扰动模型</h3>
<h3 id="sophus对李代数的运算">4.4 Sophus对李代数的运算</h3>
<p>MSVC中没有M_PI，需要增加</p>
<h2 id="相机与图像">5 相机与图像</h2>
<h3 id="相机模型">5.1 相机模型</h3>
<h4 id="针孔相机模型">5.1.1 针孔相机模型</h4>
<p>内参数：针孔模型+畸变模型</p>
<p>这两个模型把外部三维点投影到相机内部成像平面</p>
<h4 id="双目相机模型">5.1.2 双目相机模型</h4>
<p>利用视差计算像素深度</p>
<h4 id="rgb-d相机模型">5.1.3 RGB-D相机模型</h4>
<p>主动测量每个像素的深度</p>
<ul>
<li>通过结构光，比如Kinect 1，realsense</li>
<li>通过飞行时间法ToF，比如Kinect 2，原理类似于激光</li>
</ul>
<h3 id="空间点如何投影到相机">5.2 空间点如何投影到相机</h3>
<h3 id="opencv中的图像存储与表示">5.3 OpenCV中的图像存储与表示</h3>
<p>宽度640，高度480的灰度图像，可以这样表示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="built_in">image</span>[<span class="number">480</span>][<span class="number">640</span>]</span><br></pre></td></tr></table></figure>
<p>因为第一个下标表示行，第二个下标表示列。</p>
<p>这样表示的原因是OpenCV中的图像也是矩阵，矩阵的数值选取是左上角原点，先纵再横。OpenCV规定纵是Y，横是X，所以最后是这样的表示</p>
<h3 id="摄像头标定">5.4 摄像头标定</h3>
<h2 id="非线性优化">6 非线性优化</h2>
<p>之前已经说明了运动方程和观测方程，但是由于噪声的存在，所以要根据有噪声的数据进行状态估计。也就是要求一个最大似然估计或者最大后验概率，“在什么情况下最可能产生现在观测到的数据”</p>
<p>原来的观测模型加上高斯分布的噪声后，任然是高斯分布，所以我们可以使用最小化负对数来求高斯分布最大似然，这也等价于最小化噪声项，所以问题就抽象为最小二乘问题</p>
<h3 id="非线性最小二乘法">6.1 非线性最小二乘法</h3>
<h3 id="下降策略">6.2 下降策略</h3>
<p>G-N 高斯牛顿法</p>
<p>L-M</p>
<h3 id="库的使用">6.3 库的使用</h3>
<h4 id="ceres">6.3.1 Ceres</h4>
<p>Ceres——通用的优化库，从损失函数来理解比较自然</p>
<p>最小二乘问题的一般形式 <span class="math display">\[
\min _{x} \frac{1}{2} \sum_{i} \rho_{i}\left(\left\|f_{i}\left(x_{i_{1}}, \ldots x_{i_{n}}\right)\right\|^{2}\right)
\]</span> 在Ceres中，定义优化变量<span class="math inline">\(x\)</span>和代价函数<span class="math inline">\(f_i\)</span>，调用Ceres求解</p>
<p>方法：</p>
<ol type="1">
<li>定义损失函数的模型，就是一个<strong>类</strong>，并在类中定义带模板参数的<code>()</code>运算符，使该类成为一个拟函数，使Ceres可以像调用函数一样调用这个类的对象</li>
<li>调用<span class="math inline">\(AddResidualBlock\)</span>添加误差项成为目标函数，梯度我们可以
<ul>
<li>Ceres的自动求导</li>
<li>数值求导</li>
<li>自行推导解析的导数形式，提供给Ceres</li>
</ul></li>
<li>自动求导需要指定误差项和优化变量的维度
<ul>
<li>误差是标量，维度就是1</li>
<li>有3个参数要优化，维度就是3</li>
</ul></li>
</ol>
<h4 id="g2o">6.3.2 G2O</h4>
<p><span class="math inline">\(g^2o\)</span>——基于图的优化库，需要定义新的顶点和边，但<span class="math inline">\(g^2o\)</span>提供了很多顶点和边的类型，所以在相机位姿估计问题中非常方便，如果用Ceres，要自己实现损失函数，不方便。</p>
]]></content>
      <categories>
        <category>Robotics</category>
      </categories>
      <tags>
        <tag>ov</tag>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>SLAM-14讲 读书笔记 实践篇</title>
    <url>/2019/04/29/Robotics/Robotics-SLAM14-practice/</url>
    <content><![CDATA[<h2 id="视觉里程计icp">1 视觉里程计：ICP</h2>
<blockquote>
<p>前端也称为视觉里程计（VO）。它根据相邻图像的信息，估计出粗略的相机运动，给后端提供较好的 初始值</p>
</blockquote>
<h3 id="图像特征点">1.1 图像特征点</h3>
<p><strong>有代表性的点</strong>被称为</p>
<ul>
<li>经典SLAM中：路标</li>
<li><strong>视觉SLAM中</strong>：图像特征（features</li>
</ul>
<a id="more"></a>
<p><strong>特征点</strong>由两部分组成：</p>
<ul>
<li><strong>关键点</strong>：特征点在图像里的位置、朝向、大小</li>
<li><strong>描述子</strong>：通常是一个向量，描述周围像素的信息</li>
</ul>
<p>常见图像特征点：</p>
<ul>
<li>SIFT（Scale-Invariant Feature Transform）：运算量大</li>
<li>FAST：计算快</li>
<li>ORB（Oriented FAST and Rotated BRIEF）：折中
<ul>
<li>关键点为 FAST：如果一个<strong>像素</strong>与它领域的像素差别较大，则更可能是<strong>角点</strong></li>
<li>描述子为 BRIEF：二进制描述子，关键点附近两个像素的大小关系</li>
</ul></li>
</ul>
<h3 id="对极几何2d-2d">1.2 对极几何:2D-2D</h3>
<p>有了若干对匹配点，就可以通过对应关系，恢复出两帧之间的运动</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/slam-2d-2d.png" /></p>
<p>设<span class="math inline">\(P\)</span>的空间位置为：<span class="math inline">\(\boldsymbol{P}=[X, Y, Z]^{T}\)</span></p>
<p><span class="math inline">\(p_1,p_2\)</span>的像素位置为<span class="math inline">\(s_{1} \boldsymbol{p}_{1}=\boldsymbol{K} \boldsymbol{P}, \quad s_{2} \boldsymbol{p}_{2}=\boldsymbol{K}(\boldsymbol{R} \boldsymbol{P}+\boldsymbol{t})\)</span> 其中<span class="math inline">\(K\)</span>是相机内参矩阵</p>
<p>经过数学运算得到<strong>对极约束</strong>：<span class="math inline">\(\boldsymbol{p}_{2}^{T} \boldsymbol{K}^{-T} \boldsymbol{t}^{\wedge} \boldsymbol{R} \boldsymbol{K}^{-1} \boldsymbol{p}_{1}=0\)</span></p>
<ul>
<li><p>几何意义是<span class="math inline">\(O_1,P,O_2\)</span>三者共面</p></li>
<li><p>中间部分记作两个矩阵</p>
<ul>
<li><p>本质矩阵<span class="math inline">\(\boldsymbol{E}=\boldsymbol{t}^{\wedge} \boldsymbol{R}\)</span></p></li>
<li><p>基础矩阵<span class="math inline">\(\boldsymbol{F}=\boldsymbol{K}^{-T} \boldsymbol{E} \boldsymbol{K}^{-1}\)</span></p></li>
<li><p>对极约束进一步化简为<span class="math inline">\(\boldsymbol{x}_{2}^{T} \boldsymbol{E} \boldsymbol{x}_{1}=\boldsymbol{p}_{2}^{T} \boldsymbol{F} \boldsymbol{p}_{1}=0\)</span></p></li>
</ul></li>
</ul>
<p>相机位姿估计问题抽象为</p>
<ol type="1">
<li>根据配对点和像素位置，求出<span class="math inline">\(E\)</span></li>
<li>根据<span class="math inline">\(E\)</span>，求出<span class="math inline">\(R,t\)</span></li>
</ol>
<h3 id="pnp问题3d-2d">1.3 PnP问题：3D-2D</h3>
<p>PnP（Perspective-n-Point），用在双目或RGB-D的视觉里程计使用</p>
<p>求解方法多样：</p>
<ul>
<li>直接线性变换</li>
<li>EPnP</li>
<li>非线性优化，构建最小二乘问题，Bundle Adjustment</li>
</ul>
<h3 id="icp问题3d-3d">1.4 ICP问题：3D-3D</h3>
<p>假设有一组配对好的3D点<span class="math inline">\(\boldsymbol{P}=\left\{\boldsymbol{p}_{1}, \ldots, \boldsymbol{p}_{n}\right\}, \quad \boldsymbol{P}^{\prime}=\left\{\boldsymbol{p}_{1}^{\prime}, \ldots, \boldsymbol{p}_{n}^{\prime}\right\}\)</span></p>
<p>要找的是欧式变换使得<span class="math inline">\(\forall i, \boldsymbol{p}_{i}=\boldsymbol{R} \boldsymbol{p}_{i}^{\prime}+\boldsymbol{t}\)</span></p>
<p>这个问题可以用迭代最近点（Iterative Closest Point, ICP）来解决，解决方法有</p>
<ul>
<li><p>线性代数求解 SVD</p>
<ol type="1">
<li>定义误差项 <span class="math inline">\(e_{i}=\boldsymbol{p}_{i}-\left(\boldsymbol{R} \boldsymbol{p}_{i}^{\prime}+\boldsymbol{t}\right)\)</span></li>
<li>构建最小二乘问题<span class="math inline">\(\min _{\boldsymbol{R}, t} J=\frac{1}{2} \sum_{i=1}^{n}\left\|\left(\boldsymbol{p}_{i}-\left(\boldsymbol{R} \boldsymbol{p}_{i}^{\prime}+\boldsymbol{t}\right)\right)\right\|_{2}^{2}\)</span></li>
<li>可以化简为<span class="math inline">\(\min _{\boldsymbol{R}, \boldsymbol{t}} J=\frac{1}{2} \sum_{i=1}\left\|\boldsymbol{p}_{i}-\boldsymbol{p}-\boldsymbol{R}\left(\boldsymbol{p}_{i}^{\prime}-\boldsymbol{p}^{\prime}\right)\right\|^{2}+\left\|\boldsymbol{p}-\boldsymbol{R} \boldsymbol{p}^{\prime}-\boldsymbol{t}\right\|^{2}\)</span></li>
<li>发现左边项只和<span class="math inline">\(R\)</span>有关，因此先求出<span class="math inline">\(R\)</span>，令右边为<span class="math inline">\(0\)</span>即可求出<span class="math inline">\(t\)</span></li>
<li>利用代码实现就是
<ol type="1">
<li>求出两组点质心位置，求出去质心坐标</li>
<li>根据左边项求<span class="math inline">\(\boldsymbol{R}^{*}=\arg \min _{\boldsymbol{R}} \frac{1}{2} \sum_{i=1}^{n}\left\|\boldsymbol{q}_{i}-\boldsymbol{R} \boldsymbol{q}_{i}^{\prime}\right\|^{2}\)</span></li>
<li>求出<span class="math inline">\(t\)</span></li>
</ol></li>
</ol></li>
<li><p>非线性优化 BA</p>
<p>迭代求解</p></li>
</ul>
<h3 id="三角化获得三维结构">1.5 三角化获得三维结构</h3>
<h2 id="视觉里程计直接法">2 视觉里程计：直接法</h2>
<p>使用特征点的方法有一些缺点：</p>
<ol type="1">
<li>就算是ORB算法也很耗时</li>
<li>图像上很多信息没有利用到</li>
<li>相机有时候会运动到特征确实的地方（面对着墙）</li>
</ol>
<p>直接法就不匹配<em>描述子</em>，直接比较像素或特征点，有几种思路</p>
<ul>
<li><strong>光流法</strong>，使用特征点，只计算关键点，不计算描述子</li>
<li>直接法，只计算关键点，根据像素灰度信息来计算</li>
</ul>
<p>总的来说，通过最小化<strong>光度误差</strong>来求解</p>
<h3 id="lucas-kanade-光流法">2.1 Lucas-Kanade 光流法</h3>
<p>灰度是位置和时间的函数 <span class="math display">\[
\boldsymbol{I}(x, y, t)
\]</span> 光流法的基本假设：</p>
<ul>
<li><p>灰度不变假设，同一空间点的像素灰度值，在各个图像中不变 <span class="math display">\[
\boldsymbol{I}(x+\mathrm{d} x, y+\mathrm{d} y, t+\mathrm{d} t)=\boldsymbol{I}(x, y, t)=\boldsymbol{I}(x, y, t)+\frac{\partial \boldsymbol{I}}{\partial x} \mathrm{d} x+\frac{\partial \boldsymbol{I}}{\partial y} \mathrm{d} y+\frac{\partial \boldsymbol{I}}{\partial t} \mathrm{d} t
\]</span> 所以 <span class="math display">\[
\frac{\partial \boldsymbol{I}}{\partial x} \mathrm{d} x+\frac{\partial \boldsymbol{I}}{\partial y} \mathrm{d} y+\frac{\partial \boldsymbol{I}}{\partial t} \mathrm{d} t=0
\]</span> 一个方程两个未知数，所以还需要一个假设</p></li>
<li><p>某一个窗口内的像素具有相同的运动</p>
<p>如果选取一个<span class="math inline">\(w\times w\)</span>的窗口，就有<span class="math inline">\(w^2\)</span>个像素，也就有<span class="math inline">\(w^2\)</span>个方程，还是两个未知数，就可以利用最小二乘来求解出速度<span class="math inline">\(u,v\)</span></p></li>
</ul>
<h2 id="设计前端">3 设计前端</h2>
<h3 id="确定程序框架">3.1 确定程序框架</h3>
<p>选用RGB-D摄像头实现，因为较为简单，没有初始化，没有尺度问题。</p>
<p>建立不同的文件夹，分类存放文件</p>
<ul>
<li>bin 存放可执行的二进制</li>
<li>include/slam 主要是.h头文件</li>
<li>src 主要是.cpp源文件</li>
<li>test 主要是.cpp测试源文件</li>
<li>lib 编译好的库文件</li>
<li>config 存放配置文件</li>
<li>cmake_modules 第三方的cmake库</li>
</ul>
<h3 id="基本类及其关系">3.2 基本类及其关系</h3>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/slam-basic-class.png" /></p>
<h3 id="基本逻辑">3.3 基本逻辑</h3>
<p>3种状态</p>
<ul>
<li>初始化：计算ORB，设定初始位姿</li>
<li>正常：计算ORB，特征匹配，位姿估计PnP，设定新位姿
<ol type="1">
<li>特征匹配时使用hamming距离，找出所有匹配之间最大和最小</li>
<li>位姿估计时把匹配点转换为向量</li>
</ol></li>
<li>丢失：跳过</li>
</ul>
<h2 id="后端优化">4 后端优化</h2>
<p>状态估计</p>
<ul>
<li>Batch：批量的，状态估计会用未来的信息更新自己</li>
<li>Incremental：渐进的，当前状态只有过去的时刻决定</li>
</ul>
<p>希望：轨迹在较长时间内能保持最优</p>
<p>问题：只有里程计，会对自己的运动估计越来越不确定</p>
<p>sfm问题：从一组图像中恢复运动和结构 <span class="math display">\[
P\left(\boldsymbol{x}_{k} | \boldsymbol{x}_{0}, \boldsymbol{u}_{1 : k}, \boldsymbol{z}_{1 : k-1}\right)=\int P\left(\boldsymbol{x}_{k} | \boldsymbol{x}_{k-1}, \boldsymbol{x}_{0}, \boldsymbol{u}_{1 : k}, \boldsymbol{z}_{1 : k-1}\right) P\left(\boldsymbol{x}_{k-1} | \boldsymbol{x}_{0}, \boldsymbol{u}_{1 : k}, \boldsymbol{z}_{1 : k-1}\right) \mathrm{d} \boldsymbol{x}_{k-1}
\]</span></p>
<h3 id="线性系统和kf">4.1 线性系统和KF</h3>
<p>假设马尔可夫性，右侧第一部分中当前状态之和上一个时刻有关 <span class="math display">\[
P\left(\boldsymbol{x}_{k} | \boldsymbol{x}_{k-1}, \boldsymbol{x}_{0}, \boldsymbol{u}_{1 : k}, \boldsymbol{z}_{1 : k-1}\right)=P\left(\boldsymbol{x}_{k} | \boldsymbol{x}_{k-1}, \boldsymbol{u}_{k}\right)
\]</span> 右侧第二部分 <span class="math display">\[
P\left(\boldsymbol{x}_{k-1} | \boldsymbol{x}_{0}, \boldsymbol{u}_{1 : k}, \boldsymbol{z}_{1 : k-1}\right)=P\left(\boldsymbol{x}_{k-1} | \boldsymbol{x}_{0}, \boldsymbol{u}_{1 : k-1}, \boldsymbol{z}_{1 : k-1}\right)
\]</span></p>
<hr />
<p>高斯线性系统 <span class="math display">\[
\left\{\begin{array}{ll}{\boldsymbol{x}_{k}=\boldsymbol{A}_{k} \boldsymbol{x}_{k-1}+\boldsymbol{u}_{k}+\boldsymbol{w}_{k}} \\ {z_{k}=\boldsymbol{C}_{k} \boldsymbol{x}_{k}+\boldsymbol{v}_{k}}\end{array} \quad k=1, \ldots, N\right.
\]</span> 其中状态和噪声都满足高斯分布（零均值）</p>
<p>所以整个问题归纳为</p>
<p>已知：</p>
<ul>
<li><span class="math inline">\(k-1\)</span>时刻的后验状态估计：<span class="math inline">\(\hat{\boldsymbol{x}}_{k-1},\hat{\boldsymbol{P}}_{k-1}\)</span></li>
<li><span class="math inline">\(k\)</span>时刻的输入和观测</li>
</ul>
<p>求取:</p>
<ul>
<li><span class="math inline">\(x_k\)</span>的后验分布</li>
</ul>
<hr />
<p>后验均值的表达，就是两个步骤，预测和更新</p>
<ol type="1">
<li><p>预测</p></li>
<li><p>更新，计算<span class="math inline">\(K\)</span>，成为卡尔曼增益 <span class="math display">\[
\boldsymbol{K}=\overline{\boldsymbol{P}}_{k} \boldsymbol{C}_{k}^{T}\left(\boldsymbol{C}_{k} \overline{\boldsymbol{P}}_{k} \boldsymbol{C}_{k}^{T}+\boldsymbol{Q}\right)^{-1}
\]</span></p></li>
</ol>
<p>卡尔曼滤波器构成了线性系统的最优无偏估计</p>
<h3 id="非线性系统和ekf">4.2 非线性系统和EKF</h3>
<p>运动方程和观测方程一般是非线性函数，所以我们需要近似，近似成高斯分布</p>
<p>方式：线性化，就相当于一阶泰勒展开（求偏导）</p>
<p>仿照卡尔曼滤波，定义新的卡尔曼增益<span class="math inline">\(K\)</span> <span class="math display">\[
\boldsymbol{K}_{k}=\overline{\boldsymbol{P}}_{k} \boldsymbol{H}^{\mathrm{T}}\left(\boldsymbol{H} \overline{\boldsymbol{P}}_{k} \boldsymbol{H}^{\mathrm{T}}+\boldsymbol{Q}_{k}\right)^{-1}
\]</span> 利用卡尔曼增益，计算后验概率</p>
<p>局限</p>
<ul>
<li>假设了<strong>马尔可夫性</strong>，所以无法做回环检测</li>
<li>仅做了<strong>一次线性化</strong>，而一阶泰勒展开不一定能够近似整个函数，只能在很小的范围内成立</li>
<li><span class="math inline">\(EKF\)</span>存储了状态量的均值和方差</li>
</ul>
<h3 id="非线性优化">4.3 非线性优化</h3>
<p><strong>Bundle Adjustment</strong>：从视觉重建中提炼出最优的3D模型和相机参数（内参，外参）</p>
<p>在以<strong>图优化框架</strong>的<strong>视觉</strong>SLAM问题中，BA起到了核心作用。求解<strong>只有观测方程</strong>的SLAM问题</p>
<p>SLAM问题中，BA具有稀疏特性，可以在实时场景中使用</p>
<hr />
<h4 id="投影模型">投影模型</h4>
<p>从世界坐标系到像素坐标</p>
<ol type="1">
<li><p>世界坐标<span class="math inline">\(\to\)</span>相机坐标，利用<strong>外参</strong></p>
<p><span class="math inline">\(\boldsymbol{P}^{\prime}=\boldsymbol{R} \boldsymbol{p}+\boldsymbol{t}=\left[X^{\prime}, Y^{\prime}, Z^{\prime}\right]^{T}\)</span></p></li>
<li><p>相机坐标<span class="math inline">\(\to\)</span> 归一化坐标</p>
<p><span class="math inline">\(\boldsymbol{P}_{c}=\left[u_{c}, v_{c}, 1\right]^{T}=\left[X^{\prime} / Z^{\prime}, Y^{\prime} / Z^{\prime}, 1\right]^{T}\)</span></p></li>
<li><p>归一化坐标<span class="math inline">\(\to\)</span>去畸变</p>
<p><span class="math inline">\(\left\{\begin{array}{l}{u_{c}^{\prime}=u_{c}\left(1+k_{1} r_{c}^{2}+k_{2} r_{c}^{4}\right)} \\ {v_{c}^{\prime}=v_{c}\left(1+k_{1} r_{c}^{2}+k_{2} r_{c}^{4}\right)}\end{array}\right.\)</span></p></li>
<li><p>去畸变<span class="math inline">\(\to\)</span>像素坐标，利用<strong>内参</strong></p>
<p><span class="math inline">\(\left\{\begin{array}{l}{u_{s}=f_{x} u_{c}^{\prime}+c_{x}} \\ {v_{s}=f_{y} v_{c}^{\prime}+c_{y}}\end{array}\right.\)</span></p></li>
</ol>
<hr />
<p>上面的投影模型可以说就是<strong>观测方程</strong></p>
<p>可以抽象为<span class="math inline">\(z=h(\boldsymbol{x}, \boldsymbol{y})\)</span></p>
<ul>
<li><span class="math inline">\(z\)</span> 是观测数据，像素坐标</li>
<li><span class="math inline">\(x\)</span> 是相机位姿，外参<span class="math inline">\(R,t\)</span></li>
<li><span class="math inline">\(y\)</span> 是路标，三维点<span class="math inline">\(p\)</span></li>
</ul>
<p>考虑所有时刻的观测量，可以计算整体的代价函数 <span class="math display">\[
\frac{1}{2} \sum_{i=1}^{m} \sum_{j=1}^{n}\left\|\boldsymbol{e}_{i j}\right\|^{2}=\frac{1}{2} \sum_{i=1}^{m} \sum_{j=1}^{n}\left\|\boldsymbol{z}_{i j}-h\left(\boldsymbol{\xi}_{i}, \boldsymbol{p}_{j}\right)\right\|^{2}
\]</span></p>
<hr />
<h3 id="ceres实践">4.4 Ceres实践</h3>
<p>根本问题：<strong>最小化投影误差</strong>，也就是多个特征点的平均投影误差 <span class="math display">\[
\begin{aligned} r(\boldsymbol{\xi}) &amp;=\mathbf{p}^{\prime}-\mathbf{p}=\left(u^{\prime}, v^{\prime}\right)-(u, v) \end{aligned}
\]</span></p>
<p>回顾Ceres，要做优化问题</p>
<ul>
<li>构建<strong>代价函数</strong>
<ul>
<li>使用自动求导，需要构造<strong>代价函数结构体</strong>，对模板括号<code>()</code>重载，定义残差，<code>()</code>中前几个是待优化变量，最后一个是残差</li>
<li>模板参数<code>&lt;&gt;</code>中第一个参数代价函数结构体的名字，然后是残差的维度，后几个为待优化状态量的维度</li>
</ul></li>
<li>用<strong>代价函数</strong>，<strong>待优化变量</strong>构建<strong>优化问题</strong></li>
<li><em>配置</em><strong>求解器</strong></li>
<li>运行求解器</li>
</ul>
<h2 id="图优化">5 图优化</h2>
<h3 id="位姿图-pose-graph">5.1 位姿图 Pose Graph</h3>
<p>采用之前的BA优化，时间越长，运动轨迹越长，地图规模也会增长，所以计算效率就会逐渐下降。如何解决这些问题？</p>
<p>考虑到在BA优化中，一些特征点会收敛至一个值保持不动，所以不需要再进行优化。</p>
<blockquote>
<p>可以构建一个只有轨迹的图优化，而位姿节点之间的边，可以由两个关键帧之间通过特征 匹配之后得到的运动估计来给定初始值。不同的是，一旦初始估计完成，我们就不再优化 那些路标点的位置，而只关心所有的相机位姿之间的联系了。通过这种方式，我们省去了大 量的特征点优化的计算，只保留了关键帧的轨迹，从而构建了所谓的位姿图（Pose Graph）</p>
</blockquote>
<h2 id="回环检测">6 回环检测</h2>
<h3 id="概述">概述</h3>
<p>前端：特征点提取，提供轨迹和地图的<strong>初值</strong></p>
<p>后端：对前端提供的数据进行<strong>优化</strong></p>
<p>但是只考虑相邻帧之间的位移，长期来看还是会有累计误差，所以要加入<strong>回环检测</strong></p>
<p>所以仅有前端和局部后端的系统称为VO，而有回环检测和全局后端的称为SLAM</p>
<h3 id="实现">实现</h3>
<p>最简单的方式：任意两张做特征匹配，匹配多的关系就越强，但是计算量太大</p>
<p>几何的方式：在几何关系上回到起点时做检测，但是逻辑上也是鸡和蛋的问题</p>
<p>实际中应用的方式：基于外观，计算图像间的相似性</p>
<p>有两个统计量来检验<strong>判断效果</strong></p>
<ul>
<li><strong>准确率</strong>，就是所有检测到的回环中是真实回环的概率，在SLAM中更加重要一些</li>
<li>召回率，就是所有真实回环中被检测到的概率</li>
</ul>
<h3 id="词袋模型">词袋模型</h3>
<p>Bag of Words (BoW)，用图像特征来描述图像，比如说一张图片里两个人，另一张一个人</p>
<ol type="1">
<li>确定”人“的概念，相当于Words，许多<strong>Words</strong>组合在一起组成字典<strong>Dictionary</strong></li>
<li>计算一张图中的各个Words，只计算出现的次数，和空间位置等无关</li>
<li>比较相似程度</li>
</ol>
<hr />
<p>字典的定义——通过聚类解决</p>
<p>问题抽象：从一张图片中提取了<span class="math inline">\(N\)</span>个特征点，想要找一个有<span class="math inline">\(k\)</span></p>
]]></content>
      <categories>
        <category>Robotics</category>
      </categories>
      <tags>
        <tag>ov</tag>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>Robotics, What should I choose</title>
    <url>/2020/02/21/Robotics/Robotics-major/</url>
    <content><![CDATA[<h2 id="about-robotics">1 About Robotics</h2>
<p>There are 3 main aspects of robotics</p>
<ul>
<li><p>body</p>
<p>design structure, forces, velocities</p></li>
<li><p>electrical</p>
<p>power, electricity, sensors, sound, PID controller</p></li>
<li><p>programming</p>
<p>decision, brain, when and how to do something</p>
<ul>
<li><p>computer vision: understand visual information</p></li>
<li><p>motion planning: starting to ending point</p>
<p>algorithm: Dij, A*, DWA….</p></li>
<li><p>machine learning: interact with environment on it’s own</p></li>
</ul></li>
</ul>
<h2 id="research">2 Research</h2>
<p>stability of aerial vehicles</p>
<p>quadruped robots: MIT</p>
<p>climbing robot: Stanford</p>
<p>sense and avoid: UAV</p>
<p>prosthetic hand:</p>
<h2 id="company">3 Company</h2>
<p>Epson robots</p>
<p>liquid robotics</p>
<p>intuitive surgical</p>
<p>ekso bionics</p>
<p>stone aerospace</p>
]]></content>
      <categories>
        <category>Robotics</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>PADS-Analysis</title>
    <url>/2018/12/24/CS/DS%20&amp;%20Algorithm/ADS-Analysis/</url>
    <content><![CDATA[<h2 id="big-picture">1. Big Picture</h2>
<ul>
<li>What makes a program better？many valid criteria, which are often in conflict.</li>
<li>omputer scientists <em>love</em>
<ul>
<li>Time</li>
<li>Memory</li>
<li>trade off</li>
</ul></li>
<li>sum of 1-n：
<ul>
<li>simple add</li>
<li>gauss formula <a id="more"></a></li>
</ul></li>
</ul>
<h2 id="big-o-notation">2. Big O Notation</h2>
<table>
<thead>
<tr class="header">
<th>f(n)</th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>Constant</td>
</tr>
<tr class="even">
<td><span class="math inline">\(log n\)</span></td>
<td>Logarithmic</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(n\)</span></td>
<td>Linear</td>
</tr>
<tr class="even">
<td><span class="math inline">\(nlogn\)</span></td>
<td>Log Linear</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(n^2\)</span></td>
<td>Quadratic</td>
</tr>
<tr class="even">
<td><span class="math inline">\(n^3\)</span></td>
<td>Cubic</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(2^n\)</span></td>
<td>Exponential</td>
</tr>
</tbody>
</table>
<h2 id="example-anagram-detection">3. Example :Anagram Detection</h2>
<ol type="1">
<li>Checking off: check one by one ,<span class="math inline">\(O(n^2)\)</span>.</li>
<li>Sort and Compare: <span class="math inline">\(O(nlogn)\)</span></li>
<li>Brute Force , try all possibilities: <span class="math inline">\(O(n!)\)</span></li>
<li>Count and Compare: <span class="math inline">\(O(n)\)</span></li>
</ol>
<h2 id="performance-of-python-types">4. Performance of Python Types</h2>
<ul>
<li>Lists
<ul>
<li>Indexing &amp; Assigning &amp; Appending <span class="math inline">\(O(1)\)</span></li>
<li>Poping, Shifting &amp; Deleting, normally <span class="math inline">\(O(n)\)</span> ,beacuse has to shift changed element</li>
<li>Reversing <span class="math inline">\(O(n)\)</span></li>
</ul></li>
<li>Dictionaries
<ul>
<li>“getting” and “setting” : <span class="math inline">\(O(1)\)</span></li>
<li>Iterating &amp; Copying: <span class="math inline">\(O(n)\)</span></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>DS &amp; Algorithm</category>
      </categories>
      <tags>
        <tag>DS</tag>
      </tags>
  </entry>
  <entry>
    <title>PADS-Deques</title>
    <url>/2019/03/02/CS/DS%20&amp;%20Algorithm/ADS-Deques/</url>
    <content><![CDATA[<h2 id="introduction">1 Introduction</h2>
<h3 id="deques">1.1 Deques</h3>
<blockquote>
<p>A <strong>deque</strong>, also known as a <strong>double-ended queue</strong>, is an ordered collection of items similar to the queue. It has two ends, a front and a rear, and the items remain positioned in the collection. In a sense, this hybrid linear structure provides all the capabilities of stacks and queues in a single data structure.</p>
</blockquote>
<p>Simply speaking, deques is <strong>stacks + queues</strong></p>
<a id="more"></a>
<h3 id="adt">1.2 ADT</h3>
<table>
<thead>
<tr class="header">
<th>Deque Operation</th>
<th>Deque Contents</th>
<th>Return Value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>d.is_empty()</code></td>
<td><code>[]</code></td>
<td><code>True</code></td>
</tr>
<tr class="even">
<td><code>d.add_rear(4)</code></td>
<td><code>[4]</code></td>
<td></td>
</tr>
<tr class="odd">
<td><code>d.add_rear('dog')</code></td>
<td><code>['dog', 4]</code></td>
<td></td>
</tr>
<tr class="even">
<td><code>d.add_front('cat')</code></td>
<td><code>['dog', 4, 'cat']</code></td>
<td></td>
</tr>
<tr class="odd">
<td><code>d.add_front(True)</code></td>
<td><code>['dog', 4,'cat', True]</code></td>
<td></td>
</tr>
<tr class="even">
<td><code>d.size()</code></td>
<td><code>['dog', 4, 'cat', True]</code></td>
<td><code>4</code></td>
</tr>
<tr class="odd">
<td><code>d.is_empty()</code></td>
<td><code>['dog', 4, 'cat', True]</code></td>
<td><code>False</code></td>
</tr>
<tr class="even">
<td><code>d.add_rear(8.4)</code></td>
<td><code>[8.4, 'dog', 4, 'cat',True]</code></td>
<td></td>
</tr>
<tr class="odd">
<td><code>d.remove_rear()</code></td>
<td><code>['dog', 4, 'cat', True]</code></td>
<td><code>8.4</code></td>
</tr>
<tr class="even">
<td><code>d.remove_front()</code></td>
<td><code>['dog', 4, 'cat']</code></td>
<td><code>True</code></td>
</tr>
</tbody>
</table>
<h2 id="implementation">2 Implementation</h2>
<p>In practice, we just <em>import deque from collections</em> module</p>
<p>Adding and removing from the <strong>rear</strong> is <span class="math inline">\(O(1)\)</span></p>
<p>Adding and removing from the <strong>front</strong> is <span class="math inline">\(O(n)​\)</span></p>
<h2 id="example-palindrome-checker">3 Example: Palindrome Checker</h2>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/deques.png" alt="deques" /><figcaption aria-hidden="true">deques</figcaption>
</figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_palindrome</span>(<span class="params">characters</span>):</span></span><br><span class="line">    character_deque = deque(characters)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> len(character_deque) &gt; <span class="number">1</span>:</span><br><span class="line">        first = character_deque.popleft()</span><br><span class="line">        last = character_deque.pop()</span><br><span class="line">        <span class="keyword">if</span> first != last:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">is_palindrome(<span class="string">&#x27;lsdkjfskf&#x27;</span>)   <span class="comment"># =&gt; False</span></span><br><span class="line">is_palindrome(<span class="string">&#x27;radar&#x27;</span>)   <span class="comment"># =&gt; True</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CS</category>
        <category>DS &amp; Algorithm</category>
      </categories>
      <tags>
        <tag>DS</tag>
      </tags>
  </entry>
  <entry>
    <title>PADS-Lists</title>
    <url>/2019/03/02/CS/DS%20&amp;%20Algorithm/ADS-Lists/</url>
    <content><![CDATA[<h2 id="introduciton">1 Introduciton</h2>
]]></content>
      <categories>
        <category>CS</category>
        <category>DS &amp; Algorithm</category>
      </categories>
      <tags>
        <tag>DS</tag>
      </tags>
  </entry>
  <entry>
    <title>PADS-Queues</title>
    <url>/2019/01/03/CS/DS%20&amp;%20Algorithm/ADS-Queues/</url>
    <content><![CDATA[<h2 id="introduction">1 Introduction</h2>
<h3 id="queues">1.1 Queues</h3>
<blockquote>
<p>A queue is an ordered collection of items where the addition of new items happens at one end, called the “rear,” and the removal of existing items occurs at the other end, commonly called the “front.”</p>
</blockquote>
<ul>
<li><p>Example: wait in a line for a movie/ OS use queues control processes</p></li>
<li><p>Usage: keep in order</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/queues.png" alt="queues" /><figcaption aria-hidden="true">queues</figcaption>
</figure>
<a id="more"></a></li>
</ul>
<h3 id="adt">1.2 ADT</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Queue Operation</th>
<th style="text-align: center;">Queue Contents</th>
<th style="text-align: center;">Return Value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">q.is_empty()</td>
<td style="text-align: center;">[]</td>
<td style="text-align: center;">True</td>
</tr>
<tr class="even">
<td style="text-align: center;">q.enqueue(4)</td>
<td style="text-align: center;">[4]</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">q.enqueue('dog')</td>
<td style="text-align: center;">['dog', 4]</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">q.enqueue(True)</td>
<td style="text-align: center;">[True, 'dog', 4]</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">q.size()</td>
<td style="text-align: center;">[True, 'dog', 4]</td>
<td style="text-align: center;">3</td>
</tr>
<tr class="even">
<td style="text-align: center;">q.is_empty()</td>
<td style="text-align: center;">[True, 'dog', 4]</td>
<td style="text-align: center;">False</td>
</tr>
<tr class="odd">
<td style="text-align: center;">q.enqueue(8.4)</td>
<td style="text-align: center;">[8.4, True, 'dog', 4]</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">q.dequeue()</td>
<td style="text-align: center;">[8.4, True, 'dog']</td>
<td style="text-align: center;">4</td>
</tr>
<tr class="odd">
<td style="text-align: center;">q.dequeue()</td>
<td style="text-align: center;">[8.4, True]</td>
<td style="text-align: center;">'dog'</td>
</tr>
<tr class="even">
<td style="text-align: center;">q.size()</td>
<td style="text-align: center;">[8.4, True]</td>
<td style="text-align: center;">2</td>
</tr>
</tbody>
</table>
<h2 id="a-queue-implementation">2 A Queue Implementation</h2>
<p>In practice, use the standard library's <code>collections.deque</code> to achieve high performance( <span class="math inline">\(O(1)\)</span>) enqueues and dequeues.</p>
<h2 id="example-simulating-hot-potato">3 Example: Simulating Hot Potato</h2>
<p>As mentioned in the first section, <strong>queues</strong> can be used in FIFO manner.</p>
<p><strong>Hot Potato game</strong>: people line up in a <strong>circle</strong> and pass item to neighbor, at a certain point, the action stopped and the man who has the item is removed from the circle. Finally there will be only 1 person left.</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/hot-potato.png" alt="hot-patato" /><figcaption aria-hidden="true">hot-patato</figcaption>
</figure>
<p>The person who is in front of the queue may be randomly removed.</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>DS &amp; Algorithm</category>
      </categories>
      <tags>
        <tag>DS</tag>
      </tags>
  </entry>
  <entry>
    <title>PADS-Stacks</title>
    <url>/2018/12/24/CS/DS%20&amp;%20Algorithm/ADS-Stacks/</url>
    <content><![CDATA[<h2 id="introduction-to-stacks">1. Introduction to Stacks</h2>
<p>Stacks is a kind of linear data structures.</p>
<p>What distinguishes one linear structure from another is where additions and removals may occur</p>
<h3 id="stacks">1.1 Stacks</h3>
<blockquote>
<p>A <em>stack</em> is an ordered collection of items where the addition of new items and the removal of existing items always takes place at the same end.</p>
</blockquote>
<ul>
<li><p>Example: stack of books, URL back button</p></li>
<li><p>Usage: <strong>reverse the order</strong></p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/stacks.png" alt="stacks" /><figcaption aria-hidden="true">stacks</figcaption>
</figure>
<a id="more"></a></li>
</ul>
<h3 id="adt">1.2 ADT</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">ADT</th>
<th style="text-align: center;">data represents</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">DS</td>
<td style="text-align: center;"><strong>physical</strong> implementation of an ADT</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Stack operation</th>
<th style="text-align: center;">Stack contents</th>
<th style="text-align: center;">Return value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">s.is_empty()</td>
<td style="text-align: center;">[]</td>
<td style="text-align: center;">True</td>
</tr>
<tr class="even">
<td style="text-align: center;">s.push(4)</td>
<td style="text-align: center;">[4]</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">s.push('dog')</td>
<td style="text-align: center;">[4, 'dog']</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">s.peek()</td>
<td style="text-align: center;">[4, 'dog']</td>
<td style="text-align: center;">'dog'</td>
</tr>
<tr class="odd">
<td style="text-align: center;">s.push(True)</td>
<td style="text-align: center;">[4, 'dog', True]</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">s.size()</td>
<td style="text-align: center;">[4, 'dog', True]</td>
<td style="text-align: center;">3</td>
</tr>
<tr class="odd">
<td style="text-align: center;">s.is_empty()</td>
<td style="text-align: center;">[4, 'dog', True]</td>
<td style="text-align: center;">False</td>
</tr>
<tr class="even">
<td style="text-align: center;">s.push(8.4)</td>
<td style="text-align: center;">[4, 'dog', True, 8.4]</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">s.pop()</td>
<td style="text-align: center;">[4, 'dog', True]</td>
<td style="text-align: center;">8.4</td>
</tr>
<tr class="even">
<td style="text-align: center;">s.pop()</td>
<td style="text-align: center;">[4, 'dog']</td>
<td style="text-align: center;">True</td>
</tr>
<tr class="odd">
<td style="text-align: center;">s.size()</td>
<td style="text-align: center;">[4, 'dog']</td>
<td style="text-align: center;">2</td>
</tr>
</tbody>
</table>
<h2 id="a-stack-implementation">2. A Stack Implementation</h2>
<p>In practice , “use a Python <strong>list</strong> as a stack”</p>
<p>even though the implementations are logically equivalent, they would have very different timings when performing benchmark testing.</p>
<p>Here, just use <strong>python list</strong> with limit function.</p>
<h2 id="examplebalanced-parentheses">3. Example:Balanced Parentheses</h2>
<p>parentheses are used to order the performance of operations</p>
<p><span class="math display">\[
(5+6)×(7+8)/(4+3)
\]</span></p>
<p>or lisp function</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">defun</span> square(<span class="name">n</span>)</span><br><span class="line">     (<span class="name">*</span> n n))</span><br></pre></td></tr></table></figure>
<p>So,it's important to differentiate between parentheses that are correctly balanced and those that are unbalanced in <strong>strucures</strong>.</p>
<ul>
<li>Why Stack ? open match close close match open, <strong>reverse order</strong></li>
<li><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/parenthese.png" title="fig:" alt="parentheses" /></li>
<li>So a stack, push if open, pop if close. Finally, if len(stack)==0, balance.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">PAIRINGS = &#123;</span><br><span class="line">    <span class="string">&#x27;(&#x27;</span>: <span class="string">&#x27;)&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;&#123;&#x27;</span>: <span class="string">&#x27;&#125;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;[&#x27;</span>: <span class="string">&#x27;]&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_balanced</span>(<span class="params">symbols</span>):</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> symbols:</span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">in</span> PAIRINGS.keys():</span><br><span class="line">            stack.append(s)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            expected_opening_symbol = stack.pop()</span><br><span class="line">        <span class="keyword">except</span> IndexError:  <span class="comment"># too many closing symbols</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> s != PAIRINGS[expected_opening_symbol]:  <span class="comment"># mismatch</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> len(stack) == <span class="number">0</span>  <span class="comment"># false if too many opening symbols</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">is_balanced(<span class="string">&#x27;&#123;&#123;([][])&#125;()&#125;&#x27;</span>)  <span class="comment"># =&gt; True</span></span><br><span class="line">is_balanced(<span class="string">&#x27;&#123;[])&#x27;</span>)  <span class="comment"># =&gt; False</span></span><br><span class="line">is_balanced(<span class="string">&#x27;((()))&#x27;</span>)  <span class="comment"># =&gt; True</span></span><br><span class="line">is_balanced(<span class="string">&#x27;(()&#x27;</span>)  <span class="comment"># =&gt; False</span></span><br><span class="line">is_balanced(<span class="string">&#x27;())&#x27;</span>)  <span class="comment"># =&gt; False</span></span><br></pre></td></tr></table></figure>
<h2 id="example-converting-number-bases">4. Example: Converting Number Bases</h2>
<p><span class="math display">\[
233_{10}=11101001_{2}
\]</span></p>
<ul>
<li><p>Why stack？ <code>Divide by Base</code> algorithm</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/conver-num-base.png" alt="conver-num-base" /><figcaption aria-hidden="true">conver-num-base</figcaption>
</figure></li>
<li><p>So, Push fisrt, Pop at the end</p></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DIGITS = <span class="string">&#x27;0123456789abcdef&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_to_base</span>(<span class="params">decimal_number, base</span>):</span></span><br><span class="line">    remainder_stack = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> decimal_number &gt; <span class="number">0</span>:</span><br><span class="line">        remainder = decimal_number % base</span><br><span class="line">        remainder_stack.append(remainder)</span><br><span class="line">        decimal_number = decimal_number // base</span><br><span class="line"></span><br><span class="line">    new_digits = []</span><br><span class="line">    <span class="keyword">while</span> remainder_stack:</span><br><span class="line">        new_digits.append(DIGITS[remainder_stack.pop()])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(new_digits)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">convert_to_base(<span class="number">25</span>, <span class="number">2</span>)  <span class="comment"># =&gt; &#x27;11001&#x27;</span></span><br><span class="line">convert_to_base(<span class="number">25</span>, <span class="number">16</span>)  <span class="comment"># =&gt; &#x27;19&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="example-infix-prefix-and-postfix-expressions">5. Example: Infix, Prefix and Postfix Expressions</h2>
<table>
<thead>
<tr class="header">
<th>Infix expression</th>
<th>Prefix expression</th>
<th>Postfix expression</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A + B</td>
<td>+ A B</td>
<td>A B +</td>
</tr>
<tr class="even">
<td>A + B * C</td>
<td>+ A * B C</td>
<td>A B C * +</td>
</tr>
</tbody>
</table>
<ul>
<li>Infix expression need parenthese to force the performance of addition before multiplication.</li>
<li>Prefix &amp; Postfixexpression <strong>DON'T</strong> need it</li>
</ul>
<p>How to convert infix to prefix or postfix?</p>
<blockquote>
<p>Fully parenthesize the expression using the order of operations. Then move the enclosed operator to the position of either the left or the right parenthesis depending on whether you want prefix or postfix notation.</p>
</blockquote>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/postfix.png" alt="postfix" /><figcaption aria-hidden="true">postfix</figcaption>
</figure>
<h3 id="algorithm">5.1 Algorithm</h3>
<ol type="1">
<li>Create an empty stack called <code>operation_stack</code> for keeping operators. Create an empty list for output.</li>
<li>Convert the input infix string to a list by using the string method <code>split</code>.</li>
<li>Scan the token list from left to right.
<ul>
<li>If the token is an operand, append it to the end of the output list.</li>
<li>If the token is a left parenthesis, push it on the <code>operation_stack</code>.</li>
<li>If the token is a right parenthesis, pop the <code>operation_stack</code> until the corresponding left parenthesis is removed. Append each operator to the end of the output list.</li>
<li>If the token is an operator, <code>*</code>, <code>/</code>, <code>+</code>, or <code>-</code>, push it on the <code>operation_stack</code>. However, first remove any operators already on the <code>operation_stack</code> that have higher or equal precedence and append them to the output list.</li>
</ul></li>
<li>When the input expression has been completely processed, check the <code>operation_stack</code>. Any operators still on the stack can be removed and appended to the end of the output list.</li>
</ol>
<h3 id="implementation">5.2 Implementation</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">PRECEDENCE = &#123;</span><br><span class="line">    <span class="string">&#x27;*&#x27;</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">&#x27;/&#x27;</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">&#x27;+&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;-&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;(&#x27;</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CHARACTERS = <span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span></span><br><span class="line">DIGITS = <span class="string">&#x27;0123456789&#x27;</span></span><br><span class="line">LEFT_PAREN = <span class="string">&#x27;(&#x27;</span></span><br><span class="line">RIGHT_PAREN = <span class="string">&#x27;)&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">infix_to_postfix</span>(<span class="params">infix_expression</span>):</span></span><br><span class="line">    operation_stack = []</span><br><span class="line">    postfix = []</span><br><span class="line">    tokens = infix_expression.split()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> token <span class="keyword">in</span> tokens:</span><br><span class="line">        <span class="keyword">if</span> token <span class="keyword">in</span> CHARACTERS <span class="keyword">or</span> token <span class="keyword">in</span> DIGITS:</span><br><span class="line">            postfix.append(token)</span><br><span class="line">        <span class="keyword">elif</span> token == LEFT_PAREN:</span><br><span class="line">            operation_stack.append(token)</span><br><span class="line">        <span class="keyword">elif</span> token == RIGHT_PAREN:</span><br><span class="line">            top_token = operation_stack.pop()</span><br><span class="line">            <span class="keyword">while</span> top_token != LEFT_PAREN:</span><br><span class="line">                postfix.append(top_token)</span><br><span class="line">                top_token = operation_stack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> operation_stack <span class="keyword">and</span> \</span><br><span class="line">                    (PRECEDENCE[operation_stack[<span class="number">-1</span>]] &gt;= PRECEDENCE[token]):</span><br><span class="line">                postfix.append(operation_stack.pop())</span><br><span class="line">            operation_stack.append(token)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> operation_stack:</span><br><span class="line">        postfix.append(operation_stack.pop())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(postfix)</span><br><span class="line"></span><br><span class="line">infix_to_postfix(<span class="string">&#x27;A * B + C * D&#x27;</span>)  <span class="comment"># =&gt; &#x27;A B * C D * +&#x27;</span></span><br><span class="line">infix_to_postfix(<span class="string">&#x27;( A + B ) * C - ( D - E ) * ( F + G )&#x27;</span>)</span><br><span class="line"><span class="comment"># =&gt; &#x27;A B + C * D E - F G + * -&#x27;</span></span><br><span class="line">infix_to_postfix(<span class="string">&#x27;( A + B ) * ( C + D )&#x27;</span>)  <span class="comment"># =&gt; &#x27;A B + C D + *&#x27;</span></span><br><span class="line">infix_to_postfix(<span class="string">&#x27;( A + B ) * C&#x27;</span>)  <span class="comment"># =&gt; &#x27;A B + C *&#x27;</span></span><br><span class="line">infix_to_postfix(<span class="string">&#x27;A + B * C&#x27;</span>)  <span class="comment"># =&gt; &#x27;A B C * +&#x27;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CS</category>
        <category>DS &amp; Algorithm</category>
      </categories>
      <tags>
        <tag>DS</tag>
      </tags>
  </entry>
  <entry>
    <title>算法设计——推导、递归、规约</title>
    <url>/2019/08/12/CS/DS%20&amp;%20Algorithm/induc-recur-redic/</url>
    <content><![CDATA[<h2 id="overview">Overview</h2>
<h3 id="规约">规约</h3>
<p>对问题进行转化，将未知的问题转化为能够解决的问题，其中设计对问题的输入输出的转换</p>
<h3 id="推导">推导</h3>
<p>类似于数学归纳法，我们要证明某个命题是正确的，先证明基础情况，然后证明命题的递推可以正常工作</p>
<h3 id="递归">递归</h3>
<p>一个函数调用自身，要确保的是对于基础情况（不递归的情况）可以正常工作</p>
<a id="more"></a>
<h2 id="三者之间的关系">三者之间的关系</h2>
<ul>
<li>推导和递归相对应
<ul>
<li>推导是<span class="math inline">\(n-1\to n\)</span> 递归是<span class="math inline">\(n\to n-1\)</span></li>
<li>这意味着这两者可以相互转化，通常情况下非递归的方式要好一些，因为运行速度更快，而且没有用栈去实现，避免了溢出</li>
</ul></li>
<li>推导和递归都属于规约
<ul>
<li>都是将一个问题变成另一个只是规模减小的相同问题</li>
</ul></li>
</ul>
<h2 id="例子">例子</h2>
<h3 id="排序">排序</h3>
<p>目的是对排序问题进行reduce</p>
<ul>
<li>reduce成两个规模为原来一半的问题，得到了归并排序</li>
<li>每次reduce一个元素，得到了插入排序</li>
<li>找到某个元素，放在位置k上，得到了快排</li>
</ul>
<h3 id="名人问题">名人问题</h3>
<p>从一系列有依赖关系的集合中找到那个依赖关系最开始元素，比如多线程环境下的线程依赖</p>
<p>目的也是进行reduce</p>
<ul>
<li><p>每次reduce一个人，暴力求解</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">naive_celeb</span>(<span class="params">G</span>):</span></span><br><span class="line">    n = len(G)</span><br><span class="line">    <span class="keyword">for</span> u <span class="keyword">in</span> range(n):  <span class="comment"># For every candidate...</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> range(n):  <span class="comment"># For everyone else...</span></span><br><span class="line">            <span class="keyword">if</span> u == v: <span class="keyword">continue</span>  <span class="comment"># Same person? Skip.</span></span><br><span class="line">            <span class="keyword">if</span> G[u][v]: <span class="keyword">break</span>  <span class="comment"># Candidate knows other</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> G[v][u]: <span class="keyword">break</span>  <span class="comment"># Other doesn&#x27;t know candidate</span></span><br><span class="line">          <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> u  <span class="comment"># No breaks? Celebrity!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span>  <span class="comment"># Couldn&#x27;t find anyone</span></span><br></pre></td></tr></table></figure></li>
<li><p>问题也可以理解为找一个非名人(u)，也就是找到一个人(u)，他要么认识其他某个人(v)，要么某个人(v)不认识他</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">celeb</span>(<span class="params">G</span>):</span></span><br><span class="line">    n = len(G)</span><br><span class="line">    u, v = <span class="number">0</span>, <span class="number">1</span>  <span class="comment"># The first two</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):  <span class="comment"># Others to check</span></span><br><span class="line">        <span class="keyword">if</span> G[u][v]:</span><br><span class="line">            u = c  <span class="comment"># u knows v? Replace u</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            v = c  <span class="comment"># Otherwise, replace v</span></span><br><span class="line">    <span class="keyword">if</span> u == n:</span><br><span class="line">        c = v  <span class="comment"># u was replaced last; use v</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        c = u  <span class="comment"># Otherwise, u is a candidate</span></span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> range(n):  <span class="comment"># For everyone else...</span></span><br><span class="line">        <span class="keyword">if</span> c == v: <span class="keyword">continue</span>  <span class="comment"># Same person? Skip.</span></span><br><span class="line">        <span class="keyword">if</span> G[c][v]: <span class="keyword">break</span>  <span class="comment"># Candidate knows other</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> G[v][c]: <span class="keyword">break</span>  <span class="comment"># Other doesn&#x27;t know candidate</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> c  <span class="comment"># No breaks? Celebrity!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span>  <span class="comment"># Couldn&#x27;t find anyone</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="拓扑排序">拓扑排序</h3>
<p>Linux系统中软件的安装，检测依赖</p>
<ul>
<li><p>递归，每次去掉一个节点，解决剩下的拓扑排序，在将去掉的节点插入合适的位置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">naive_topsort</span>(<span class="params">G, S=None</span>):</span></span><br><span class="line">    <span class="keyword">if</span> S <span class="keyword">is</span> <span class="literal">None</span>: S = set(G)  <span class="comment"># Default: All nodes</span></span><br><span class="line">    <span class="keyword">if</span> len(S) == <span class="number">1</span>: <span class="keyword">return</span> list(S)  <span class="comment"># Base case, single node</span></span><br><span class="line">    v = S.pop()  <span class="comment"># Reduction: Remove a node</span></span><br><span class="line">    seq = naive_topsort(G, S)  <span class="comment"># Recursion (assumption), n-1</span></span><br><span class="line">    min_i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, u <span class="keyword">in</span> enumerate(seq):</span><br><span class="line">        <span class="keyword">if</span> v <span class="keyword">in</span> G[u]: min_i = i + <span class="number">1</span>  <span class="comment"># After all dependencies</span></span><br><span class="line">    seq.insert(min_i, v)</span><br><span class="line">    <span class="keyword">return</span> seq</span><br><span class="line"></span><br><span class="line">G = &#123;<span class="string">&#x27;a&#x27;</span>: set(<span class="string">&#x27;bf&#x27;</span>), <span class="string">&#x27;b&#x27;</span>: set(<span class="string">&#x27;cdf&#x27;</span>),<span class="string">&#x27;c&#x27;</span>: set(<span class="string">&#x27;d&#x27;</span>), <span class="string">&#x27;d&#x27;</span>: set(<span class="string">&#x27;ef&#x27;</span>), <span class="string">&#x27;e&#x27;</span>: set(<span class="string">&#x27;f&#x27;</span>), <span class="string">&#x27;f&#x27;</span>: set()&#125;</span><br><span class="line"><span class="keyword">print</span> naive_topsort(G) <span class="comment"># [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;]</span></span><br></pre></td></tr></table></figure></li>
<li><p>规约，每次从图中删除一个入度为0的节点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topsort</span>(<span class="params">G</span>):</span></span><br><span class="line">    count = dict((u, <span class="number">0</span>) <span class="keyword">for</span> u <span class="keyword">in</span> G)  <span class="comment"># The in-degree for each node</span></span><br><span class="line">    <span class="keyword">for</span> u <span class="keyword">in</span> G:</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> G[u]:</span><br><span class="line">            count[v] += <span class="number">1</span>  <span class="comment"># Count every in-edge</span></span><br><span class="line">    Q = [u <span class="keyword">for</span> u <span class="keyword">in</span> G <span class="keyword">if</span> count[u] == <span class="number">0</span>]  <span class="comment"># Valid initial nodes</span></span><br><span class="line">    S = []  <span class="comment"># The result</span></span><br><span class="line">    <span class="keyword">while</span> Q:  <span class="comment"># While we have start nodes...</span></span><br><span class="line">        u = Q.pop()  <span class="comment"># Pick one</span></span><br><span class="line">        S.append(u)  <span class="comment"># Use it as first of the rest</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> G[u]:</span><br><span class="line">            count[v] -= <span class="number">1</span>  <span class="comment"># &quot;Uncount&quot; its out-edges</span></span><br><span class="line">            <span class="keyword">if</span> count[v] == <span class="number">0</span>:  <span class="comment"># New valid start nodes?</span></span><br><span class="line">                Q.append(v)  <span class="comment"># Deal with them next</span></span><br><span class="line">    <span class="keyword">return</span> S</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="如何解决一个问题">如何解决一个问题</h2>
<ol type="1">
<li><p>首先要搞明白你要解决的问题</p>
<ul>
<li>输入输出，将问题抽象为熟悉的结构</li>
</ul></li>
<li><p>寻找一个规约方式</p>
<p>将问题转化成另一个能够解决的问题，通过reduce一个元素</p></li>
<li><p>有没有其他的重要的假设条件</p></li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
        <category>DS &amp; Algorithm</category>
      </categories>
      <tags>
        <tag>DS</tag>
      </tags>
  </entry>
  <entry>
    <title>DS-Introduction</title>
    <url>/2019/07/08/CS/DS%20&amp;%20Algorithm/uda-ds-intro/</url>
    <content><![CDATA[<h2 id="introduction">Introduction</h2>
<h3 id="welcome">Welcome</h3>
<p>At its core, this program is about how to write code to <strong>solve problems</strong> and to do so <strong>efficiently</strong>.</p>
<p>The key to mastering these skills is practice.</p>
<h2 id="python-refresher">Python Refresher</h2>
<p>Using Python3 to do the exercise</p>
<ul>
<li><p>Control structure</p></li>
<li><p>Function &amp; Generator</p>
<blockquote>
<p>A generator in Python is similar to a function except instead of returning a value and exiting a process, a generator will pause the process, saving its state for next time. The biggest difference between a function and generator from a code perspective is one word: <code>return</code> is changed to <code>yield</code>.</p>
</blockquote></li>
</ul>
<a id="more"></a>
<ul>
<li><p>Classes</p>
<ul>
<li><code>self</code> a very important concept:star: which is used to reference a class instance's own variables and functions from within the class definition</li>
</ul></li>
</ul>
<h2 id="how-to-solve-problems">How to Solve Problems</h2>
<h2 id="efficiency">Efficiency</h2>
<h2 id="unscramble-computer-science-problem">Unscramble Computer Science Problem</h2>
]]></content>
      <categories>
        <category>CS</category>
        <category>DS &amp; Algorithm</category>
      </categories>
      <tags>
        <tag>DS</tag>
      </tags>
  </entry>
  <entry>
    <title>Data-Regression</title>
    <url>/2019/03/17/CS/Data/Data-Regression/</url>
    <content><![CDATA[<h2 id="introduction">1 Introduction</h2>
<blockquote>
<p>In statistical modeling, regression analysis is a set of statistical processes for <strong>estimating the relationships among variables.</strong></p>
</blockquote>
<p><span class="math display">\[
\left\{\begin{array}{l}{y=\beta_{0}+\beta_{1} x+\varepsilon} \\ {E \varepsilon=0, D \varepsilon=\sigma^{2}}\end{array}\right.
\]</span></p>
<a id="more"></a>
<h2 id="the-develop-of-algorithm">2 the Develop of Algorithm</h2>
<h3 id="problem-set">Problem set</h3>
<p><span class="math display">\[
\mathbf{X}=\left[ \begin{array}{cccc}{x_{11}} &amp; {x_{12}} &amp; { . .} &amp; {x_{1 m}} \\ {x_{21}} &amp; {x_{22}} &amp; {\dots} &amp; {x_{2 m}} \\ {\ldots} &amp; {\cdots} &amp; {\cdots} &amp; {\cdots} \\ {x_{n 1}} &amp; {x_{n 2}} &amp; {\dots} &amp; {x_{n m}}\end{array}\right]
\]</span></p>
<p><span class="math display">\[
Y=\left(y_{1} \quad y_{2}\right)=\left[ \begin{array}{cc}{y_{11}} &amp; {y_{12}} \\ {y_{12}} &amp; {y_{22}} \\ {\cdots} &amp; {\cdots} \\ {y_{1 n}} &amp; {y_{2 n}}\end{array}\right]
\]</span></p>
<p><span class="math display">\[
B=\left(b_{1} \quad b_{2}\right)=\left[ \begin{array}{cc}{b_{11}} &amp; {b_{21}} \\ {b_{12}} &amp; {b_{22}} \\ {\dots} &amp; {\dots} \\ {b_{1 m}} &amp; {b_{2 m}}\end{array}\right]
\]</span></p>
<p><span class="math display">\[
E=\left(e_{1} \quad e_{2}\right)=\left[ \begin{array}{cc}{e_{11}} &amp; {e_{21}} \\ {e_{12}} &amp; {e_{22}} \\ {\cdots} &amp; {\cdots} \\ {e_{1 n}} &amp; {e_{2 n}}\end{array}\right]
\]</span></p>
<p><span class="math display">\[
\boldsymbol{Y}=\boldsymbol{X} \boldsymbol{B}+\boldsymbol{E} ; \quad y_{1}=\boldsymbol{X} \boldsymbol{b}_{1} ; \quad y_{2}=\boldsymbol{X} \boldsymbol{b}_{2}
\]</span></p>
<p>we know (2) and (3), we want to get (6) , so we need to solve (4) and (5)</p>
<h3 id="ols">2.1 OLS</h3>
<p>Ordinary least squares</p>
<ul>
<li><p>Constraint: <span class="math inline">\(min(error)​\)</span> <span class="math display">\[
e=y-\mathbf{X} b \quad \Rightarrow \quad \min \left(e^{\prime} e\right)
\]</span></p></li>
<li><p>Solution: Solved by Lagrange Multiplier <span class="math display">\[
b=\left(X^{\prime} X\right)^{-1} X^{\prime}{y}
\]</span></p></li>
<li><p>Problem: if there are multi -collinearity in <span class="math inline">\(\mathbf{X}​\)</span> , <span class="math inline">\(b​\)</span> will be <strong>very big</strong>, like <span class="math inline">\(\infin​\)</span></p></li>
</ul>
<h3 id="rr">2.2 RR</h3>
<p>Ridge Regression: solve the problem in the OLS, add some constraint for <span class="math inline">\(b​\)</span></p>
<ul>
<li><p>Constraint: <span class="math inline">\(min(error \ \&amp;\ b​\)</span>) <span class="math display">\[
e=y-\mathbf{X} b \quad \Rightarrow \quad \min \left(e^{\prime} e+kb^{\prime}b \right )
\]</span></p></li>
<li><p>Solution: <span class="math display">\[
\hat{\boldsymbol{\beta}}(\mathrm{k})=\left(X^{\prime} X+k I\right)^{-1} X^{\prime} y
\]</span></p></li>
<li><p>Problem: how to choose <span class="math inline">\(k\)</span> is a problem</p></li>
</ul>
<p><a href="https://stats.stackexchange.com/questions/118712/why-does-ridge-estimate-become-better-than-ols-by-adding-a-constant-to-the-diago/119708#119708">Why it called <em>ridge</em>?</a></p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/岭回归.png" alt="岭回归" /><figcaption aria-hidden="true">岭回归</figcaption>
</figure>
<h3 id="pcr">2.3 PCR</h3>
<p>Principal Component Regression: Often the principal components with higher variances are selected as regressors</p>
<ul>
<li><p>Constraint: Apply PCA to <span class="math inline">\(\mathbf{X}\)</span>, get component matrix <span class="math inline">\(\mathbf{F}\)</span> <span class="math display">\[
\mathbf{F}=\mathbf{X}_{0} \mathbf{U}
\]</span></p></li>
<li><p>Solution: <span class="math display">\[
\hat{\gamma}=\left(\mathbf{F}^{\prime} \mathbf{F}\right)^{-1} \mathbf{F}^{\prime} \mathbf{Y}
\]</span></p></li>
<li><p>Problem: for the purpose of predicting the outcome, the principal components with <strong>low variances</strong> may also be <strong>important</strong>, in some cases even more important. <a href="https://www.jstor.org/stable/2348005">MORE</a></p></li>
</ul>
<h3 id="pls">2.4 PLS</h3>
<p>Partial least squares regression: it finds a linear regression model by projecting the predicted variables and the observable variables to a <em>new space</em></p>
<p>Underlying model of PLS:</p>
<p><span class="math display">\[
\begin{aligned} X &amp;=T P^{\mathrm{T}}+E \\ Y &amp;=U Q^{\mathrm{T}}+F \end{aligned}
\]</span></p>
<ul>
<li>Constraint:
<ol type="1">
<li>Variances of <span class="math inline">\(T\)</span> and <span class="math inline">\(U\)</span> should be as big as possible</li>
<li>Correlation of <span class="math inline">\(T​\)</span> and <span class="math inline">\(U​\)</span> should be as big as possible</li>
</ol>
<ul>
<li>Combine 1. and 2. , we want covariance of <span class="math inline">\(T\)</span> and <span class="math inline">\(U​\)</span> be as big as possible</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>Data</category>
      </categories>
      <tags>
        <tag>data</tag>
        <tag>regression</tag>
      </tags>
  </entry>
  <entry>
    <title>Data-PCA</title>
    <url>/2019/03/08/CS/Data/Date-PCA/</url>
    <content><![CDATA[<h2 id="introduction">1 Introduction</h2>
<p>Principal component analysis (PCA) is a common tool for data analysis</p>
<ul>
<li>Goal: reduce complex data set to a <strong>lower dimension</strong></li>
<li>Math tool: singular value decomposition (<strong>SVD</strong>)</li>
</ul>
<a id="more"></a>
<h3 id="intuition">1.1 intuition</h3>
<p>Many problem in real world can be expressed by <strong>a small number of variables</strong>. But we don't know that, we just collect <strong>so many data</strong> and have no ideal how to deal with <strong>hundreds of variables</strong>. Also, there will be noise in our data, which makes the problem even more complicated.</p>
<p>PCA is to solve this problem by <em>identify the <strong>most meaningful</strong> basis to re-express the data.</em> Then we can delete the less important basis( variable)</p>
<h3 id="a-little-math">1.2 A little math</h3>
<ul>
<li><span class="math inline">\(\mathbf{X}\)</span> : the original data set <span class="math inline">\(\rightarrow\)</span> how to re-express <span class="math inline">\(\mathbf{X}\)</span>
<ul>
<li>row : variable ;</li>
<li>column : measurements</li>
</ul></li>
<li><span class="math inline">\(\mathbf{Y}\)</span> : transformed data set <span class="math inline">\(\rightarrow\)</span> how <span class="math inline">\(\mathbf{Y}\)</span> should look like <span class="math inline">\(\rightarrow\)</span> <span class="math inline">\(\mathrm{C}_{\mathrm{Y}}\)</span></li>
<li><span class="math inline">\(\mathbf{P}​\)</span> : transformation</li>
<li><span class="math inline">\(\sigma_{\mathrm{ab}}^{2}​\)</span> : covariance o f A and B
<ul>
<li><span class="math inline">\(\sigma_{\mathrm{ab}}^{2} \equiv \frac{1}{n} \mathbf{a b}^{T}\)</span> , <span class="math inline">\(\mathbf{a}=\left[a_{1} a_{2} \ldots a_{n}\right]\)</span> ,<span class="math inline">\(\mathbf{b}=\left[b_{1} b_{2} \ldots b_{n}\right]\)</span></li>
</ul></li>
<li><span class="math inline">\(\mathbf{C}_{\mathbf{X}} \equiv \frac{1}{n} \mathbf{X} \mathbf{X}^{T}\)</span> : covariance matrix of <span class="math inline">\(\mathbf{X}\)</span>, the covariance value reflect the noise and redundancy in the measurement
<ul>
<li>large off-diagonal terms correspond to high redundancy</li>
</ul></li>
</ul>
<p><strong>Assumption 1</strong>: <em>bigger variance, more information</em> <strong>Assumption 2</strong>: If the covariance of 2 variable is big, one of them should be deleted. <strong>Assumption 3</strong>: the principal components are orthogonal</p>
<h3 id="goal-in-math">1.3 Goal in math</h3>
<p>Find a transformation <span class="math inline">\(\mathbf{P}​\)</span>( an orthonormal matrix) to make <span class="math inline">\(\mathrm{C}_{\mathrm{Y}}​\)</span></p>
<ul>
<li>A diagonal matrix, means <span class="math inline">\(\mathbf{Y}​\)</span> is <strong>decorrelated</strong></li>
<li>diagonal terms <strong>decrease</strong> from the top-left, means <span class="math inline">\(\mathbf{Y}​\)</span> is rank-ordered</li>
</ul>
<h2 id="math-solution-for-pca">2. Math Solution for PCA</h2>
<h3 id="eigenvector-decomposition">2.1 Eigenvector Decomposition</h3>
<ol type="1">
<li><p>Rewriting <span class="math inline">\(\mathrm{C}_{\mathrm{Y}}\)</span> <span class="math display">\[
\begin{aligned} \mathbf{C}_{Y} &amp;=\frac{1}{n} \mathbf{Y} \mathbf{Y}^{T} \\ &amp;=\frac{1}{n}(\mathbf{P X})(\mathbf{P X})^{T} \\ &amp;=\frac{1}{n} \mathbf{P} \mathbf{X} \mathbf{X}^{T} \mathbf{P}^{T} \\ &amp;=\mathbf{P}\left(\frac{1}{n} \mathbf{X} \mathbf{X}^{T}\right) \mathbf{P}^{T}\\&amp;=\mathbf{P} \mathbf{C}_{\mathbf{X}} \mathbf{P}^{T} \end{aligned}
\]</span></p></li>
<li><p>Notice that <span class="math inline">\(\mathrm{C}_{\mathrm{X}}\)</span> is a symmetric matrix, and can be diagonalized.</p>
<p><span class="math display">\[
\mathrm{C}_{\mathrm{X}}=\mathbf{E D E}^{T}
\]</span></p>
<ul>
<li><span class="math inline">\(\mathbf{D}​\)</span> is a diagonal matrix</li>
<li><span class="math inline">\(\mathbf{E}\)</span> is a matrix of eigenvectors of <span class="math inline">\(\mathrm{C}_{\mathrm{X}}​\)</span></li>
</ul></li>
<li><p><strong>Trick</strong>: select <span class="math inline">\(\mathbf{P}\)</span> to be a matrix of eigenvectors of <span class="math inline">\(\mathrm{C}_{\mathrm{X}}​\)</span> <span class="math display">\[
\begin{aligned} \mathbf{C}_{\mathbf{Y}} &amp;=\mathbf{P} \mathbf{C}_{\mathbf{X}} \mathbf{P}^{T} \\ &amp;=\mathbf{P}\left(\mathbf{E}^{T} \mathbf{D E}\right) \mathbf{P}^{T} \\ &amp;=\mathbf{P}\left(\mathbf{P}^{T} \mathbf{D P}\right) \mathbf{P}^{T} \\ &amp;=\left(\mathbf{P} \mathbf{P}^{T}\right) \mathbf{D}\left(\mathbf{P} \mathbf{P}^{T}\right) \\ &amp;=\left(\mathbf{P} \mathbf{P}^{-1}\right) \mathbf{D}\left(\mathbf{P} \mathbf{P}^{-1}\right)\\ &amp;=\mathbf{D} \end{aligned}
\]</span></p></li>
</ol>
<h3 id="singular-value-decomposition">2.2 Singular Value Decomposition</h3>
<p>SVD is a more general method of understanding <em>change of basis</em></p>
<ol type="1">
<li>Let <span class="math inline">\(\mathbf{X}\)</span> be an arbitrary <span class="math inline">\(n\times m\)</span> matrix, and <span class="math inline">\(\mathbf{X}^{T} \mathbf{X}\)</span> be a rank <em>r</em> , square, symmetric <span class="math inline">\(m\times m\)</span> matrix.
<ul>
<li>define <span class="math inline">\(\left\{\hat{\mathbf{v}}_{1}, \hat{\mathbf{v}}_{2}, \ldots, \hat{\mathbf{v}}_{r}\right\}\)</span> be the eigenvectors of <span class="math inline">\(\mathbf{X}^{T} \mathbf{X}\)</span> with associated with eighenvalues <span class="math inline">\(\left\{\lambda_{1}, \lambda_{2}, \ldots, \lambda_{r}\right\}​\)</span></li>
<li>define <span class="math inline">\(\sigma_{i} \equiv \sqrt{\lambda_{i}}\)</span> are positive real and termed the <em>singular value</em></li>
<li>define <span class="math inline">\(\left\{\hat{\mathbf{u}}_{1}, \mathbf{\hat { u }}_{2}, \ldots, \hat{\mathbf{u}}_{r}\right\}\)</span> where <span class="math inline">\(\hat{\mathbf{u}}_{\mathbf{i}} \equiv \frac{1}{\sigma_{\mathbf{i}}} \mathbf{X} \hat{\mathbf{v}}_{\mathbf{i}}\)</span> (scaler version SVD)</li>
</ul></li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
        <category>Data</category>
      </categories>
      <tags>
        <tag>data</tag>
      </tags>
  </entry>
  <entry>
    <title>ML:Bayesian Learning</title>
    <url>/2019/01/16/CS/Machine%20Learning/ML-BayesianLearning/</url>
    <content><![CDATA[<h2 id="introduction">1 Introduction</h2>
<p>Testing whether a hypothesis is true or false by calculating the probability of an event in a prolonged experiment is known as <strong><em>frequentist statistics</em></strong></p>
<a id="more"></a>
<ul>
<li>An experiment with an <strong>infinite</strong> number of trials guarantees <span class="math inline">\(p\)</span> with <strong>absolute</strong> accuracy
<ul>
<li>It's <strong>not practial</strong> to conduct an experiment with an <strong>infinite</strong> number of trials</li>
<li>deciding the value of this sufficient number of trials is a <strong>challenge</strong></li>
</ul></li>
<li>If we can determine the <strong><em>confidence</em></strong> of the estimated <span class="math inline">\(p\)</span> , it will allow us to decide whether to
<ul>
<li><strong>accept</strong> the conclusion</li>
<li><strong>extend</strong> the experiment with more trials until it achieves sufficient confidence</li>
</ul></li>
<li><strong><em>prior beliefs</em></strong> (for example, coins are usually fair and the coin used is not made biased intentionally, therefore <span class="math inline">\(p≈0.5\)</span>)
<ul>
<li>play a significant role in shaping the outcome of a hypothesis test</li>
<li>However, it ==can't== be used along with <em>frequentist statistics</em></li>
</ul></li>
</ul>
<h2 id="bayesian-learning">2 Bayesian Learning</h2>
<p>Consider the flip coin experiment, if you flip the coin <span class="math inline">\(10\)</span> times, there are 2 case:</p>
<ul>
<li><p>5 heads and 5 tails</p>
<ul>
<li>more confidence about that <span class="math inline">\(p=0.5​\)</span></li>
</ul></li>
<li><p><span class="math inline">\(x\)</span> head and <span class="math inline">\(10-x\)</span> tails</p>
<p>Now you have 2 options</p>
<ul>
<li><em>frequentist statistics</em> :Neglect prior beliefs, just based on data</li>
<li><em>Bayesian Learning</em> :Adjust your belief according to observation</li>
</ul></li>
</ul>
<h3 id="bayes-theorem">2.1 Bayes' Theorem</h3>
<p>Bayes’ theorem <span class="math display">\[
P ( \theta | X ) = \frac { P ( X | \theta ) P ( \theta ) } { P ( X ) }
\]</span></p>
<ul>
<li><span class="math inline">\(P ( \theta )\)</span> Prior Probability is the probability of the hypothesis <span class="math inline">\(\theta\)</span> being true</li>
<li><span class="math inline">\(P ( X | \theta )​\)</span> Likelihood is the conditional probability of the evidence given a hypothesis</li>
<li><span class="math inline">\(P ( X )\)</span> Evidence :a summation (or integral) of the probabilities of all possible hypotheses</li>
<li><span class="math inline">\(P ( \theta | X )​\)</span> Posteriori probability</li>
</ul>
<h3 id="application1-map">2.2 Application1: MAP</h3>
<p>Used to confirm the valid hypothesis using posterior probabilities <span class="math display">\[
\begin{aligned} \theta _{ M A P } &amp; = \operatorname { argmax }_ { \theta } P \left( \theta _{ i } | X \right) \\ &amp; = \operatorname { argmax }_ { \theta } \left( \frac { P ( X | \theta _{ i } ) P \left( \theta_ { i } \right) } { P ( X ) } \right) \end{aligned}
\]</span> <span class="math inline">\(P(x)\)</span> is independent of <span class="math inline">\(\theta\)</span> . Therefore, we can simplify the $_{MAP} $ to <span class="math display">\[
\theta_ { M A P } = \operatorname { argmax } _{ \theta } \left( P ( X | \theta_ { i } ) P \left( \theta _ { i } \right) \right)
\]</span></p>
<h3 id="how-to-achieve-the-goal">2.3 How to Achieve the Goal</h3>
<p>For the <span class="math inline">\(P ( X | \theta _ { i } )\)</span> part</p>
<p>Use <span class="math inline">\(MLE\)</span></p>
<p><span class="math display">\[
\frac { d } { d \theta } \ln P (X | \theta ) = 0
\]</span></p>
<hr />
<p>For the <span class="math inline">\(P \left( \theta _ { i } \right)\)</span> part</p>
<p>if the hypothesis space is continuous, it will be <strong>endless</strong> hypothesis.</p>
<p>So in practical, we use <strong>approximation</strong> techniques : <strong><em>Beta prior distribution</em></strong> <span class="math display">\[
P ( \theta ) = \frac { \theta ^ { \alpha - 1 } ( 1 - \theta ) ^ { \beta - 1 } } { B ( \alpha , \beta ) }
\]</span></p>
<ul>
<li><span class="math inline">\(B ( \alpha , \beta )\)</span> acts as the normalizing constant</li>
</ul>
<h3 id="example">2.4 Example</h3>
<p>As a Binomial probability example <span class="math display">\[
P ( k , N | \theta ) = \left( \begin{array} { c } { N } \\ { k } \end{array} \right) \theta ^ { k } ( 1 - \theta ) ^ { N - k }
\]</span></p>
<p><span class="math display">\[
P ( \theta ) = \frac { \theta ^ { \alpha - 1 } ( 1 - \theta ) ^ { \beta - 1 } } { B ( \alpha , \beta ) }
\]</span></p>
<p>So the posterior <span class="math display">\[
\begin{aligned} P ( \theta | N , k ) &amp; = \frac { P ( N , k | \theta ) \times P ( \theta ) } { P ( N , k ) } \\ &amp; = \frac { \left( \begin{array} { c } { N } \\ { k } \end{array} \right) } { B ( \alpha , \beta ) \times P ( N , k ) } \times \theta ^ { ( k + \alpha ) - 1 } ( 1 - \theta ) ^ { ( N + \beta - k ) - 1 } \end{aligned}
\]</span> and consider it as a <strong>new</strong> <em>Beta prior distribution</em> <span class="math display">\[
P ( \theta | N , k ) = \frac { \theta ^ { \alpha _{ n e w } - 1 } ( 1 - \theta ) ^ { \beta_ { n e w } - 1 } } { B \left( \alpha _{ n e w } , \beta_ { n e w } \right) }
\]</span></p>
<h2 id="bayes-optimal-classifier">3 Bayes Optimal Classifier</h2>
<p>Given new <strong>instance</strong> <span class="math inline">\(x\)</span>, the hypothesis we get previously <span class="math inline">\(h _ { M A P } ( x )\)</span> may be not the most probable classification.</p>
<blockquote>
<p>e.g.1 <span class="math display">\[
P \left( h _{ 1 } | D \right) = 0.4 , P \left( h_ { 2 } | D &gt;\right) = 0.3 , P \left( h _ { 3 } | D \right) = 0.3
\]</span> New instance</p>
<p><span class="math display">\[
h _{ 1 } ( x ) = + , h_ { 2 } ( x ) = - , h _ { 3 } ( x ) = -
\]</span></p>
</blockquote>
<p>Bayes optimal classifier tell us that we should find: <span class="math display">\[
\arg \max _{ v_ { j } \in V } \sum _{ h_ { i } \in H } P \left( v _{ j } | h_ { i } \right) P \left( h _ { i } | D \right)
\]</span></p>
<blockquote>
<p>e.g.1</p>
<p><span class="math display">\[
P \left( h _{ 1 } | D \right)  = 0.4 , P ( - | h_ { 1 } ) = 0 , &gt;P ( + | h _{ 1 } ) = 1 \\ P \left( h_ { 2 } | D \right) =  0.3 , &gt;P ( - | h _{ 2 } ) = 1 , P ( + | h_ { 2 } ) = 0 \\ P \left( h _{ &gt;3 } | D \right) =  0.3 , P ( - | h_ { 3 } ) = 1 , P ( + | h _{ 3 &gt;} ) = 0
\]</span> therefore <span class="math display">\[
\begin{aligned} \sum_ { h _{ i } \in H } P ( + | h_ { i } ) P &gt;\left( h _{ i } | D \right) &amp; = .4 \\ \sum_ { h _{ i } \in H } P &gt;( - | h_ { i } ) P \left( h _ { i } | D \right) &amp; = .6 &gt;\end{aligned}
\]</span> so we choose <span class="math inline">\(-\)</span> as the classification</p>
</blockquote>
<h2 id="navie-bayes-classifier">4 Navie Bayes Classifier</h2>
<p>When to use:</p>
<ul>
<li>Large training set available</li>
<li>Attributes are independent</li>
<li>Used in <em>diagnosis</em> and <em>text classification</em></li>
</ul>
<p>Navie Bayes assumption： <span class="math display">\[
P \left( a _{ 1 } , a_ { 2 } \ldots a _{ n } | v_ { j } \right) = \prod _{ i } P \left( a_ { i } | v _{ j } \right)
\]</span> Bayes MAP <span class="math display">\[
\begin{aligned} v_ { M A P } &amp; = \underset { v _{ j } \in V } { \operatorname { argmax } } \frac { P \left( a_ { 1 } , a _{ 2 } \ldots a_ { n } | v _{ j } \right) P \left( v_ { j } \right) } { P \left( a _{ 1 } , a_ { 2 } \ldots a _{ n } \right) } \\ &amp; = \underset { v_ { j } \in V } { \operatorname { argmax } } P \left( a _{ 1 } , a_ { 2 } \ldots a _{ n } | v_ { j } \right) P \left( v _{ j } \right) \end{aligned}
\]</span> Navie Bayes Classifier <span class="math display">\[
v_ { N B } = \underset { v _{ j } \in V } { \operatorname { argmax } } P \left( v_ { j } \right) \prod _{ i } P \left( a_ { i } | v _ { j } \right)
\]</span></p>
<h2 id="bayesian-belief-networks">5 Bayesian Belief Networks</h2>
<p>Improve Navie Bayes Classifier:</p>
<ul>
<li>Attributes are independent <span class="math inline">\(\to\)</span> too restrictive</li>
<li>So Bayes Nets describe conditional independence among <strong><em>subsets</em></strong></li>
</ul>
<blockquote>
<p>Conditional Independence <span class="math display">\[
P ( X | Y , Z ) = P ( X | Z )
\]</span> e.g. <span class="math inline">\(P ( \text { Thunder } | \text { Rain, Lightning) } = P ( \text { Thunder } | \text {Lightning} )\)</span></p>
</blockquote>
<p>Bayes nets use cond. indep. to justify <span class="math display">\[
\begin{aligned} P ( X , Y | Z ) &amp; = P ( X | Y , Z ) P ( Y | Z ) \\ &amp; = P ( X | Z ) P ( Y | Z ) \end{aligned}
\]</span> A network</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/bayesian-belief-network.png" alt="bayesian-belief-network" /><figcaption aria-hidden="true">bayesian-belief-network</figcaption>
</figure>
<p>in general <span class="math display">\[
P \left( y _{ 1 } , \ldots , y_ { n } \right) = \prod _{ i = 1 } ^ { n } P \left( y_ { i } | \text { Parents } \left( Y _{ i } \right) \right)
\]</span> So, joint distribution is fully defined by <strong>graph</strong>, and <span class="math inline">\(P \left( y_ { i } | \text { Parents } \left( Y _ { i } \right) \right)\)</span></p>
<hr />
<p>Learning task:</p>
<ul>
<li>Graph structure might be <em>known</em> or <em>unknown</em></li>
<li>Training data might provide <em>all</em> or <em>some</em> variables</li>
</ul>
<p>Case 1: known</p>
<ul>
<li>Simlilar to training neural network with hidden units</li>
<li>Using gradient <strong>ascent</strong>
<ul>
<li>to <strong>maximizes</strong> <span class="math inline">\(P ( D | h )\)</span></li>
</ul></li>
<li>Using EM (Expection Maximization)
<ul>
<li>to <strong>maximizes</strong> <span class="math inline">\(E [ \ln P ( D | h ) ]\)</span></li>
</ul></li>
</ul>
<p>Case 2: unknown</p>
<ul>
<li>Use greedy search to add/substact edges and nodes</li>
<li>…… ==in research==</li>
</ul>
<h2 id="appendix-em">Appendix: EM</h2>
<p>When to use? Data is only <strong>partially</strong> observable</p>
<h3 id="question-definition">Question Definition</h3>
<p>Given:</p>
<ul>
<li>Observed data <span class="math inline">\(X = \left\{ x _{ 1 } , \ldots , x_ { m } \right\}\)</span></li>
<li>Unobserved data <span class="math inline">\(Z = \left\{ z _{ 1 } , \ldots , z_ { m } \right\}\)</span></li>
<li>Probablity distribution <span class="math inline">\(P ( Y | h )\)</span>
<ul>
<li><span class="math inline">\(Y = \left\{ y _{ 1 } , \dots , y_ { m } \right\}\)</span> where <span class="math inline">\(y _{ i } = x_ { i } \cup z _ { i }\)</span></li>
<li><span class="math inline">\(h\)</span> parameters</li>
</ul></li>
</ul>
<p>Determin:</p>
<p><span class="math inline">\(h​\)</span> that maximizes <span class="math inline">\(E [ \ln P ( Y | h ) ]​\)</span></p>
<h3 id="general-method">General Method</h3>
<p>Use <span class="math inline">\(h\)</span> and <span class="math inline">\(X\)</span> <strong>estimate</strong> <span class="math inline">\(Z\)</span> <span class="math display">\[
E [ \ln P ( Y | h ) ] \to E [ \ln P ( Y | h ^ { \prime } ) | h , X ]
\]</span></p>
]]></content>
      <categories>
        <category>CS</category>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>ml</tag>
        <tag>bayes</tag>
      </tags>
  </entry>
  <entry>
    <title>ML:First Step</title>
    <url>/2019/01/16/CS/Machine%20Learning/ML-ConceptLearning/</url>
    <content><![CDATA[<h2 id="introduction">1 Introduction</h2>
<p><strong>How</strong> machine can learn from data?</p>
<p>First of all, we need to understand human brain. And we can make the machine learning application work the same way as our brain did.</p>
<a id="more"></a>
<p><strong>Most</strong> simple algorithms: <strong>Find-S</strong></p>
<h2 id="what-is-concept-learning">2 What is Concept Learning</h2>
<blockquote>
<p>“The problem of searching through a predefined space of potential hypotheses for the hypothesis that best fits the training examples.”</p>
<p>​ — Tom Michell</p>
</blockquote>
<p>Human learning: acquiring general concepts from past experiences.</p>
<p>Machine learning: find a hypothesis that best fits the training example.</p>
<p>Notaion:</p>
<ul>
<li>target concept <span class="math inline">\(c\)</span></li>
<li>object <span class="math inline">\(X\)</span></li>
<li>all hypothesis set <span class="math inline">\(H\)</span></li>
<li><span class="math inline">\(c : X \to \{ 0,1 \}\)</span></li>
</ul>
<p><strong>*</strong>*<strong>What we should do is to find a hypothesis</strong> <span class="math inline">\(h ( x ) = c ( x ) \text { for all } x \text { in } X\)</span></p>
<blockquote>
<p>Good hypothesis fit <strong>large set</strong> of training example well</p>
<p><span class="math inline">\(\to\)</span> the hypothesis fit <strong>unobserved</strong> example well</p>
</blockquote>
<h2 id="find-s">3 Find-S</h2>
<h3 id="hypothesis-notations">3.1 Hypothesis Notations</h3>
<ol type="1">
<li><span class="math inline">\(\varnothing\)</span> :a hypothesis that <strong>rejects all</strong></li>
<li><span class="math inline">\(&lt; ? , ? , ? , ? &gt;\)</span> :<strong>accepts all</strong></li>
<li><span class="math inline">\(&lt; \text { true, false, } ? , ? &gt;\)</span> :<strong>accepts some</strong></li>
</ol>
<p>Total number of the possible hypothesis <span class="math inline">\(N=(3*3*3*3)+1=82\)</span></p>
<h3 id="specific-to-general">3.2 Specific to General</h3>
<ol type="1">
<li>Start with the most specific hypothesis <span class="math inline">\(\mathbf { h } \leftarrow &lt; \boldsymbol { \varnothing } , \boldsymbol { \varnothing } , \boldsymbol { \varnothing } , \boldsymbol { \varnothing } &gt;\)</span></li>
<li>Pick up a sample
<ol type="1">
<li>if sample is <strong>negative</strong> <span class="math inline">\(\to​\)</span> unchanged</li>
<li>if sample is <strong>positive</strong> <span class="math inline">\(\to\)</span> update current hypothesis
<ul>
<li><span class="math inline">\(&lt;true,true,false,true&gt; \and &lt;true,true,false,false&gt; \to &lt;true,true,false,?&gt;\)</span></li>
</ul></li>
</ol></li>
<li>repetition of Step 2</li>
</ol>
<h3 id="limitations">3.3 Limitations</h3>
<ul>
<li>No way to determine if result is consistent with the data</li>
<li>Inconsistent sets will mislead the result</li>
<li>No backtrack</li>
</ul>
<h2 id="candidate-elimination">4 Candidate-elimination</h2>
<h3 id="chrarcters">4.1 Chrarcters</h3>
<p>Maintain 2 hypothesis</p>
<ul>
<li><span class="math inline">\(S_0\)</span> most specific</li>
<li><span class="math inline">\(G_0\)</span> most general</li>
</ul>
<h3 id="algorithm">4.2 Algorithm</h3>
<p>Pick up a sample</p>
<ul>
<li>if sample is <strong>negative</strong> <span class="math inline">\(\to\)</span> specificalize <span class="math inline">\(G_0\)</span></li>
<li>if sample is <strong>positive</strong> <span class="math inline">\(\to\)</span> generalize <span class="math inline">\(S_0\)</span></li>
</ul>
<h3 id="limitations-1">4.3 Limitations</h3>
<p>Low fault tolerance</p>
<h2 id="inductive-bias">5 Inductive Bias</h2>
<p>Stronger the bias is, more powerful the generaliztion is.</p>
<p>indicate that: If there is no assumption, the learner can learn <strong>nothing</strong> but the <strong>data</strong></p>
<p>Common biases:</p>
<ul>
<li>Maximum conditional independence</li>
<li>Minimum cross-validation error</li>
<li>Minimum description length :<em>Occam's razor</em></li>
<li>Minimum features</li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>ml</tag>
      </tags>
  </entry>
  <entry>
    <title>ML:Decision Tree</title>
    <url>/2019/01/16/CS/Machine%20Learning/ML-DTree/</url>
    <content><![CDATA[<h2 id="introduction">1 Introduction</h2>
<h3 id="what-is-a-decision-tree">1.1 What is a Decision Tree</h3>
<p>A tree shaped supervised learning algorithm</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/decision-tree.png" alt="decision-tree" /><figcaption aria-hidden="true">decision-tree</figcaption>
</figure>
<a id="more"></a>
<p>Problem setting:</p>
<ul>
<li>Set of possible instances <span class="math inline">\(X\)</span>
<ul>
<li>each instance <span class="math inline">\(x\)</span> in <span class="math inline">\(X\)</span> is a feature vector <span class="math inline">\(x = &lt; x _{ 1 } , x_ { 2 } \ldots x _ { n } &gt;\)</span></li>
</ul></li>
<li>Unknown target function <span class="math inline">\(f : X \rightarrow Y\)</span></li>
<li>Set of function hypotheses <span class="math inline">\(H = \{ h | h : X \rightarrow Y \}\)</span></li>
</ul>
<p>Input:</p>
<ul>
<li>Training examples <span class="math inline">\(\left\{ &lt; x ^ { ( i ) } , y ^ { ( i ) } &gt; \right\}\)</span></li>
</ul>
<p>Output:</p>
<ul>
<li>Hypothesis <span class="math inline">\(h \in H\)</span> that best approximates target function <span class="math inline">\(f\)</span></li>
</ul>
<h3 id="how-it-works">1.2 How it works</h3>
<p>The tree divide the data into many categories make biggest <strong>entropy</strong>. That means the tree will try to get the <strong>maximum information gain</strong> from the dataset.</p>
<h2 id="how-to-split-a-node">2 How to Split a Node</h2>
<p>In other word, how to split a node into 2 or more sub-nodes.</p>
<p>There are multiple methods can be used：</p>
<ol type="1">
<li><p>Information gain</p>
<ul>
<li><p>Based on entropy and information theory.</p></li>
<li><p>Used by <em>ID3</em> <em>C4.</em>5 <em>C5.0</em></p></li>
<li><p>Entropy <span class="math inline">\(\mathrm { H } ( T ) = \mathrm { I } _{ E } \left( p_ { 1 } , p _{ 2 } , \ldots , p_ { J } \right) = - \sum _{ i = 1 } ^ { J } p_ { i } \log _{ 2 } p_ { i }\)</span></p>
<p>Note: <span class="math inline">\(\sum p_i=1\)</span> which means if <span class="math inline">\(p_i=p_j\)</span> ,<span class="math inline">\(H(T)\)</span> is biggest $1 $ (equal probablity, most chaos)</p></li>
<li><p>Information Gain <span class="math display">\[
I G ( T , a ) = H ( T ) -  \mathrm { H } ( T | a )\\
=- \sum _{ i = 1 } ^ { J } p_ { i } \log _{ 2 } p_ { i } - \sum _{ a } p ( a ) \sum_ { i = 1 } ^ { J } - \operatorname { Pr } ( i | a ) \log _ { 2 } \operatorname { Pr } ( i | a )
\]</span></p></li>
</ul></li>
<li><p>Gini impurity</p>
<ul>
<li><p>A measure of impurity, lower <span class="math inline">\(\to\)</span> better</p></li>
<li><p>Used by <em>CART</em> (classification and regression tree) for <strong>classification</strong></p></li>
<li><p>Calculation <span class="math display">\[
\mathrm { I } _{ G } ( p )= 1 - \sum_ { i = 1 } ^ { J } p _ { i } ^ { 2 }
\]</span></p></li>
</ul></li>
<li><p>Variance reduction</p>
<ul>
<li>Used by <em>CART</em> (classification and regression tree) for <strong>regression</strong></li>
</ul></li>
</ol>
<h2 id="overfitting">3 Overfitting</h2>
<p>How to avoid?</p>
<ul>
<li><p>Stop growing when data split not statistically <strong>significant</strong></p>
<ul>
<li>easy to understand</li>
<li>hard to decide what is significant</li>
</ul></li>
<li><p>Grow full tree, then post-prune</p>
<ul>
<li>useful in practice</li>
<li>Reduced-Error Pruning
<ol type="1">
<li>Create a tree that classifies <strong>training set</strong></li>
<li>Evaluate impact on <em>validation set</em> of purning each possible node</li>
<li>Greedily remove the impact most slightly</li>
</ol></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>ml</tag>
      </tags>
  </entry>
  <entry>
    <title>ML:Evaluating Hypotheses</title>
    <url>/2019/01/16/CS/Machine%20Learning/ML-EvaluatingHypo/</url>
    <content><![CDATA[<h2 id="error">1 Error</h2>
<p>There are two types of error:</p>
<ul>
<li><em>true error</em>: <span class="math inline">\(\operatorname { error } _{ \mathcal { D } } ( h ) \equiv \operatorname { Pr }_ { x \in \mathcal { D } } [ f ( x ) \neq h ( x ) ]\)</span>
<ul>
<li><span class="math inline">\(D\)</span> for distribution</li>
</ul></li>
<li><em>sample error</em>: <span class="math inline">\(error_s( h ) \equiv \frac { 1 } { n } \sum_ { x \in S } \delta ( f ( x ) \neq h ( x ) )\)</span>
<ul>
<li><span class="math inline">\(\delta ( f ( x ) \neq h ( x ) )=1\)</span> if <span class="math inline">\(f ( x ) \neq h ( x )\)</span></li>
</ul></li>
</ul>
<p>How well dose <em>sample error</em> <strong>estimate</strong> <em>true error</em>？</p>
<p>We can check</p>
<ul>
<li>Bias</li>
<li>Variance</li>
</ul>
<h2 id="estimators">2 Estimators</h2>
<ol type="1">
<li>Choose sample <span class="math inline">\(S\)</span> of size <span class="math inline">\(n\)</span> according to <span class="math inline">\(D\)</span></li>
<li>measure <span class="math inline">\(error_s(h)\)</span></li>
<li><span class="math inline">\(\to\)</span> <em>sample error</em> is an <strong>unbiased estimator</strong> for <em>true error</em></li>
</ol>
<p>e.g. with approximately <span class="math inline">\(95\%\)</span> probability, <em>true error</em> lie in <span class="math display">\[
\operatorname { error } _{ S } ( h ) \pm 1.96\sqrt \frac { \text { errors } ( h ) \left( 1 - e r r o r_ { S } ( h ) \right) } { n }
\]</span></p>
]]></content>
      <categories>
        <category>CS</category>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>ml</tag>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>ML:Reinforcement Learning</title>
    <url>/2019/04/15/CS/Machine%20Learning/ML-Reinforcement/</url>
    <content><![CDATA[<h2 id="introduction">1 Introduction</h2>
<p><em><a href="http://spinningup.openai.com">Spinning Up</a></em> brought by OpenAI is a good resource for learning reinforcement learning.</p>
<p>The goal of Spinning up is to ensure AI is <strong>safe</strong> developed and help people to learn Deep RL which has a pretty high barrier to entry</p>
<blockquote>
<p>In a nutshell, RL is the study of agents and how they learn by trial and error. It formalizes the idea that rewarding or punishing an agent for its behavior makes it more likely to repeat or forego that behavior in the future.</p>
</blockquote>
<a id="more"></a>
<p>Learning Types：</p>
<ul>
<li>supervised：given x and y, find <span class="math inline">\(f()\)</span></li>
<li>unsupervised：given x, find <span class="math inline">\(cluster\)</span></li>
<li>reinforcement：given x and z, find decision <span class="math inline">\(f()\)</span> to generate y
<ul>
<li>difference from supervised learning: <strong>delayed</strong> reward that is your movement will affect later world. about <strong>time</strong> and <strong>sequence</strong></li>
</ul></li>
</ul>
<p>Markov decision process (MDP) :</p>
<ul>
<li>states: things described the world</li>
<li>actions: things you can do</li>
<li>model: rules, physics of the world</li>
<li>reward: a scaler value to value the <em>state</em></li>
<li><strong>policy</strong>: what we want to learn, <span class="math inline">\(\pi^{\star}(state)\to action\)</span> ,the action can maximize the cumulative reward.
<ul>
<li>when moving in the grid map, agent should avoid <span class="math inline">\(-negative\)</span> reward and get <span class="math inline">\(+positive\)</span> reward</li>
<li>You need to set the reward carefully<br />
</li>
<li>Even if you are in the same state, your action will be different for different <strong>step(time)</strong> you can take later. E.g. if you have only 3 steps to go, you may take action <strong>risky</strong>, <span class="math inline">\(\pi^{\star}(state,time)\to action\)</span></li>
</ul></li>
</ul>
<h2 id="key-concepts">2 Key Concepts</h2>
<h3 id="what-can-rl-do">2.1 What can RL do</h3>
<ul>
<li>Teach computers to control robots in simulation and real world</li>
<li>Create breakthrough AI for sophisticated strategy games (Go/Dota)</li>
<li>…</li>
</ul>
<h3 id="terminology">2.2 Terminology</h3>
<p>Main loop of RL:</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/reinforcement-learning.png" alt="reinforcement-learning" /><figcaption aria-hidden="true">reinforcement-learning</figcaption>
</figure>
<ul>
<li><p>state <span class="math inline">\(s\)</span> : <strong>complete</strong> description of the state of the world</p>
<ul>
<li>represented by a vector, matrix or tensor</li>
<li>Grid map e.g. <span class="math inline">\(4\times3\)</span></li>
</ul></li>
<li><p>observation <span class="math inline">\(o\)</span> : <strong>partial</strong> description of a state</p>
<ul>
<li>represented by a vector, matrix or tensor</li>
</ul></li>
<li><p>Action space: The set of all valid actions</p>
<ul>
<li>Discrete action space: Go and Atari</li>
<li>Continuous action space: Control a robot</li>
</ul></li>
<li><p>Policies: rule used by an agent to decide what actions to <strong>take</strong></p>
<ul>
<li>deterministic <span class="math inline">\(a_{t}=\mu\left(s_{t}\right)\)</span></li>
<li>stochastic <span class="math inline">\(a_{t} \sim \pi\left(\cdot | s_{t}\right)\)</span> : sampling action <span class="math inline">\(+\)</span> computing <span class="math inline">\(\log \pi_{\theta}(a | s)\)</span> , <em>which means your action may not be execute <span class="math inline">\(100\%\)</span></em> that is <strong>uncertainty</strong>
<ul>
<li>Catergorical policies: <strong>discrete</strong>, jsut like a <strong>classifier</strong>, output are probabilities vector</li>
<li>diagonal Gaussian policies: continuous</li>
</ul></li>
<li>The policy is trying to maximize reward</li>
</ul></li>
<li><p>Trajectories: <span class="math inline">\(\ \)</span> <span class="math inline">\(\tau\)</span> is a <strong>sequence of states and actions</strong> in the world</p>
<ul>
<li><span class="math inline">\(\tau=\left(s_{0}, a_{0}, s_{1}, a_{1}, \dots\right)\)</span></li>
</ul></li>
<li><p>Reward and Return: depends on the current state, the action just taken, and the next state of the world</p>
<ul>
<li><span class="math inline">\(r_{t}=R\left(s_{t}, a_{t}, s_{t+1}\right)\)</span> but ususally simplified to <span class="math inline">\(r_{t}=R\left(s_{t}\right)\)</span></li>
<li>goal of the agent is to maximize cumulative reward over trajectory <span class="math inline">\(R(\tau)=\sum_{t=0}^{T} r_{t}\)</span></li>
<li>if the time is infinite, we should add a <strong>factor</strong> to the cumulative reward or it will go <span class="math inline">\(\infty\)</span> , so we should <span class="math inline">\(R(\tau)=\sum_{t=0}^{\infty} \gamma^{t} r_{t}\)</span></li>
</ul></li>
<li><p>The RL Problem: select a policy which maximized <strong>expected return</strong></p></li>
<li><p>Value Funciton: know the value of a state</p>
<ol type="1">
<li><p><strong>On-Policy Value Function</strong> <span class="math inline">\(V^{\pi}(s)\)</span></p></li>
<li><p><strong>On-Policy Action-Value Function</strong> <span class="math inline">\(Q^{\pi}(s, a)\)</span></p></li>
</ol>
<p>start with random action</p>
<ol start="3" type="1">
<li><p><strong>Optimal Value Function</strong> $V^{*}(s) $</p></li>
<li><p><strong>Optimal Action-Value Function</strong> <span class="math inline">\(Q^{*}(s, a)\)</span></p></li>
</ol></li>
<li><p>Bellman Equations</p>
<ul>
<li><blockquote>
<p>basic idea: The value of your starting point is the reward you expect to get from being there, plus the value of wherever you land next.</p>
</blockquote></li>
<li><p><span class="math inline">\(V^{*}(s)=\max _{\pi} \underset{\tau \sim \pi}{\mathrm{E}}\left[R(\tau) | s_{0}=s\right]\)</span></p>
<p><span class="math inline">\(n\)</span> equations and <span class="math inline">\(n\)</span> unknown</p></li>
</ul></li>
</ul>
<h2 id="kinds-of-rl-algorithms">3 Kinds of RL Algorithms</h2>
<h3 id="taxonomy">3.1 Taxonomy</h3>
<p><img src="rl_algorithms_9_15.svg" /></p>
<p>Model-Based RL:</p>
<ul>
<li>Upside: allows the agent to plan by thinking ahead. Example: AlphaZero</li>
<li>Downside: the given model is different from the real enviroment the agent works.</li>
</ul>
<p>Model-Free RL:</p>
<ul>
<li>Upside: easier to implement and tune, more popular</li>
</ul>
<h3 id="what-to-learn">3.2 What to Learn</h3>
<h4 id="model-free-rl">3.2.1 Model-Free RL</h4>
<ul>
<li><p>Policy Optimization: On policy</p>
<ul>
<li>A2C / A3C, gradient ascent</li>
<li>PPO, updates indirectly</li>
</ul></li>
<li><p>Q-Learning: Off policy</p>
<p>learn an approximator <span class="math inline">\(Q_{\theta}(s, a)\)</span> for the optiaml action-value function.</p>
<ul>
<li>DQN</li>
<li>C51</li>
</ul></li>
<li><p>Trade-offs:</p>
<ul>
<li>Policy: these kind of algorithm optimize for the thing we want directly.</li>
<li>Q-Learning’s result is unstable, which means it may be better sometimes but maybe worse other times.</li>
</ul></li>
</ul>
<h4 id="model-based-rl">3.2.2 Model-Based RL</h4>
<ul>
<li>Pure Planning: compute a new plan each time, execute the first action and discards the rest of it.</li>
<li>Expert Iteration: updated version of Pure-Planning</li>
<li>Data Augmentation for Model-Free Methods</li>
<li>…</li>
</ul>
<h2 id="policy-optimization">4 Policy Optimization</h2>
<h3 id="deriving-some-math">4.1 Deriving some Math</h3>
<p>Here we consider the case of stochastic, parameterized policy.</p>
<p><strong>Aim</strong>: maximize the expected return <span class="math inline">\(J\left(\pi_{\theta}\right)=\underset{\tau \sim \pi_{\theta}}{E}[R(\tau)]\)</span></p>
<p><strong>How</strong>: optimize by gradient ascent: <span class="math inline">\(\theta_{k+1}=\theta_{k}+\alpha \nabla_{\theta} J\left.\left(\pi_{\theta}\right)\right|_{\theta_{k}}\)</span> ,which means we need an expression for the policy.</p>
<p><strong>Program</strong>:</p>
<ol type="1">
<li>Making the policy network
<ol type="1">
<li>make core policy network</li>
<li>make action selection</li>
</ol></li>
<li>Making the Loss Function</li>
<li>Running one Epoch of Training</li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>ml</tag>
        <tag>rl</tag>
      </tags>
  </entry>
  <entry>
    <title>ML:Transfer Learning</title>
    <url>/2019/04/15/CS/Machine%20Learning/ML-Transfer/</url>
    <content><![CDATA[<h2 id="what-is-transfer-learning">1 What is Transfer Learning</h2>
<blockquote>
<p>Transfer learning is a machine learning technique where a model trained on one task is re-purposed on a second related task.</p>
</blockquote>
<p>For example, if I already have a fine trained model for detecting dog and cat, and now I want to train a model can detect different kinds of dogs, I don’t need to train the model from scratch. Just use the pre-trained model and train the last few layers’ neural.</p>
<a id="more"></a>
<h2 id="how-to-use-transfer-learning">2 How to use Transfer Learning</h2>
<p>Two common approaches:</p>
<ul>
<li>Develop Model : If you have <strong>large dataset</strong> on a similar problem and willing to train the model <strong>yourself</strong>.</li>
<li>Pre-trained Model : If you don’t have enough data to train your model so you can download some <strong>pre-trained model</strong> released by some <strong>research institutions</strong>.</li>
</ul>
<h2 id="when-to-use-transfer-learning">3 When to use Transfer Learning</h2>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/transfer-learning.png" alt="transfer-learning" /><figcaption aria-hidden="true">transfer-learning</figcaption>
</figure>
]]></content>
      <categories>
        <category>CS</category>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>ml</tag>
      </tags>
  </entry>
  <entry>
    <title>RL:tabular Q-learning</title>
    <url>/2019/04/27/CS/Machine%20Learning/RL-QLearning/</url>
    <content><![CDATA[<h2 id="introduction">1 Introduction</h2>
<p>Q-Learning: method based on Q value</p>
<ul>
<li>Every <em>action</em> in a specific <em>state</em> will have a Q value <span class="math inline">\(Q(s,a)\)</span></li>
<li>For example, if someone in state <span class="math inline">\(s_1\)</span> have 2 optional action <span class="math inline">\(a_1\)</span> and <span class="math inline">\(a_2\)</span>, and <span class="math inline">\(Q(s_1,a_1)&gt;Q(s_1,a_2)\)</span>, then this agent will do <span class="math inline">\(a_1\)</span> rather than <span class="math inline">\(a_2\)</span></li>
</ul>
<a id="more"></a>
<p>Main idea:</p>
<ol type="1">
<li>Start with a bad Q-table that will guide our action</li>
<li>Do action based on Q-table</li>
<li>Calculate <strong>estimated Q-value</strong> before action and <strong>real Q-value</strong> after action</li>
<li>Update the Q-table based the error between esti-Q-val and real-Q-val, make the Q-table better for action</li>
</ol>
<h2 id="simple-game">2 Simple Game</h2>
<h3 id="q-table">Q-table</h3>
<p>index matches states, columns matches actions</p>
<p>start with 0</p>
<h3 id="choose-action">Choose action</h3>
<p><code>epsilon</code>: e.g. <span class="math inline">\(epsilon=0.9\)</span></p>
<ul>
<li>90% time choose the best action based on Q-table</li>
<li>10% time choose random action to explore the world</li>
</ul>
<h3 id="environment-feedback">Environment Feedback</h3>
<p>AKA <em>reward</em></p>
<p>e.g. Only when the agent reach the <em>goal point</em>, it will get reward <span class="math inline">\(1\)</span>, else the reward is <span class="math inline">\(0\)</span>.</p>
<p>And <em>agent’s state</em> and <em>environment</em> update can also be done in this module.</p>
<h3 id="main-loop">Main loop</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">initialize the Q-table</span><br><span class="line">Repeat (for each episode):</span><br><span class="line"> initialze the state</span><br><span class="line"> while not is_end:</span><br><span class="line">  action&#x3D;choose_action(state,q-table)</span><br><span class="line">  new_state,reward&#x3D;env_feedback(state,action)</span><br><span class="line">  q_estimate&#x3D;q-table[S][A] #estimate Q value by Q-table</span><br><span class="line">  if end:  # if reach the goal</span><br><span class="line">   q_real&#x3D;reward #real Q value</span><br><span class="line">   is_end&#x3D;true</span><br><span class="line">  else:</span><br><span class="line">   q_real&#x3D;reward+Gamma*q-table[n_state].max()</span><br><span class="line">  update_q_table(q_real,q_estimate)</span><br><span class="line">  update_env(S,A)</span><br><span class="line">  state&#x3D;new_state</span><br></pre></td></tr></table></figure>
<h2 id="hyper-parameter">3 Hyper Parameter</h2>
<p>We update our Q-table by <span class="math display">\[
Q(s, a) \leftarrow Q(s, a)+\alpha\left[r+\gamma \max _{a^{\prime}} Q\left(s^{\prime}, a^{\prime}\right)-Q(s, a)\right]
\]</span> There are 2 hyper parameter we can tune:</p>
<ul>
<li><span class="math inline">\(\alpha\)</span> : learning rate, how much error we should learn. This value should be smaller than 1</li>
<li><span class="math inline">\(\gamma\)</span> : reduction value
<ul>
<li>if <span class="math inline">\(\gamma=1\)</span>, the future can be totally estimated. So agent will calculate long term reward add up.</li>
<li>if <span class="math inline">\(\gamma=0\)</span>, the future can <strong>not</strong> be estimated at all, so the agent will only value the next step’s reward.</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>ml</tag>
        <tag>rl</tag>
      </tags>
  </entry>
  <entry>
    <title>读书感想:Nilsson人工智能</title>
    <url>/2020/04/22/CS/Machine%20Learning/ai-nilsson-note/</url>
    <content><![CDATA[<p>今天下午抽空翻阅了Nilsson的人工智能教材--<em>Artificial Intelligence--A New Synthesis</em>. 写一写自己的感受</p>
<p>这本书是Nilsson于1998年写的, 书的主要内容就是到那个时间点为止的人工智能的研究方向, 文章中随处可见的引用以及大量的参考内容让我感觉这更像是一篇带有教材性质的Review.</p>
<p>从大的方面来说, 人工智能领域有三个学派</p>
<ul>
<li>符号主义</li>
<li>连接主义</li>
<li>行为主义</li>
</ul>
<p>Nilsson显然是符号主义的支持者(代表人物). 书的前一半介绍了连接主义的神经网络, 后一半就主要是介绍知识的表示和推理.</p>
<p>对我来说, 前一半的知识是比较熟悉的, 毕竟这几年借着算力的提升, 神经网络的方法也是火的一塌糊涂, 所以平时接触的也比较多, 所以前一半看起来并不费力, 看起来也很快. 不得不说社会热点对知识的普及作用比我想象中的要强很多, 20年前最领先的(部分)知识到今天几乎都变成了领域内入门的知识, 可能随便找一个本科生也能对这些知识讲得头头是道. 可能这和学科也有关系, 各个基础科学的知识显然就普及的少很多, 我们大部分人掌握的都是几百年前的物理. 而计算机科学虽然也叫科学, 但本质上还是偏向于工程多一些.</p>
<p>后一半是关于知识和推理的, 其实我对人工智能最早的理解可能就是关于知识和推理, 当时看钢铁侠的时候, 那个能够根据指令和互联网来做出响应的贾维斯实在是太酷了. 但是上了大学之后好像就被带偏了, 默认把神经网络, 没有深入了解其他方面的人工智能, 有点后悔. 因为只是粗略地翻阅了一下, 所以没有特别的感悟, 总体上和我想象的差不多, 将知识存储起来, 通过逻辑的方式进行推理. 我觉得难点也很显而易见, 知识太多且除了人工录入外似乎没有简单的方法收集合理表达的知识.</p>
<hr />
<p>突然想起来要吐槽一下这本书的翻译, 不知道是因为这本书年代的原因还是两位浙大老师的翻译水平问题, 读的过程非常难受, 经常有的句子读不通, 有的专有名词和现在的名称不一样. 如果要仔细阅读应该直接阅读英文原文</p>
]]></content>
      <tags>
        <tag>ai</tag>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT EECS 导论课 1</title>
    <url>/2020/03/17/CS/Miscellaneous/EECS-1/</url>
    <content><![CDATA[<h1 id="导论">导论</h1>
<h2 id="学习目标">1 学习目标</h2>
<p>MIT EECS的导论课, 以Robotics为切入点进行普及性的教育, 课程主要分为四个专题</p>
<ul>
<li>软件工程</li>
<li>信号与系统</li>
<li>电子电路</li>
<li>概率与规划</li>
</ul>
<p>整个课程的目的是让学生能够appreciate工程中的抽象和设计, 能够理解数学模型的重要性, 并利用建模来解决问题, 并给学生一些实验课程来体验四个专题中的内容</p>
<a id="more"></a>
<blockquote>
<p>我觉得对于刚入学的本科生来说这一门非常好的课程, 让学生了解到专业中真正重要的东西和所要解决问题的本质, 可能任何一个工科的学生都可以学习一下. 我大一时没有意识去主动接触这些优秀的, 真正为学生着想的公开课, 真是非常可惜. 虽然其中一些能力也在实践或者课程中慢慢学到了, 但我相信一个优秀的导论课程会让整个大学时期都少点迷茫, 多点实践.</p>
</blockquote>
<h2 id="模块化-抽象与建模">2 模块化, 抽象与建模</h2>
<p>为什么要抽象和模块化? 这在数学</p>
<ol type="1">
<li>因为要处理的东西很复杂</li>
<li>人处理复杂性的能力较弱</li>
<li>分而治之</li>
</ol>
<p>想象一个例子: 要造一个轮式机器人, 运动到离灯泡一定距离时停止移动. 这其中就会用到光敏电阻来检测到灯泡的距离, 但是课中不会介绍光敏电阻背后的物理原理, 这其实就是一种抽象了. 在抽象和模块化的过程中, 我们要考虑一些其他的问题</p>
<h3 id="抽象层级">抽象层级</h3>
<p>作为工程师, 很重要的一个工作是将一系列所拥有的组件进行标准化然后进行构建系统. 标准化的好处是提高效率(作为人的理解效率和作为生产的制造效率), 标准化之后可能的<strong>设计空间</strong>就变小了. 这些能更快理解一个系统, 更好地构建一个系统. 层级越高, 设计越简单, 但是设计空间也就越小</p>
<h3 id="模型">模型</h3>
<p>建模的最困难之处在于要决定对哪些属性建模, 忽略哪些属性.</p>
<p>另一个难点在于确定模型是否是确定性的, 还是要把模型设成概率型的.</p>
<p>模型大致可以分为以下几种</p>
<ul>
<li><p>分析模型: 已经给定了一个系统, 我们要做的就是分析这个系统, 计算理论上的结果</p></li>
<li><p>合成模型: 描述输入输出, 让计算机在可能的空间中搜寻这个系统</p></li>
<li><p><strong>内部模型(internal model): 内部有个模型, 也会根据外部环境来更新内部的环境. 类似于SLAM</strong></p>
<blockquote>
<p>对于机器人来说, 我觉得第三种应该是最重要的, 因为机器人所在的环境是真实地比较多变的, 机器人的大部分工作都是在处理不定性的问题, 所以</p>
</blockquote></li>
</ul>
<h2 id="嵌入式编程系统">3 嵌入式编程系统</h2>
<p>不同的模型与抽象适合不同的任务, 这里主要介绍的是与外部环境交互的软件系统的不同策略</p>
<p>主要的交互就是3步</p>
<ol type="1">
<li>感知环境</li>
<li><strong>计算所要做的工作</strong></li>
<li>做出改变</li>
</ol>
<h3 id="驱动方式">驱动方式</h3>
<p>主要存在以下几种驱动方式</p>
<ul>
<li>序列化的, 步骤都已经事先定义好了</li>
<li>事件驱动, 利用回调函数来完成工作</li>
</ul>
]]></content>
      <tags>
        <tag>cs</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT EECS 导论课 2</title>
    <url>/2020/03/17/CS/Miscellaneous/EECS-2/</url>
    <content><![CDATA[<h1 id="软件工程">软件工程</h1>
<p>首先介绍了一下基本的Python编程, 然后着重介绍了抽象和模块化的重要性, 并且以移动机器人为例具体介绍了<strong>过程, 数据结构, 对象, 状态机</strong></p>
<blockquote>
<p>我一开始学习的编程语言就是C语言, 一个非常简单又非常难写的语言, 语法简单好学, 可能一个下午语法就学完了. 但是过于简单导致编程过程中经常花很多时间用在学习一些和程序本身没有关系的知识上(计算机系统), 我觉得实在是得不偿失</p>
</blockquote>
<p>首先介绍了基础的<strong>PCAP框架</strong>, Primitives, Combination, Abstraction, Patterns. 恰好Python可以方便地实现这个框架</p>
<p>这个基本的框架是我们们在考虑建模时要经常考虑的问题, <strong>它可以帮助我们设计有用的模型</strong></p>
<a id="more"></a>
<h2 id="程序和数据low-level">1 程序和数据(Low Level)</h2>
<p>介绍了一个程序中的基本结构</p>
<ul>
<li>数据
<ul>
<li>基本数据</li>
<li>数据结构, 变量更像是一个指针</li>
</ul></li>
<li>过程
<ul>
<li>语句的组合, 可以看成是一个函数</li>
<li>通过定义函数达到抽象的目的</li>
</ul></li>
<li>对象: 面向对象编程
<ul>
<li>对象和实例</li>
<li>继承</li>
</ul></li>
<li>递归: 确保每次调用时, 工作量会变小. 递归程序分成两部分, <strong>在解释器上用到了递归的思想</strong>
<ul>
<li>基本情况</li>
<li>递归情况</li>
</ul></li>
</ul>
<blockquote>
<p>虽然用的是Python, 但是其中仍然有指针的概念, 一样能将计算机系统介绍的很清楚, 甚至在本章的后半部分还带学生实现了一个简单的解释器, 既兼顾到了广度(程序设计的基本设计模式), 又实现了深度(解释器的设计), 我觉得光这一节课就顶的上我所上过的<em>C程序设计+面向对象+计算机基础+自学的解释器</em>, 效果也更加好</p>
</blockquote>
<h3 id="助教课-函数式编程">助教课: 函数式编程</h3>
<p>在python中, 函数也是一等公民, 也就是可以作为参数或者被return.</p>
<p>所以虽然总体上Python是一个面向对象的语言, 但是我们也可以写成<strong>函数式</strong>的程序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span>(<span class="params">x</span>):</span> <span class="comment">#定义了一个平方函数</span></span><br><span class="line">    <span class="keyword">return</span> x*x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selfComposition</span>(<span class="params">someFunction</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">returnFunction</span>(<span class="params">*args</span>):</span></span><br><span class="line">        <span class="keyword">return</span> someFunction(someFunction(*args))</span><br><span class="line">    <span class="keyword">return</span> returnFunction <span class="comment">#返回的参数是一个函数</span></span><br><span class="line"></span><br><span class="line">f=selfComposition(square)</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">f=selfComposition(<span class="keyword">lambda</span>: x x*x)</span><br><span class="line">f(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 16</span></span><br></pre></td></tr></table></figure>
<p>Lamdas: 定义一个没有名字的函数, 非常简洁</p>
<p>非常好用的用处是操控一些数列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">map(<span class="keyword">lambda</span> x:x*<span class="number">2</span>,demolist)</span><br></pre></td></tr></table></figure>
<p>也可以用于list comprehension</p>
<blockquote>
<p>助教课我觉得是一种很好的学习方式, 因为作为同龄人, 他们更能理解学生的学习方式, 也可以介绍一些比较前沿的内容, 不适合在课上讲的内容.</p>
</blockquote>
<h2 id="状态机high-level">2 状态机(High Level)</h2>
<p>介绍了状态机的定义: 一种建模方法, 其输出取决于其输入的整个历史, 它表示了<strong>控制过程</strong>, 它的表示方式简洁, 能从程序的循环中脱离, 是模块化的</p>
<p>虽然现实生活是连续的, 但是在计算机系统中, 控制策略都是<strong>高度非线性和离散</strong>的. 我们可以把嵌入式系统或者机器人系统看成一个处理<strong>输入值流</strong>(Input Stream)到输出值流的转换, 所以时间越长, <strong>过程就越复杂</strong>. 为了解决这个问题, 我们需要<strong>捕捉历史的基本属性</strong></p>
<p>状态机有以下几个基本属性: <strong>状态集合, 输入集合, 输出集合, next-state方程, ouput方程, 初值</strong>. 如果状态是有限的, 那就是有限状态机</p>
<p>一般来说, 状态机也可以分成三种, 对应着与环境交互的三种模式</p>
<ul>
<li>综合型 由目标决定
<ul>
<li>输入: 传感器读到的外部环境</li>
<li>输出: 控制指令</li>
</ul></li>
<li>解析型 由系统决定
<ul>
<li>输入: 控制指令</li>
<li>输出: 系统的一些简单度量, 比如是否会收敛到稳定</li>
</ul></li>
<li>预测型 由系统和环境决定 (SLAM)
<ul>
<li>输入: 控制指令</li>
<li>外部环境的状态</li>
</ul></li>
</ul>
<p>当然复杂的状态机也是由许多简单的状态机构成的</p>
<h3 id="primitive">Primitive</h3>
<p>定义一个Abstract Class, SM(State Machine), 其他所有状态机都继承于这个类.</p>
<p>对于每一个状态机来说, 都需要指定</p>
<ul>
<li><p>初值 startState</p></li>
<li><p>获取输出 getNextValue, 输入是这一时刻状态和输入, 输出是下一时刻的状态和输出</p>
<p>这个函数<strong>不会改变状态机的状态</strong>, 为什么要这样设计? 虽然有很多种设计方式, 但是实践表明这种<strong>没有副作用</strong>的函数是非常有用的</p></li>
</ul>
<p>例子: 要做一个加法器Accumulator的状态机</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Accumulator</span>(<span class="params">SM</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,initialValue</span>):</span> <span class="comment">#定义初值, 每个SM都一样</span></span><br><span class="line">        self.startState=initialValue</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span>(<span class="params">self</span>):</span> <span class="comment">#状态机的开始, 每个SM都一样</span></span><br><span class="line">        self.state=self.startState</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">step</span>(<span class="params">self,input</span>):</span> <span class="comment">#更新状态</span></span><br><span class="line">        (s,output)=self.getNextValue(self.state,input)</span><br><span class="line">        self.state=s</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transduce</span>(<span class="params">self,input_stream</span>):</span> <span class="comment">#处理流数据</span></span><br><span class="line">        self.start()</span><br><span class="line">        <span class="keyword">return</span> [self.step(input) <span class="keyword">for</span> input <span class="keyword">in</span> input_stream]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getNextValue</span>(<span class="params">self,state,input</span>):</span><span class="comment">#输入是这一时刻状态和输入</span></span><br><span class="line">        <span class="keyword">return</span> (state+input,state+input)<span class="comment">#输出是下一时刻的状态和输出, 这里状态和输出是一样的</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h3 id="combination">Combination</h3>
<p>在上一节构建了基础的状态机之后, 我们可以组合起来变成更加复杂的状态机</p>
<p>基础的组合方式包括: 级联, 并联, 负反馈</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用Python实现负反馈的关键: 存在未定义的时刻, ignore掉</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getNextValues</span>(<span class="params">self,state,inp</span>):</span></span><br><span class="line">    (ignore,o)=self.m.getNextValues(state,’undefined’</span><br><span class="line"> (newS,ignore)=self.m.getNextValues(state,o)</span><br><span class="line">   <span class="keyword">return</span>(newS,o)</span><br></pre></td></tr></table></figure>
<p>终止状态机(TSM)也是一种非常有用的状态机, 比如扫地机器人先扫A房间, 再扫B房间, 这就是终止了某一个状态机开启了另一个状态机</p>
<h3 id="control-robot-using-state-machine">Control Robot Using State Machine</h3>
<p>抽象出输入(传感器), 输出(执行器), 然后再对行为建模做成一个状态机, 写成代码. 机器人所做的事情就是</p>
<ol type="1">
<li>读取传感器输入</li>
<li>将输入喂给状态机
<ol type="1">
<li>前进状态机</li>
<li>旋转状态机</li>
<li>坐标系状态机</li>
</ol></li>
<li>执行输出</li>
</ol>
<h2 id="总结">3 总结</h2>
<p>对于大部分系统, 我们都可以找到一个PCAP系统来描述它, 如果没有, 就发明一个. 通过这种方式, 我们可以将一个复杂的问题变得更加简单, 容易解决</p>
<p>e.g. 以SLAM为例</p>
<p>主要就是三个状态机</p>
<ol type="1">
<li>地图构建状态机
<ul>
<li>读取传感器</li>
<li>输出地图</li>
</ul></li>
<li>路径规划状态机
<ul>
<li>读取地图和传感器</li>
<li>输出路径</li>
</ul></li>
<li>执行器状态机
<ul>
<li>读取路径和传感器</li>
<li>输出指令</li>
</ul></li>
</ol>
]]></content>
      <tags>
        <tag>cs</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT EECS 导论课 3</title>
    <url>/2020/03/19/CS/Miscellaneous/EECS-3/</url>
    <content><![CDATA[<h1 id="信号与系统">信号与系统</h1>
<p>上一章主要的目的就是如何构建<strong>复杂</strong>系统, 主要是和编程有关, 已经是抽象过一次了, 不需要了解物理层面的问题. 这种状态机的方式有一个问题就是有时候系统太过于复杂, 以至于我们必须要实际运行系统然后再看看实际发生了什么</p>
<p>这一章, 主要介绍的是如何对物理系统建模和控制, 也就是比上一级更加low-level的内容, LTI, 通过一个模型, 将一些输出<span class="math inline">\(x(t)\)</span>转化成输出<span class="math inline">\(y(t)\)</span>, 因为系统是离散的, 所以我们可以用差分方程或者方块图来表示这个系统, 然后教授通过一个简单的例子说明了为什么差分方程可以变成简单的代数形式(因为比如一个右移<strong>算符Operator</strong>就可以表示差分), 这让学生在直观上了解了差分方程表示法的优点(容易转换成简单的计算相比于差分方程, 表达又很简介相比于方块图).</p>
<p>如果有反馈的话, 会出现算符作为分母的形式, 我们可以用无穷级数来表示, 比如 <span class="math display">\[
\frac{1}{1+2R}=1-2R+4R^2-8R^3 \cdots
\]</span> 这也解释了为什么有反馈的滤波器是无线脉冲响应的(IIR)</p>
<a id="more"></a>
<blockquote>
<p>现在我能明白这是Top-Down的教学或者学习方式, 我最早接触这种学习方式是在学习计算机网络时使用的教科书: "计算机网络: 自顶向下的方法", 当时读的时候就觉得非常舒服, 很自然, 先知道目的, 然后逐渐了解一些底层的实现细节. 对我来说这是更加高效的方式(相比于Bottom-Up). 先学电子电路, 物理, 直到大二下才有机器人导论, 到玉泉再学机器人的设计与实践, 在这样的学习过程中我有很长一段时间不知道自己学的东西有什么用, 只是单纯的从理论到实践的过程.</p>
<p>老师的水平和授课质量就不说了, 差距太大, 对知识的理解完全不在一个层次上.</p>
</blockquote>
<h2 id="基础知识">1 基础知识</h2>
<p>LTI, 前馈, 反馈之类的</p>
<h3 id="助教课-lti动机与表示">助教课 LTI动机与表示</h3>
<p>主要应用在控制系统中, 是为了通过建模预测系统之后的输出</p>
<h2 id="预测系统行为">2 预测系统行为</h2>
<p>假设我们已经知道了系统的代数方程表示, 我们要如何预测系统的输出?</p>
<ul>
<li>单位冲击响应s</li>
<li>通过系统的<strong>极点(Poles)</strong>来了解</li>
</ul>
<p>先研究一阶的, 比较简单, <span class="math inline">\(\frac{1}{1-p_0R}\)</span>, 如果<span class="math inline">\(P_0&lt;1\)</span>收敛, 否则就发散</p>
<h3 id="二阶系统">二阶系统</h3>
<p>再研究二阶的, 稍微复杂一点, 可以看成是<strong>两个一阶的级联</strong>或者<strong>两个一阶的累加(拆分)</strong></p>
<p>为了方便因式分解, 令<span class="math inline">\(R=\frac{1}{z}\)</span>, 这样可以方便找出方程的极点, 设未知数求解也可以</p>
<ul>
<li><p>如果都是实根, 比较简单, 和1比大小就行</p></li>
<li><p>如果有复根, 将其表示为指数形式(为什么要这样呢?因为这样的表示在做幂的时候比较简洁), 那么复根会怎么影响输出呢? 主要看幅值最大</p>
<blockquote>
<p>类似于之前反馈时提到的无穷级数, 对于复数也可以这样操作 <span class="math display">\[
\frac{1}{1-\operatorname{re}^{j \Omega} R }=1+ r e^{j \Omega} R +r^{2} e^{j 2 \Omega} R ^{2}+\cdots
\]</span></p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/20200319175342.png" alt="image-20200319020038344" style="zoom: 80%;" /></p>
<p>因为现实生活中的模型都是<strong>实参数</strong>的, 因此<strong>复根都是共轭</strong>的, 所以分母乘起来复数就消失了</p>
</blockquote></li>
</ul>
<p>二阶系统有两个复根时可以表示成这样 <span class="math display">\[
\frac{Y}{X}=\frac{\frac{1}{2}(1-j \cot \Omega)}{1-r e^{j Q} R }+\frac{\frac{1}{2}(1+j \cot \Omega)}{1-r e^{-j \Omega} R }
\]</span></p>
<p><span class="math display">\[
y[n]=r^{n}(\cos n \Omega+\cot \Omega \sin n \Omega)
\]</span></p>
<p>利用 <span class="math display">\[
-\sqrt{1+\cot ^{2} \Omega} \leqslant \cos n \Omega+\cot \Omega \sin n \Omega \leqslant \sqrt{1+\cot ^{2} \Omega}
\]</span> 得到了 <span class="math display">\[
-\frac{1}{\sin \Omega} r^{n} \leqslant y[n] \leqslant \frac{1}{\sin \Omega} r^{n}
\]</span> 可以看出,<span class="math inline">\(\Omega\)</span>和<span class="math inline">\(r\)</span>影响了系统的响应</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/20200319175422.png" alt="image-20200319021647812" /><figcaption aria-hidden="true">image-20200319021647812</figcaption>
</figure>
<p>其中<span class="math inline">\(r\)</span>代表了红色和绿色的线, 也就是收敛的速度,</p>
<p>而<span class="math inline">\(\Omega\)</span>表示了振荡的速度</p>
<h3 id="特殊情况">特殊情况</h3>
<ul>
<li>零点极点消除, 一般来说不能消除(<em>不是很理解</em>)</li>
<li>重复极点</li>
<li>可叠加</li>
</ul>
<h2 id="设计实例-反馈控制">3 设计实例 反馈控制</h2>
<p>让一个小车检测到墙壁的距离并在停在一定距离, 使用<strong>比例控制</strong></p>
<h3 id="不考虑延迟">3.1 不考虑延迟</h3>
<p>理论上传感器获取数据是有延迟的, 从传达指令到实际速度执行也是有延迟的. 这里暂时不考虑</p>
<ol type="1">
<li><p>先列差分方程 <span class="math display">\[
v[n]=k(d_i[n]-d_0[n])\\
d_0[n]=d_0[n-1]-Tv[n-1]\\
d_s[n]=d_0[n-1]
\]</span> 注意到这个差分方程其实包含了许多个方程(近似3n)和很多个未知数, 不便于处理和计算, 转成算符方程, 方程式就少了很多</p></li>
<li><p>转成代数形式 <span class="math display">\[
V=k(D_i-D_0) \\
D_0=RD_0-TRV\\
D_0=\frac{-TKR}{1-(1+TK)R}D_i
\]</span></p></li>
<li><p>看根的情况</p>
<p>一个根是<span class="math inline">\(1+TK\)</span>, 为了让系统能够收敛, <span class="math inline">\(|1+TK|&lt;1\)</span>.</p>
<p>现在假设<span class="math inline">\(T=0.1\)</span>, 显然<span class="math inline">\(K=-10\)</span>是最好的, 一步收敛</p></li>
</ol>
<h4 id="考虑延迟">3.2 考虑延迟</h4>
<ol type="1">
<li><p>先列差分方程 <span class="math display">\[
v[n]=k(d_i[n]-d_0[n-1])\\
d_0[n]=d_0[n-1]-Tv[n-1]
\]</span></p></li>
<li><p>转成代数形式 <span class="math display">\[
V=k(D_i-RD_0) \\
D_0=RD_0-TRV\\
D_0=\frac{-TKR}{1-R-TkR^2}D_i
\]</span></p></li>
<li><p>看根的情况</p>
<p>两个个根是<span class="math inline">\(\frac{1}{2} \pm \frac{1}{2} \sqrt{1+4 k T}\)</span>,</p></li>
</ol>
]]></content>
      <tags>
        <tag>cs</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT EECS 导论课 4</title>
    <url>/2020/03/19/CS/Miscellaneous/EECS-4/</url>
    <content><![CDATA[<h1 id="电子电路">电子电路</h1>
<p>前面2个内容分别介绍了抽象和模块的能力以及如何对信号系统建模, 这一章将更加基本, 涉及到底层的电路(还不是最底层), 并且也会用到模块化的思想来简化设计</p>
<h2 id="背景知识">1 背景知识</h2>
<p>电流, 电压, 怎么根据回路列方程</p>
<h2 id="运算放大器">2 运算放大器</h2>
<h3 id="动机">动机</h3>
<p>电路的设计是复杂的, 因为你随便加一个原件就会影响整个电路的电压或者电流</p>
<p>通过引入运放作为<strong>Buffer</strong>, 元素之间的影响(interaction)被减小甚至消除了</p>
<p>可以把运放看成是<strong>由电压控制的电压源</strong> <span class="math inline">\(V_o=K(V_+-V_-)\)</span></p>
<ul>
<li>理想的运放, <span class="math inline">\(k\to \infin\)</span> , <span class="math inline">\(V_+=V_-\)</span></li>
<li>感受两端的差距, 通过正反馈不断放大</li>
<li>给<span class="math inline">\(V_+\)</span>的负反馈是不稳定的</li>
</ul>
<h2 id="抽象电路">3 抽象电路</h2>
<p>戴维南定理: 通过计算开路电压和短路电流, 一个电路中两个变量的关系可以用平面上的直线表示, 这意味着我们可以用其他的元件来完成同样的功能</p>
<ul>
<li>有一个复杂的电路, 计算开路电压, 短路电路, 画出他的直线图, 找到和坐标轴的交点以及直线的斜率</li>
<li>用简单的电路实现</li>
</ul>
<p>为啥要这么想呢? 因为我们想要知道电路的每个部分是如何<strong>交互</strong>的, 简化计算(当我们改变这个端口的负载时), 简化思维负担(概念)</p>
<p>叠加性: 因为系统是线性的, 所以在电路有多个电压源, 我们可以一个一个源地计算, 计算的时候另其他源都为0</p>
]]></content>
      <tags>
        <tag>cs</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT EECS 导论课 5</title>
    <url>/2020/03/19/CS/Miscellaneous/EECS-5/</url>
    <content><![CDATA[<h1 id="决策和搜索">决策和搜索</h1>
<p>上一章主要讲的是<strong>建图, 定位</strong>,利用贝叶斯理论. 介绍了基本的概率论, 状态估计, 如何根据<strong>观察</strong>和原有的状态来<strong>更新状态</strong>.</p>
<p>这一章, 注重于介绍<strong>搜索策略</strong>, 就是已经有了建图和定位之后怎么找到一条适合的路线</p>
<h2 id="概率部分">1 概率部分</h2>
<p>介绍了基本的概率论</p>
<h3 id="状态估计">1.1 状态估计</h3>
<p>当我们有许多概率分布时, 我们依然使用PCAP的方法来控制复杂性</p>
<ul>
<li>Primitive 基本的概率分布: Delta<br />
</li>
<li>Combination: 利用条件概率叠加</li>
</ul>
<h3 id="随机状态机">1.2 随机状态机</h3>
<p>通过贝叶斯理论来更新状态机, 这在机器人学中花了很多时间来学习</p>
<h2 id="搜索部分">2 搜索部分</h2>
<h3 id="状态空间搜索">2.1 状态空间搜索</h3>
<p>我们所要做的就是</p>
<ul>
<li>定义<strong>状态集合</strong></li>
<li>确定<strong>起始状态</strong>和期望的<strong>目标状态</strong></li>
<li>一张地图, 或者说各个状态之间是如何连接在一起的, 以及如何从一个状态到另一个状态</li>
</ul>
<h4 id="python实现-一棵有很多点的树">Python实现: 一棵有很多点的树</h4>
<p>我们定义一个类来表示节点, 这个类需要有以下属性</p>
<ul>
<li>这个节点的状态state</li>
<li>用来到达这个节点所采取的action</li>
<li>这个节点可以到达的子节点</li>
</ul>
<p>搜索算法:</p>
<ul>
<li><p>输入是问题的描述(起点, 终点)</p></li>
<li><p>输出是所要求取的路径</p></li>
<li><p>具体的算法有不同的策略, 基本的有<strong>深度优先</strong>和<strong>广度优先</strong></p>
<blockquote>
<p>在上程序设计专题时, 我们选的设计目标是一个泡泡堂游戏. 其中一个功能就是路径搜寻, 那要怎么找到这个路我当时几乎没有任何相关的背景知识, 自己研究了一个礼拜终于想出了深度优先的算法. 在想出来之后觉得很简单, 但是在一开始探索时简直是不知所措, 当时也不会一些研究方法, 花了很多时间做了很多尝试. 也就是从那个时候我逐渐将编程理解成一种翻译, 将其他语言(逻辑)成翻译计算机能够理解的语言. 如果当时直接老师告诉我的话, 大概不会有那么深刻的印象</p>
</blockquote></li>
</ul>
<p>下面这个是一个比较通用的框架, 通过在这个框架上增添一些功能, 我们就可以实现深度优先</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">initialState,goalTest,actions,successor</span>):</span></span><br><span class="line">    <span class="keyword">if</span> goalTest(initialState):</span><br><span class="line">        <span class="keyword">return</span> [(<span class="literal">None</span>,initialState)]</span><br><span class="line">    agenda=EmptyAgenda()</span><br><span class="line">    add(SearchNode(<span class="literal">None</span>,initialState,<span class="literal">None</span>),agenda)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> empty(agenda):</span><br><span class="line">        parent=getElement(agenda)</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> actions(parent.state):</span><br><span class="line">            newS=successor(parent.state,a)</span><br><span class="line">            newN=SearchNode(a,newS,parent)</span><br><span class="line">            <span class="keyword">if</span> goalTest(News):</span><br><span class="line">                <span class="keyword">return</span> newN.path()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                add(newN,agendas)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>简本的剪枝: 可以避免一些愚蠢的情况, 比如在两个点之间不断来回. 那么我们可以设置规则: 一条路径不走回头路</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> parent.inPath(NewS):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>深度优先: 每次都优先不断进入子节点, 直到到达末端点还没有到期望的终点, 再往回在向下</p>
<p>广度优先: 每次都先便利同一层上的节点, 没有遇到期望的终点就继续向下</p>
<p><strong>动态规划</strong>: 可以用来计算<strong>最短路径</strong>. 记录所到达过的状态, 如果遇到新的状态, 就根据已有的距离和新的距离来更新, 列表中同样的节点只能出现一次</p>
<ul>
<li>基于的原理: X到Z的最短路径=X到Y的最短路径+Y到Z的最短路径</li>
<li>动态规划还能大大减少所要遍历的路径</li>
</ul>
<h3 id="数值搜索领域">2.2 数值搜索领域</h3>
<p>如何通过数值来求解最优解. 比如在微积分中, 我们可以通过求导来梯度下降找到最优解</p>
<p>在优化的过程中, 我们还要考虑计算的复杂性, 时间复杂性, 空间复杂性. 使用动态规划可以大大降低复杂性</p>
<h3 id="启发式搜索">2.3 启发式搜索</h3>
]]></content>
      <tags>
        <tag>cs</tag>
      </tags>
  </entry>
  <entry>
    <title>依据基本原理构建线代计算机--硬件部分</title>
    <url>/2019/08/14/CS/Miscellaneous/build-cs-hardware/</url>
    <content><![CDATA[<h2 id="introduction">0 Introduction</h2>
<p>从与非门到俄罗斯方块的建立，课程分为两个独立的部分，硬件和软件</p>
<p>这门课专注于硬件部分</p>
<h3 id="background">Background</h3>
<p>最简单的Hello World背后也隐藏着很多神奇的事。比如你写一句printf，最后就在显示器上显示出了内容</p>
<p>当然这也是计算机科学中最重要的抽象过程，你不需要知道how，你只需要知道what，只需要关注高一层的逻辑就能实现你想要的功能。</p>
<ul>
<li>这样的抽象是多层次的，从最简单的电子元器件到CPU到计算机到编程语言</li>
</ul>
<p>之后的的课程，每一次都</p>
<ul>
<li>只考虑单一一层的抽象</li>
<li>把低一层的接口作为已知</li>
<li>实现高一层的接口</li>
<li>测试我们的接口是能正常使用的</li>
</ul>
<a id="more"></a>
<h3 id="this-course">This Course</h3>
<p>构建一个Hack计算机，能够沟通ROM,CPU和RAM</p>
<p>学习的方式：从下到上，从EE到CS</p>
<ul>
<li><p>怎么建立一个芯片：使用模拟器仿真</p>
<p>设计：知道了一个芯片的抽象功能，然后设计硬件图，然后转化为硬件描述语言，最后用在仿真软件里看效果</p></li>
</ul>
<h3 id="next-course">Next Course</h3>
<p>之前的课程中已经建立了可以运行汇编语言的电脑，在下一节课中，我们会建立更加高级的编程语言，并且建立相应的编译器、基础系统库</p>
<h2 id="boolean-functions-and-gate-logic">1 Boolean Functions and Gate Logic</h2>
<h3 id="boolean-functions">Boolean Functions</h3>
<p>我们可以对布尔值进行的操作</p>
<ul>
<li>AND</li>
<li>OR</li>
<li>NOT</li>
</ul>
<p>根据一些等价转换可以转换逻辑函数，起到化简的作用</p>
<p>显然我们可以根据布尔表达式求解真值表，那么如何从<strong>真值表到布尔函数</strong>？</p>
<ul>
<li><p>将所有最终值为1的行表达为一个简单表达式（这个表达式只在那一行的值为1，其他行为0），然后将这些简单表达式用<strong>or</strong>连接起来</p></li>
<li><p>如何找最简的表达式？NP-Hard问题</p></li>
<li><p>任意表达式都可以用AND</p>
<ul>
<li><p>进阶：任意表达式都可以用AND</p>
<p>证明：<span class="math inline">\((\mathrm{x} \mathrm{OR} \mathrm{y})=\mathrm{NOT}(\mathrm{NOT}(\mathrm{x}) \mathrm{AND} \mathrm{NOT}(\mathrm{y}))\)</span></p></li>
<li><p><strong>进进阶：任意表达式都可以用NAND组成的表达式表示</strong></p>
<p>这是因为：<span class="math inline">\((\mathrm{x} \mathrm{NAND} \mathrm{y})=\mathrm{NOT}(\mathrm{x} \mathrm{AND} \mathrm{y})\)</span></p>
<p>证明：AND和NOT都可以用NAND表示 <span class="math display">\[
\begin{array}{l}{\text { 1) } \operatorname{NOT}(x)=(x \text { NAND } x)} \\ {\text { 2) }(x A N D y)=\operatorname{NOT}(x \text { NAND } y)}\end{array}
\]</span></p></li>
</ul></li>
</ul>
<h3 id="logic-gates">Logic Gates</h3>
<p>基础逻辑门：NAND、AND、OR、NOT</p>
<p>复合逻辑门：三个输入的AND</p>
<ul>
<li>也是一种抽象，每种门的表达是一样的，但是实现可以不同（EE做的事）</li>
</ul>
<h3 id="hardware-description-language">Hardware Description Language</h3>
<p>HDL只是一种描述语言，还需要一个模拟器来将所描述的结构运行起来</p>
<ul>
<li>所以描述的顺序是没有关系的，但是推荐从左到右，调高程序的可读性</li>
<li>有许多不同的HDL
<ul>
<li>VHDL</li>
<li>Verilog</li>
<li>课程使用的HDL，最简化，简单</li>
</ul></li>
</ul>
<p>输入输出都是由外部给定的变量名</p>
<p>假设：我们已经有了基本的AND</p>
<p>设计步骤：</p>
<ol type="1">
<li>写出基本的逻辑表达式</li>
<li>画成电路图（也是由AND）</li>
<li>写成HDL程序</li>
<li>用模拟器测试HDL是否正确</li>
</ol>
<blockquote>
<p>在一个实际的项目中，芯片的设计是怎么样的呢？</p>
<ol type="1">
<li>项目中有设计师和工程师</li>
<li>设计师知道要实现的具体功能
<ol type="1">
<li>决定要设计哪些小的芯片</li>
<li>对于每个小芯片，确定<strong>名字API、测试脚本、比较文件</strong></li>
</ol></li>
<li>让工程师根据以上内容，建立芯片</li>
</ol>
</blockquote>
<blockquote>
<p>Multi-Bit Buses</p>
<p>我们需要对一排bit进行操作，所以，使用数组进行描述</p>
</blockquote>
<h3 id="project-1">Project 1</h3>
<p>我们要实现的是一共<strong>15个</strong>门电路</p>
<p>除了常见的AND，还有</p>
<ul>
<li><p>MUX</p>
<p>这两个可以作用于通信领域，将不同的信息通过通过单一的数据线进行传输</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/nand-mux-demux.png" /></p></li>
</ul>
<p>实现过程：</p>
<ol type="1">
<li>先用NAND实现AND</li>
<li>然后用AND</li>
</ol>
<h2 id="boolean-arithmetic-and-alu">2 Boolean Arithmetic and ALU</h2>
<h3 id="binary-numbers">Binary Numbers</h3>
<p>我们可以用01来表示数，不管是二进制还是十进制</p>
<p>对于二进制数的操作，虽然看上去有很多，包括加减乘除比大小。但是其实我们只要能够实现<strong>加法</strong>，其他的一些操作都能够简单的实现</p>
<ul>
<li><p>减法和比大小显然能够轻松达成</p></li>
<li><p>乘法和除法<strong>不会有硬件上的实现</strong>，而是通过软件模拟</p>
<p>这是为了<strong>简单</strong>起见，如果要构建这样的硬件，需要很多的设计花费，这也是一个trade-off</p></li>
<li><p><strong>溢出问题</strong></p>
<p>因为加法的两个数字长是固定的，所以如果两者相加溢出了，比如8位变成了9位。那么计算机会<strong>直接忽略溢出的那个数</strong>，这是需要使用计算机的人记住的，那就是<strong>相加的结果可能不正确</strong>，如果不使用正确的长度</p></li>
</ul>
<p>如何操作负数呢？</p>
<ul>
<li><del>用最左边的那一位表示符号</del>
<ul>
<li>这样的实现不优雅，比如会有-0的情况，而且还要分类讨论</li>
</ul></li>
<li>用<span class="math inline">\(2^n-x\)</span>代表<span class="math inline">\(-x\)</span>
<ul>
<li>正的范围<span class="math inline">\(0...{2^{n-1}-1}\)</span></li>
<li>负的范围<span class="math inline">\(-1...-2^{n-1}\)</span></li>
</ul></li>
<li><strong>加法</strong>就只需要按这个逻辑，效果是一样的</li>
<li><strong>减法</strong>可以用<span class="math inline">\(2^{n}-x=1+\left(2^{n}-1\right)-x\)</span>，这样因为<span class="math inline">\(2^n-1\)</span>都是111111，所以不需要进位
<ul>
<li>这就是<strong>补码的背后思路</strong>：取反+1</li>
</ul></li>
</ul>
<h3 id="alu">ALU</h3>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/n2t-alu.png" /></p>
<p>ALU接受两个输入和一个函数<span class="math inline">\(f\)</span>，输出值</p>
<ul>
<li><span class="math inline">\(f\)</span>是一堆已经事先定义好的函数中的一个</li>
<li>确定<span class="math inline">\(f\)</span>的集合大小是一个典型的trade-off的问题</li>
</ul>
<p>在这门课中的ALU，称为Hack ALU，ALU实现的<span class="math inline">\(f\)</span>的集合是<strong>18个</strong>函数</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/n2t-hack-alu.png" /></p>
<p>其中比较重要的就是上面的6个控制值，他们进行了一些预处理</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/n2t-alu-6-options.png" /></p>
<p>下面的两个zr、ng是两个寄存器，说明一些输出的性质</p>
<ul>
<li>zr说明了out是否为0</li>
<li>ng说明了out是否为负数</li>
</ul>
<blockquote>
<p>设计的芯片的<strong>效率问题</strong>：总的来说基本上没有什么可以优化的，因为都是最简单的实现，没有优化的余地。</p>
<p>但是对于加法器ADDER，因为要计算进位，所以计算的位数越多，<strong>延时</strong>也就越多</p>
<p>解决方法：Carry Look-Ahead Adder</p>
<p>解决思路：</p>
<ul>
<li>延时有<strong>线延时</strong>和<strong>门延时</strong>，我们<strong>主要关注门延时</strong></li>
<li>改变结构，使得全加器的进入输入不来自上一级的全加器，而是<strong>超前进位</strong>
<ul>
<li>优点：使得延迟时间减小，固定为3级门延迟</li>
<li>缺点：如果拓宽加法器的位数，电路非常复杂</li>
</ul></li>
</ul>
</blockquote>
<h3 id="project-2">Project 2</h3>
<p>给定：在Project 1中已经实现的所有芯片</p>
<p>目标：构建以下新的芯片</p>
<ul>
<li>半加器：XOR+AND</li>
<li>全加器：</li>
<li>ALU</li>
<li>…</li>
</ul>
<h2 id="memory">3 Memory</h2>
<blockquote>
<p>Cache memory: RAM is very expensive, so there are trade-offs in the situation</p>
<ul>
<li>Use large and cheap RAM with low quality</li>
<li>Use small and expensive RAM with good quality</li>
</ul>
</blockquote>
<p>从这一部分开始，会涉及到时间，其中会有一些问题包括</p>
<ul>
<li>重复使用相同的硬件</li>
<li>记住系统的状态</li>
<li>协调速度</li>
</ul>
<h3 id="clock">Clock</h3>
<p>在一个时钟周期内，系统的状态是一样的</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/n2t-clock.png" /></p>
<p>当然在物理层面，系统状态的变化不会是瞬间的，就如图中所示灰色的部分一样</p>
<ul>
<li>在设计时，这部分不需要考虑，因为我们只看最后平稳的那一部分</li>
<li>实际上，时钟的频率就是根据这段变化的时间来确定的，只要间隔比灰色时间长一点就好</li>
</ul>
<p><strong>时序逻辑</strong>：下一时刻的输出由上一时刻的输入决定</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/n2t-seq-logic.png" /></p>
<h3 id="data-flip-flop">Data Flip Flop</h3>
<p>我们需要一个电路（1-Bit），能够记住一个状态</p>
<ul>
<li><p>这个电路（1-Bit）能够永远记住一个状态，除非来了新的数据</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/n2t-flip-flip.png" /></p></li>
<li><p>内部结构（Data Flip Flop+Mux）</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/n2t-mem-dff.png" /></p></li>
</ul>
<p>DFF和1Bit的区别：DFF是瞬时的，而1Bit的状态可以延续</p>
<blockquote>
<p>DFF的电路实现</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/n2t-dff-ee.png" /></p>
</blockquote>
<h3 id="memory-units">Memory Units</h3>
<p>基本电路就是上一节提到的（1-Bit）电路，通过把许多的（1-Bit）电路顺序地连接在一起，就变成了一个<strong>寄存器</strong>，寄存器的长度w，可以是16、32、64</p>
<p><strong>RAM unit</strong></p>
<ul>
<li>就是一堆有地址的寄存器叠加起来</li>
<li>在任意时刻，只有1个寄存器被选择——被读或被写</li>
<li>地址的长度<span class="math inline">\(\log_2{n}\)</span></li>
</ul>
<p>在这节课中，会建立一些不同长度、大小的RAM</p>
<h3 id="counters">Counters</h3>
<p>计数器的作用：递增地址，使得程序能够顺序执行</p>
<p>所以需要的功能有</p>
<ul>
<li>Reset，PC=0</li>
<li>Next，PC++</li>
<li>Goto，PC=n</li>
</ul>
<p>计数器在硬件上抽象地实现了上述功能</p>
<h3 id="project-3">Project 3</h3>
<p>给定：Project 2中所实现的所有芯片</p>
<p>目标：构建以下芯片</p>
<ul>
<li><p>Bit</p></li>
<li><p>寄存器</p></li>
<li><p>RAM(各种大小)都是16位</p>
<ul>
<li><p>先建立RAM8，然后拼成RAM64，再用RAM64拼成RAM512</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/n2t-ram-hire.png" /></p></li>
<li><p>在Address部分，可以使用一部分作为那一个RAM的选择，还有一部分地址作为RAM内部寄存器的选择</p></li>
</ul></li>
<li><p>PC</p>
<ul>
<li>好几个MUX选择</li>
</ul></li>
</ul>
<h2 id="machine-language">4 Machine Language</h2>
<h3 id="overview">Overview</h3>
<p>How is it possible that we can do all different things with a single hardware</p>
<ul>
<li>theory from Turing: one machine can simulate all other machine</li>
<li>practice from Von Neumann: architect</li>
</ul>
<p>3 Most important elements for every ML:</p>
<ol type="1">
<li><strong>Operation</strong>s: what to do with this instruction</li>
<li><strong>Program Counter</strong>: what to do next</li>
<li><strong>Addresing</strong>: what to operate (where the data is)</li>
</ol>
<blockquote>
<p>e.g. assembly language</p>
<p>a instruction 010001000110010</p>
<p>in fact it can be view as 3 part: <code>0100010</code> <code>0011</code> <code>0010</code> ADD R3 R2</p>
</blockquote>
<h3 id="elements">Elements</h3>
<p>Machine language is the interface beteween hardware and software</p>
<h4 id="operations">Operations</h4>
<ul>
<li>Arithmetic: add, subtract</li>
<li>Logical: and, or</li>
<li>Flow control: goto, if</li>
</ul>
<p><strong>Differences</strong> between machine languages:</p>
<ul>
<li>richness of the set of operations</li>
<li>data types</li>
</ul>
<h4 id="addressing">Addressing</h4>
<p>Accessing a memory location is expensive</p>
<p>Solution: Memory Hierarchy</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/n2t-mem-hier.png" /></p>
<ul>
<li><strong>Registers’ number and functions are a center part of the machine language</strong></li>
</ul>
<p>这部分基本都是微机原理所涉及的内容</p>
<h3 id="hack-computer">Hack Computer</h3>
<p>课程所要设计的电脑</p>
<ul>
<li>硬件部分
<ul>
<li>16位计算机，意味着RAM里有一堆寄存器，每个寄存器都是16位的，CPU也都能处理16位的数据指令</li>
<li>由3部分组成，ROM</li>
</ul></li>
<li>软件部分
<ul>
<li>16位的指令。A instruction and D instruction</li>
</ul></li>
</ul>
]]></content>
      <tags>
        <tag>cs</tag>
      </tags>
  </entry>
  <entry>
    <title>$\lambda$演算</title>
    <url>/2020/05/01/CS/Miscellaneous/lambda-calculus/</url>
    <content><![CDATA[<h2 id="介绍">0 介绍</h2>
<p>图灵机可以解决计算所有的问题. 有些问题无法通过计算解决.</p>
<p>对于人工智能来说, 可计算性是一个非常重要的议题, 值得学习与思考</p>
<p><span class="math inline">\(\lambda\)</span>运算 是与图灵机类似的一种工具, 听说比图灵机更加简洁. 因此学习并记录</p>
<h2 id="历史">1 历史</h2>
<p>发明者: Alonzo Church. 美国逻辑学家</p>
<p>发明初衷: 给逻辑学提供一个基础, 代替罗素的类型理论和策梅洛的集合理论</p>
<p>作用: 系统中的<span class="math inline">\(\lambda\)</span>演算具有良好的性质, 可以等价地定义出<strong>可计算函数</strong>. 用<span class="math inline">\(\lambda\)</span>演算证明了判定性问题不可答, 比<a href="https://www.youtube.com/watch?v=7TycxwFmdB0&amp;list=PL8dPuuaLjXtNlUrzyH5r6jN9ulIgZBpdo&amp;index=16">图灵证明停机问题不可判</a>更早</p>
<p>发展: 计算机出现后, 有研究者发现<span class="math inline">\(\lambda\)</span>演算可以看成是一种程序设计语言(如Lisp). 因为它既可以描述计算过程, 也可以看成一个数学对象, 用于推导证明命题</p>
<h2 id="解释">2 解释</h2>
<p>所有的操作就是</p>
<ol type="1">
<li>读取一行符号或字符</li>
<li>剪切和粘贴</li>
</ol>
<p>这样的过程定义了所有的可计算过程, 也就是说只要是能计算表示的都可以用它来表示</p>
<p>Input: 一个<strong>表达式</strong>, 长得像<span class="math inline">\((\lambda x.xy)(ab)\)</span></p>
<ul>
<li>单个的字母,像<span class="math inline">\(a\ b\ c\)</span>等, 被称为<strong>变量</strong>, 可以写在一起
<ul>
<li>变量没有实际意义或者值, 就像是函数中的形参</li>
</ul></li>
<li>括号<span class="math inline">\((\ )\)</span>, 用来表示其中的表达式是一起的</li>
<li><span class="math inline">\(\lambda\)</span>, 用它和<span class="math inline">\(.\)</span> 我们用来表示一个<strong>函数</strong>, 表示函数的开始. 也成为<strong>head</strong></li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/20200508011805.png" alt="image-20200503160104175" /><figcaption aria-hidden="true">image-20200503160104175</figcaption>
</figure>
<h3 id="剪切和粘贴">剪切和粘贴</h3>
<p>如果一个函数后面跟着一个表达式, 那么我们可以解析这些函数</p>
<p>解析的方式：获取头部中提到的变量, 将其在正文中出现的所有内容替换为函数后面的表达式</p>
<p>所以说函数就是告诉我们要在哪里替换变量</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/20200508011811.png" alt="image-20200503161012145" /><figcaption aria-hidden="true">image-20200503161012145</figcaption>
</figure>
<h2 id="例子数字">3 例子:数字</h2>
<p>数字是我们最常计算的东西.</p>
<h3 id="所有的自然数">3.1 所有的自然数</h3>
<p>我们首先来定义所有的自然数, 方法是: 定义0,然后定义递增的操作 <span class="math display">\[
0: \Leftrightarrow \lambda \ sz .z
\]</span> 类似的, 我们定义</p>
<ul>
<li>这种定义看起来确实非常奇怪, 但是从数学角度上来说是和我们用<span class="math inline">\(1,2,3...\)</span>或者<strong>一二三四五</strong>没什么区别的,都是用符号来表示一个数. 和人类的名字一样, 我们只是用其来表示这个人, 就算换一个名字, 这个人还是这个人</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
&amp;\begin{array}{l}
1=\lambda \text { sz.s }( z ) \\
2=\lambda sz . s ( s ( z ))
\end{array}\\
&amp;3=\lambda \operatorname{sz} \cdot s(s(s(z)))\\
&amp;4=\lambda \operatorname{sz.s}( s ( s ( s ( z ))))
\end{aligned}
\]</span> 我们也可以说, 我们在<span class="math inline">\(z\)</span>上应用<span class="math inline">\(s\)</span>这个操作n次</p>
<p>一个有趣的递增函数可以是</p>
<p><span class="math display">\[
S: \leftrightarrow \ \lambda \ abc.b(abc)
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
S 0 &amp;=(\lambda abc \cdot b ( abc ))(\lambda s z \cdot z ) \\
&amp;=\lambda bc \cdot b ((\lambda s z \cdot z ) bc ) \\
&amp;=\lambda bc \cdot b ((\lambda z \cdot z ) c ) \\
&amp;=\lambda bc \cdot b ( c )
\end{aligned}
\]</span></p>
<p>根绝我们的定义, 这就是<span class="math inline">\(1\)</span></p>
<h3 id="算数">3.2 算数</h3>
<p>加法可以非常自然地用到我们上面所用的定义, 比如说<span class="math inline">\(1+2\)</span>, 就是在<span class="math inline">\(1\)</span>上做两次递增操作, 可以表达成<span class="math inline">\(1S2\)</span> <span class="math display">\[
1+2=3S5
\]</span> 乘法我们需要新的定义, <span class="math inline">\(\lambda \ abc.a(bc)\)</span></p>
<ul>
<li>通过验算可以证明其正确性</li>
</ul>
<p>减法是和加法相对的, 虽然说我们知道了加法的定义, 与之相对的就是减法的定义. 但是这个只是说明性的描述. 我们实际需要的是如何定义这个减法计算</p>
<p>...后续还有很多操作可以定义, 比如说逻辑, 条件</p>
]]></content>
      <tags>
        <tag>cs</tag>
        <tag>lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>Newline Characters</title>
    <url>/2019/07/30/CS/Miscellaneous/newline/</url>
    <content><![CDATA[<h2 id="difference">Difference</h2>
<p><code>'\n'</code> writes a newline in UNIX</p>
<p><code>'\r\n'</code>writes a newline in Windows</p>
<p>Why Windows use extra <code>‘\r’</code> to do this job?</p>
<a id="more"></a>
<h2 id="eol">EOL</h2>
<p>Newline, also called <code>line ending</code>, <code>end of line</code>, <code>line break</code> is a control character in a specify <strong>encoding</strong> system.</p>
<p>This control character tell the text editor how to display the text.</p>
<p>In <strong>ASCII</strong></p>
<ul>
<li>CR: Carriage Return <code>\r</code></li>
<li>LF: Linefeed <code>\n</code></li>
<li>CRLF: Carriage Return &amp; Linefeed <code>\r\n</code></li>
</ul>
<p>Windows use CRLF to be backward compatible with MS-DOS for historical reason</p>
<h2 id="conclusion">Conclusion</h2>
<p>To use plain text in multiple platform, try to use <code>\n</code></p>
]]></content>
      <tags>
        <tag>tips</tag>
        <tag>cs</tag>
      </tags>
  </entry>
  <entry>
    <title>Regular Expressions</title>
    <url>/2019/07/30/CS/Miscellaneous/regexp/</url>
    <content><![CDATA[<h2 id="overview">Overview</h2>
<p>Regular expressions are useful in <strong>text</strong> processing fields to <strong>extract information</strong>.</p>
<p>The main idea: writting <strong>patterns</strong> to <strong>match</strong> a specific sequence of characters</p>
<h2 id="quick-start">Quick Start</h2>
<ul>
<li><p>Letters</p>
<p><code>a</code> matches <em>a</em></p>
<p><code>ab</code> matches <em>ab</em></p>
<p><code>[abc]</code> matches only <em>a / b / c</em> (1 character)</p>
<a id="more"></a>
<p><code>[^abc]</code> matches only 1 character **except a</p>
<p><code>[a-z]</code> matches only 1 character <em>from a to z</em></p></li>
<li><p>Digits</p>
<p><code>123</code> matches <em>123</em></p>
<p><code>\d</code> matches <em>any digit</em></p>
<p><code>\D</code> matches any <em>Non-digit</em></p></li>
<li><p>Wild Card</p>
<p><code>.</code> matches <em>any character</em></p>
<p><code>\.</code> matches <em>.</em></p>
<p><code>\w</code> matches <em>any Alphanumeric</em> (alphabet + number) character</p>
<ul>
<li>equals to <code>[A-Za-z0-9_]</code></li>
</ul>
<p><code>\W</code> matches <em>any non-alphanumeric</em> character</p></li>
<li><p>Repetitions</p>
<p><code>a&#123;3&#125;</code> matches <em>aaa</em></p>
<p><code>a&#123;1,3&#125;</code> matches <em>a / aa / aaa</em></p>
<p><code>a*</code> matches <em>0 or more</em> repetition of a</p>
<p><code>a+</code> matches <em>1 or more</em> repetition of a</p>
<p><code>a?</code> a is optional in this case, so matches <em>0 / 1</em> repetition of a</p></li>
<li><p>Whitespace</p>
<p>There are many common forms of <strong>whitespace</strong></p>
<ul>
<li>space</li>
<li>tab</li>
<li>new line</li>
<li>carriage return</li>
</ul>
<p>These can be matched by <code>\s</code>, so <code>\s</code> is extremely useful when dealing with raw input text</p></li>
<li><p><code>^...$</code></p>
<p>Defines what should be matched in a <strong>line</strong>‘s begining and end</p></li>
<li><p>Group</p>
<p>Use <code>( )</code> to <strong>extract information</strong> for further processing</p>
<p>e.g. <code>^(IMG\d+)\.png$</code> will match .png file but will only capture files’ <em>name</em></p>
<ul>
<li><p>Nested Group</p>
<p>Use nested <code>( )</code> to extract multiple layes of information</p></li>
</ul></li>
</ul>
<h2 id="ref">Ref</h2>
<p><a href="https://regexone.com/">RegexOne</a></p>
]]></content>
      <tags>
        <tag>tips</tag>
        <tag>cs</tag>
      </tags>
  </entry>
  <entry>
    <title>Adaptive Control of Discrete-Time Systems Using Multiple Models</title>
    <url>/2019/08/07/CS/Paper/Adaptive%20Control%20of%20Discrete-Time%20Systems%20Using%20Multiple%20Models/</url>
    <content><![CDATA[<h2 id="abstract">Abstract</h2>
<p>Using <strong>multiple models</strong> to control a linear time-invariant discrete-time system</p>
<p>Giving proof of global <strong>stability</strong> of the overall system</p>
<h2 id="introduction">Introduction</h2>
<h2 id="mathematical-preliminaries">Mathematical Preliminaries</h2>
<h2 id="adaptive-control">Adaptive Control</h2>
]]></content>
      <categories>
        <category>CS</category>
        <category>Paper</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes about MINDS, BRAINS, AND PROGRAMS</title>
    <url>/2019/07/21/CS/Paper/MindBrainProgram/</url>
    <content><![CDATA[<h2 id="background">Background</h2>
<p>Researchers in AI fields often suggest our human’s mental activity can be just like a computer program. That may means our brain is just a</p>
<ul>
<li>information <strong>processo</strong>r like a CPU</li>
<li>has working and long-term <strong>memory</strong> like ROM</li>
</ul>
<p>That’s the <strong>Strong AI</strong>. This paper in intended to prove that Strong AI is <strong>false</strong></p>
<blockquote>
<p>The “<strong>Turing Test</strong>”: Anything capable of conducting a conversation well-enough to <strong>fool</strong> a typical human questioner (or “interlocutor”) into thinking that it is conversing with a genuine human ought to be deemed “intelligent.”</p>
</blockquote>
<p>The author of this paper, Searle@UCB gave <strong>The Chinese Room thought experiment</strong>, arguing that program can pass the <strong>Turing Test</strong> but still have no intelligence at all because the program can just follow the instruction and make it look like a human from outside.</p>
<h2 id="abstract">Abstract</h2>
<p>This article is an attempt to explore the consequences of two propositions</p>
<ol type="1">
<li><p><strong>Intentionality</strong> in human beings (and animals) is a product of <strong>causal features of the brain</strong>.</p>
<p>I assume this is an <strong>empirical fact</strong> about the actual causal relations between mental processes and brains.</p>
<p>It says simply that <strong>certain brain processes</strong> are sufficient for intentionality.</p></li>
<li><p><strong>Instantiating a computer program is never by itself a sufficient condition of intentionality.</strong></p>
<p>The <strong>main argument of this paper</strong> is directed at establishing this claim</p>
<p>The form of the argument is to show how a human agent could instantiate the program and still not have the relevant intentionality.</p></li>
</ol>
<p>So Strong AI is not about machines but about programs, and no program by itself is sufficient for thinking.</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>Paper</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title>Matplotlib</title>
    <url>/2019/03/12/CS/Python/python-matplotlib/</url>
    <content><![CDATA[<h2 id="basics">1. Basics</h2>
<ul>
<li>Figure
<ul>
<li>Axes
<ul>
<li>Axis</li>
<li>Title</li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>data</tag>
      </tags>
  </entry>
  <entry>
    <title>Basic HTML</title>
    <url>/2019/05/20/CS/Web/html/</url>
    <content><![CDATA[<h2 id="overview">Overview</h2>
<p>HTML means hyper text markup language</p>
<p>HTML的作用是定义网页的结构, 比如说哪一段是标题, 哪一段是文章内容, 哪一段是图片等, 就类似于MarkDown中定义了怎么样的是标题, 怎么样的是列表一样. 具体长什么样由CSS决定</p>
<h2 id="grammar">Grammar</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>My cat is very grumpy<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>由部分组成</p>
<ol type="1">
<li>opening tag &lt;&gt;</li>
<li>内容</li>
<li>closing tag &lt;/&gt;</li>
</ol>
<p>3部分组合起来叫做element. element可以有一些属性attribute</p>
<h2 id="a-typical-html-file">A Typical HTML File</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>My test page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/firefox-icon.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;My test image&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>html包裹了网页中所有的东西</li>
<li>head包裹了所有<strong>不给浏览者</strong>看的东西, 包括一些自定义的变量, keywords(给搜索引擎看的),标题(出现在tab上的标题)等</li>
<li>body包裹了所有<strong>给浏览者</strong>看的东西, 包括你想要展示的内容, 图片等</li>
</ul>
<h2 id="basic-element">Basic Element</h2>
<ul>
<li>&lt;hx&gt; heading, x=1~6</li>
<li>&lt;p&gt; paragraphs</li>
<li>&lt;ol&gt; &lt;ul&gt; list, ordered, unordered</li>
<li>&lt;xx style=“color:red”&gt; inline style，内联样式，简单但不易于维护</li>
<li>CSS，层叠样式表，cascading style sheets，易于维护
<ul>
<li>元素选择器，style中 h2，p：colot、font-size、font-family、border</li>
<li>类选择器 style中 .blue-text</li>
</ul></li>
<li>锚点anchor，a元素，#死链接</li>
<li>alt，图片无法加载时显示的替代文本</li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes about Dropout</title>
    <url>/2018/12/30/CS/paper/Dropout/</url>
    <content><![CDATA[<h2 id="abstract">Abstract</h2>
<p>深度神经网络有很多参数因而威力巨大。但是过大的神经网络使得过拟合成为了一个非常严重的问题。Dropout是解决这个问题的一个方法。其主要思想是在训练过程中随机舍弃一些单元，而验证这种方法效果的方式也很简单：通过和不经过Dropout，而大小与经过Dropout的模型相近的神经网络模型进行对比。通过实验，这种方法能够很好地防止过拟合，并且和目前的一些正则化方法相比有了明显的提升。</p>
<a id="more"></a>
<h2 id="introduction">Introduction</h2>
<p>深度神经网络包含了许多非线性隐藏层，这使得深度神经网络变得有很强的表达性，也就是说其可以学习输入和输出之间的复杂的关系。</p>
<p>但是当训练数据有限的时候，可能部分关系是从采样噪声学到的，这些关系在训练集中存在但在实际的测试数据中不存在。这就导致了过拟合。</p>
<p>减少过拟合的方法包括，验证集上的性能开始下降时尽快停止训练，为权重引入L1/L2正则惩罚项。</p>
<p>如果计算量上不受限制，按照bayesian的黄金准则，regularize 一个固定规模的模型的最好的方式是，在参数的所有可能的取值上做预测，再根据每种取值的后验概率对这些预测加权取平均。实际中希望用更少的计算量近似到达bayesian的性能。</p>
<p>本文提出dropout，<strong>学习指数个共享参数的模型，做预测，求几何平均</strong>。近似地有效地组合了指数多个神经网络体系结构。</p>
<p>Dropout做法，暂时地随机地移除网络中的单元（及其输入和输出连接）。比如，每个单元都以固定的概率<span class="math inline">\(p\)</span>（比如=0.5）保留。（但是输入单元的保留概率应该接近1），相当于从原网络中采样一个thinned稀疏的网络。 原网络有<span class="math inline">\(n\)</span>个单元，则有<span class="math inline">\(2^n\)</span>种可能（每个节点有移除/保留2种可能,各节点独立）的稀疏网络。</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/dropout_compare.jpg" alt="dropout_compare" /><figcaption aria-hidden="true">dropout_compare</figcaption>
</figure>
<p>在测试的时候，直接地先对每个网络做预测再平均 计算量大不可行。采用近似平均方法，将<span class="math inline">\(2^n\)</span>个网络组合成一个神经网络（所有单元都保留，但单元的输出权重都乘以该单元在训练时候的保留概率），基于这个神经网络做预测。</p>
<h2 id="motivation">Motivation</h2>
<p>Dropout的动机来自于关于性别在进化中的作用的理论。有性生殖包括从一个亲本和另一个亲本中提取一半的基因，加入非常少量的随机突变，并将它们结合产生受精卵。无性繁殖是通过父母基因的拷贝中加入微小突变来创造后代。无性繁殖应该是一种更好的方法来优化个体的健康，这似乎是合理的，因为一组良好的基因组合在一起可以直接传递给后代。另一方面，有性生殖很可能会破坏这些共同适应的基因，特别是如果这些基因的数量很大，而且直觉上，这应该会降低已经进化出复杂的共同适应的生物体的适应性。然而，有性繁殖是最先进的生物进化的方式。</p>
<p>对有性生殖优势的一种可能解释是，从长期来看，自然选择的标准可能不是个体特性，而是基因的混合能力。就是说那些能够和更多随机的基因协作的基因才是更加健壮的。因此一些基因必须要自己学会做一些事而不只是跟很多其他基因合作，这种合作会减少个体适应性。类似地，随机的选择dropout可以增加隐层神经元的健壮性。</p>
<p>有个密切相关但却略有不同的例子，十个阴谋，每个五人参与和一个大阴谋五十人参与相比，显然前者获得一次成功概率较大。一个复杂的共同协作的网络在训练集表现会很出色，但到测试集中，出现了很多新的数据，他就不如很多个更为简单的协作神经元工作的效果好。</p>
<h2 id="model-description">Model Description</h2>
<p>考虑一个有着<span class="math inline">\(L\)</span>层隐藏层的神经网络，让<span class="math inline">\(l \in \{1,....,L \}\)</span> 表示隐藏层的层数，让<span class="math inline">\(z^{(l)}\)</span> 表示输入到第<span class="math inline">\(l\)</span>c层神经网络的向量，<span class="math inline">\(y^{(l)}\)</span> 表示第<span class="math inline">\(l\)</span>层神经网络的输出，<span class="math inline">\(W^{(l)}\)</span>表示第<span class="math inline">\(l\)</span>层神经网络的权重，<span class="math inline">\(b^{(l)}\)</span>表示第<span class="math inline">\(l\)</span>层神经网络的bias <span class="math display">\[
\begin{aligned} z _ { i } ^ { ( l + 1 ) } &amp; = \mathbf { w } _ { i } ^ { ( l + 1 ) } \mathbf { y } ^ { l } + b _ { i } ^ { ( l + 1 ) } \\ y _ { i } ^ { ( l + 1 ) } &amp; = f \left( z _ { i } ^ { ( l + 1 ) } \right) \end{aligned}
\]</span> <img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/dropour-neural.png" alt="dropout-neural" /></p>
<blockquote>
<p>左图：普通神经网络。右图：dropout之后的神经网络</p>
</blockquote>
<p><span class="math display">\[
\begin{aligned} r _ { j } ^ { ( l ) } &amp; \sim \text { Bernoulli } ( p ) \\ \widetilde { \mathbf { y } } ^ { ( l ) } &amp; = \mathbf { r } ^ { ( l ) } * \mathbf { y } ^ { ( l ) } , \\ z _ { i } ^ { ( l + 1 ) } &amp; = \mathbf { w } _ { i } ^ { ( l + 1 ) } \widetilde { \mathbf { y } } ^ { l } + b _ { i } ^ { ( l + 1 ) } \\ y _ { i } ^ { ( l + 1 ) } &amp; = f \left( z _ { i } ^ { ( l + 1 ) } \right) \end{aligned}
\]</span></p>
<h2 id="conclusion">Conclusion</h2>
<p>Dropout是一种可以在神经网络中减小过拟合程度的一种方法。普通的反向传播算法只能在学习到训练集中的知识但是泛化性能不够。而随机的Dropout使得每一个隐藏层的单元都不一定会在输出中起到作用，因此能够提升神经网络在各个领域内的使用性能。</p>
<p>Dropout的一个缺点是它使得训练的时间延长了，通常来说，一个使用Dropout来训练的神经网络会比拥有相同结构的普通神经网络耗费2-3倍的时间，这主要是因为变量的更新较为缓慢，每一次更新都是几乎不相同的结构。当然有得必有失，在机器学习的领域中，要想获得一方面的进步，就要在其他方面做出让步。Dropout方法增加了算法的训练时间，降低了模型的过拟合风险。</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>Paper</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title>Why We Need Window Function</title>
    <url>/2020/03/29/Control/DSP/why-window/</url>
    <content><![CDATA[<p>在数字信号处理中，我们经常会对一段信号进行加窗的处理，为什么要这样做呢？这里采用自上而下的方式来考虑</p>
<h2 id="fft">FFT</h2>
<p>当我们要考量信号的频域特征时，我们就要做傅里叶变换。</p>
<p>FFT的对象只能是两种</p>
<ul>
<li>从负无穷到正无穷</li>
<li>有限长度的周期信号</li>
</ul>
<p>在实际中，FFT的对象肯定是<strong>有限长度</strong>的时域信号，所以会对信号进行截断。如果截断的长度不是周期的整数倍就会存在泄露，如下所示</p>
<ul>
<li><p>如果是周期性的截断，那么截断之后的信号还是保留了原来信号的信息，可以还原出来的信号</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/20200329231116.png" style="zoom:50%;" /></p></li>
<li><p>如果是非周期性截断，起始和结束时刻的赋值不等，这样就是非连续的了</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/20200329231219.png" style="zoom:50%;" /></p>
<p>对截断后的信号做频谱分析显然会导致频谱复杂，只会在正确的频率上出现一个峰值，其他地方会存在<strong>泄露</strong></p></li>
</ul>
<p>窗函数就是为了减少泄露，使得时域信号变化之后更好地满足周期性，<strong>减少泄露</strong></p>
<h2 id="窗函数">窗函数？</h2>
<p>由上一节得知，我们可以通过窗函数来减少泄露，尽量使得截断的信号能够更加真实地反应原信号的频谱</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/20200329232804.png" style="zoom:50%;" /></p>
<p>理想情况是<strong>左图</strong>，能够准确还原出原来信号的频谱信息</p>
<p>不加窗的实际情况大致如<strong>中间图</strong>，存在很多不相关的频率信息，这就是泄露</p>
<p>加了窗的实际情况大概如<strong>右图</strong>，虽然存在泄露，但大大减少了，总体能够反应原来信号的信息</p>
<p>原理：通过窗函数将非平稳信号平稳化，更加具有周期性</p>
<p>窗函数是一个有限长度的加权函数，存在不同的加权方式所以存在不同的窗函数，常见的有矩形窗，hamming窗，kaiser窗等</p>
<p>有什么用？</p>
<ul>
<li>频域分析</li>
<li>滤波器设计</li>
</ul>
]]></content>
      <tags>
        <tag>signal</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机控制系统设计与实践</title>
    <url>/2019/06/22/Control/Process%20Control/Computer-control-system/</url>
    <content><![CDATA[<h2 id="概述">1 概述</h2>
<h3 id="控制的本质">1.1 控制的本质</h3>
<p>过程控制、时序控制、运动控制都是控制，核心在于<strong>闭环反馈</strong></p>
<h3 id="课程目的">1.2 课程目的</h3>
<p>掌握控制系统<strong>组成部件设备</strong>的基本原理和特性，能够<strong>选用</strong>合适的设备部件用于构成控制系统</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/ccs-course.png" /></p>
<a id="more"></a>
<p>计算机体现在<strong>控制器</strong>的输入输出都是<strong>数字量</strong>的</p>
<p>FCS相当于DCS多一层级，把机柜下降到传感器的层级</p>
<h3 id="数字通信技术">1.3 数字通信技术</h3>
<p>基本概念</p>
<ul>
<li>信号类型
<ul>
<li>模拟，连续的物理量</li>
<li><strong>数字</strong>，不连续的物理状态</li>
</ul></li>
<li>串并传输方式
<ul>
<li>并行，以字或字节为单位传输，不宜远距离通信</li>
<li><strong>串行</strong>，逐位传输，</li>
</ul></li>
<li>交互方式
<ul>
<li>单工：单一方向</li>
<li><strong>半双工</strong>：双方可以交互，但不同时</li>
<li>全双工：双方可同时交互</li>
</ul></li>
<li>波特率</li>
<li>基带传输，数字信号的数字传输</li>
<li>频带传输，把数字信号调制成模拟信号，HART协议</li>
</ul>
<p>现场总线首选RS-485</p>
<hr />
<p><strong>传感器硬件一般自己都做了滤波</strong></p>
<p>为了防止<strong>周期性干扰</strong>（<span class="math inline">\(60Hz\)</span>）和<strong>随机干扰</strong>，可以采用滤波</p>
<p>在实际应用中，选取什么数字滤波要视具体情况而定</p>
<ul>
<li>中位值滤波法适用于偶然的脉冲干扰</li>
<li>算术平均值滤波法适用于随机干扰</li>
<li>递推平均滤波算法对周期性干扰有良好的抑制作用</li>
<li>加权递推平均滤波算法适用于大纯滞后对象和采样周期较短的系统</li>
<li>惯性滤波法适用于高频的干扰信号（但不能太大）</li>
</ul>
<h2 id="变送器检测仪表的原理与选型">2 变送器——检测仪表的原理与选型</h2>
<h3 id="基本概念">2.1 基本概念</h3>
<p>分类，单元组合仪表</p>
<ul>
<li>电动单元组合</li>
<li>气动单元组合</li>
</ul>
<p>信号制</p>
<ul>
<li>气动：<span class="math inline">\(20KPa-100KPa\)</span></li>
<li>电动：<span class="math inline">\(4-20mA\)</span></li>
<li>数字：RS-232,RS-485</li>
</ul>
<p>防爆</p>
<ol type="1">
<li>分类，煤矿井下用、工厂用</li>
<li>分级，根据最小引爆火花能量区分</li>
<li>分组，根据最高表面温度区分</li>
</ol>
<h3 id="选型">2.2 选型</h3>
<ul>
<li>量程，工作范围在仪表的<span class="math inline">\(\frac{1}{3}-\frac2{3}\)</span>之间</li>
<li>精度，满足生产要求</li>
<li>类型
<ul>
<li>材料及处理，腐蚀性、特殊参数</li>
<li>环境条件，防爆，高温低潮</li>
<li>输出信号类型</li>
</ul></li>
</ul>
<h2 id="执行器">3 执行器</h2>
<h3 id="概述-1">3.1 概述</h3>
<p>作用：接收控制信号<span class="math inline">\(\to\)</span>产生驱动力<span class="math inline">\(\to\)</span>改变控制变量</p>
<p>需要注意的问题：与介质直接接触</p>
<h3 id="执行机构">3.2 执行机构</h3>
<ul>
<li><strong>气动薄膜</strong>，输出力较小，但可以加装阀门定位器解决，<strong>应用更加广泛</strong></li>
<li>气动活塞：行程长，输出力大</li>
</ul>
<h3 id="控制系统的其他组件">3.3 控制系统的其他组件</h3>
<ul>
<li><p>安全栅</p>
<ul>
<li>作用：应用在防爆系统，将供给本质安全电路的电压和电流限制在一定安全范围内，防止非本安电路的危险能量串入本安电路</li>
<li>原理：通过二极管、电容来隔离</li>
</ul></li>
<li><p>线缆</p>
<ul>
<li><p>RVV,全称铜芯聚氯乙烯绝缘聚氯乙烯护套软电线，又称轻型聚氯乙烯护套软线,俗称软护套线.</p>
<p>规格：“平方”，在工作温度30°，长期连续90%负载下的载流</p></li>
</ul></li>
</ul>
<h2 id="控制器">4 控制器</h2>
<h3 id="概述-2">4.1 概述</h3>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/ccs-controller.png" /></p>
<h3 id="控制律">4.2 控制律</h3>
<ul>
<li>比例控制
<ul>
<li>控制块、有余差</li>
<li><span class="math inline">\(K_p\)</span>越大，比例作用越强，余差越小。但越大，系统也越容易发散</li>
</ul></li>
<li>比例积分</li>
<li>比例微分</li>
<li>比例积分微分</li>
</ul>
<h3 id="plc">4.3 PLC</h3>
<p>Programmable Logical Controller</p>
<p>开发初衷：用可编程的控制设备取代继电器控制系统</p>
<p>特点</p>
<ul>
<li>高可靠性，接口光电隔离，RC滤波器</li>
<li>模块化结构，CPU，电源，I/O都是模块化</li>
<li>组态化编程，通过组态软件编程</li>
<li>I/O口丰富</li>
</ul>
<p>工作原理</p>
<ol type="1">
<li>输入采样</li>
<li>用户程序执行</li>
<li>输出刷新</li>
</ol>
<h2 id="西门子控制器">5 西门子控制器</h2>
<h2 id="欧姆龙控制器">6 欧姆龙控制器</h2>
]]></content>
      <categories>
        <category>Control</category>
        <category>Process Control</category>
      </categories>
      <tags>
        <tag>control</tag>
        <tag>process</tag>
      </tags>
  </entry>
  <entry>
    <title>功能块图编程语言</title>
    <url>/2019/09/04/Control/Process%20Control/FBD-Language/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>功能块图编程语言也称为FBD语言,它源于信号处理领域，使用类似于数字电路中的图形逻 辑符号来表示控制逻辑，有数字电路基础的人很容易掌握。该语言具有图形符号，可图形连接，操作方便，因此被广泛采用。</p>
<p>FBD语言的一些组成部分</p>
<ul>
<li>函数</li>
<li>功能块</li>
<li>连接元素</li>
</ul>
<p>一个功能块网络能够看成一个电气电路图,电气之间的连接用于描述组件之间的信号流. 功能块的典型应用包括<strong>描述控制回路和逻辑</strong></p>
]]></content>
      <categories>
        <category>Control</category>
        <category>Process Control</category>
      </categories>
      <tags>
        <tag>control</tag>
        <tag>process</tag>
      </tags>
  </entry>
  <entry>
    <title>Process Control:Basics</title>
    <url>/2019/01/20/Control/Process%20Control/ProcessControl-basics/</url>
    <content><![CDATA[<h2 id="概论">1 概论</h2>
<p>大多数生产过程的效益取决于控制的好坏，因此控制很重要。</p>
<p>大多数过程可以分解为一些基本环节，掌握这些环节之后我们就可以进行改造、控制，并预估性能。</p>
<p><strong>总目标</strong>：对于任意外部干扰<span class="math inline">\(DV\)</span>，通过调节操作变量<span class="math inline">\(MV\)</span>，使被控变量<span class="math inline">\(CV/PV\)</span>维持在设定值<span class="math inline">\(SP\)</span></p>
<a id="more"></a>
<h2 id="过程动态特性">2 过程动态特性</h2>
<p>不同的过程动态特性不相同。</p>
<h3 id="典型动态特性机理建模">2.1 典型动态特性，机理建模</h3>
<p>自衡过程--纯滞后、单容、多容</p>
<p>非自衡--积分、指数</p>
<p>常用方程</p>
<ul>
<li>物料守恒，能量守恒</li>
</ul>
<h3 id="变送环节与控制阀特性">2.2 变送环节与控制阀特性</h3>
<p>变送环节一般可表示为一阶+纯滞后，希望滞后和时间常数尽量小</p>
<p>测量信号往往会经过处理：周期性脉动、噪声--低通滤波，线性化处理--<span class="math inline">\(\sqrt{x}\to x^2\to x\)</span></p>
<p>控制阀直接与介质接触，工作在恶劣环境下。要谨慎选择</p>
<ul>
<li>开度<span class="math inline">\(15 \% - 85 \%\)</span></li>
<li>气开、气关，主要考虑失气时使生产状态处于安全状态
<ul>
<li>进水阀气关</li>
<li>燃料阀气开</li>
</ul></li>
<li>流量特性
<ul>
<li>线性阀--常数</li>
<li>等百分比阀--先慢后快</li>
<li>快开阀--先快后慢</li>
<li>抛物线阀--先慢后快</li>
</ul></li>
<li>流量特性选择
<ul>
<li>设想开环增益不变，就不用改控制器参数</li>
<li>选择非线性阀补偿其他环节的变化，使开环增益保持不变</li>
</ul></li>
</ul>
<blockquote>
<p>e.g.</p>
<p>已知热平衡<span class="math inline">\(C_1G_1(T-T_1)=\lambda G_2\)</span></p>
<p>那么，控制通道的静态增益 <span class="math display">\[
K _ { p } = \frac { \partial T } { \partial G _ { 2 } } = \frac { \lambda } { C _ { 1 } G _ { 1 } } \propto \frac { 1 } { G _ { 1 } }
\]</span></p>
<ul>
<li>若主要扰动为<span class="math inline">\(T_1\)</span>,<span class="math inline">\(K_p\)</span>为常数，所以选择直流线性阀</li>
<li>若主要扰动为<span class="math inline">\(G_1\)</span>，所以<span class="math inline">\(K_V\)</span>要<span class="math inline">\(\boldsymbol { K } _ { \boldsymbol { V } } \propto G _ { 1 }\)</span>，所以选择等百分比阀</li>
</ul>
</blockquote>
<h3 id="广义对象经验建模法">2.3 广义对象，经验建模法</h3>
<p>广义对象：简化控制系统的分析与设计，将执行机构、被控对象、测量变送环节合起来当成广义对象</p>
<p>对象获取：一般考虑为一阶+纯滞后</p>
<ul>
<li>阶跃测试法
<ol type="1">
<li>阶跃响应：在稳态下快速改变输入量
<ul>
<li>扰动信号幅度要适宜，一般<span class="math inline">\(5\%-15\%\)</span></li>
</ul></li>
<li>计算<span class="math inline">\(K,T,\tau\)</span> <em><span class="math inline">\(K\)</span>广义对象的输出输入比 </em><span class="math inline">\(T=1.5(t_{y=0.632}-t_{y=0.283})\)</span> *<span class="math inline">\(\tau=t_{y=0.283}-T\)</span></li>
</ol></li>
</ul>
<h2 id="反馈控制">3 反馈控制</h2>
<p>最基本、应用最广泛——单回路反馈控制</p>
<p>反馈不是唯一的控制方法，但是最简单、鲁棒性最好。</p>
<h3 id="性能指标">3.1 性能指标</h3>
<ul>
<li><p>以阶跃响应的特征参数为指标</p>
<ul>
<li><p>衰减比 一般<span class="math inline">\(4:1-10:1\)</span>之间，保持足够的稳定裕度。不希望有振荡的就不要了</p></li>
<li><p>余差</p></li>
</ul></li>
<li><p>偏差积分性能指标</p>
<p>一个综合性的指标来全面反映控制的品质</p>
<ul>
<li>偏差积分IE ：不能保证有合适衰减比</li>
<li>平方偏差积分 ISE ：数学上处理较为方便</li>
<li>绝对偏差积分 IAE ：较为常用</li>
</ul></li>
</ul>
<h3 id="pid">3.2 PID</h3>
<ul>
<li><strong>P</strong>比例控制
<ul>
<li>输出=k*偏差+稳态工作点</li>
<li>比例度<span class="math inline">\(PB=1/K_c\)</span> <em><span class="math inline">\(K_c\)</span>的选择是对</em>稳定性<em>和</em>精度*的权衡，越大精度提高，但稳定性变差</li>
<li>缺点：存在余差，但很多场合适用（液位）</li>
</ul></li>
<li><strong>PI</strong>比例积分控制
<ul>
<li>静态增益<span class="math inline">\(\infty\)</span>，所以没有余差</li>
<li>因为带来相角滞后，因此稳定性变差，所以<span class="math inline">\(K_c\)</span>要相应减小</li>
<li>积分饱和问题：控制器的饱和输出比执行机构的范围大，使得控制信号很慢回落
<ul>
<li>解决方法：当发现控制器输出饱和时，就停止积分作用。用控制器的输出值作为反馈信号</li>
</ul></li>
</ul></li>
<li><strong>PID</strong>比例积分微分控制
<ul>
<li>微分控制通过误差的变化率来预报误差信号的变化趋势</li>
<li>理想微分实现不了，用传递函数近似</li>
</ul></li>
</ul>
<blockquote>
<p>为什么PID在时域中有偏置<span class="math inline">\(u_0\)</span>，但在复频域的算式中没有？</p>
<p>答：因为传递函数表达的是系统在稳态工作点附近变化时的情况</p>
</blockquote>
<p><strong>理论PID模拟</strong>算式 <span class="math display">\[
u ( t ) = K _ { c } \left[ e ( t ) + \frac { 1 } { T _ { i } } \int _ { 0 } ^ { t } e ( \tau ) d \tau + T _ { d } \frac { d e ( t ) } { d t } \right] + u _ { 0 }
\]</span> 当然实际上无法达到，无论是理论的积分还是微分。<strong>位置式数字PID</strong> <span class="math display">\[
u ( k ) = K _ { c } \left[ e ( k ) + \frac { T _ { s } } { T _ { i } } \sum _ { j = 0 } ^ { k } e ( j ) + \frac { T _ { d } } { T _ { s } } ( e ( k ) - e ( k - 1 ) ) \right] + u _ { 0 }
\]</span> 上式计算机可以实现，但是要存储过往的误差消耗空间太大，提出<strong>增量式数字PID</strong> <span class="math display">\[
\begin{array} { l } { \Delta u ( k ) = u ( k ) - u ( k - 1 ) } \\ { \qquad \quad= K _ { c } \left[ ( e ( k ) - e ( k - 1 ) ) + \frac { T _ { s } } { T _ { i } } e ( k ) + \frac { T _ { d } } { T _ { s } } ( e ( k ) - 2 e ( k - 1 ) + e ( k - 2 ) ) \right] } \end{array}
\]</span></p>
<h3 id="pid的选取与整定">3.3 PID的选取与整定</h3>
<ul>
<li><p>选型</p>
<ul>
<li><p>P：简单，调整方便，但有余差。特别适合具有积分环节的对象以及允许余差的场合</p></li>
<li><p>PI：大部分都是PI。流量和快速压力等滞后小、运行周期短的过程，<span class="math inline">\(K_c\)</span>一般取得比较小，如果不用积分就会有较大余差</p></li>
<li><p>PID：对于响应过程缓慢的过程如温度控制和成分控制，可以加入微分作用。在具有高频噪声的场合不适宜PID</p></li>
<li><p>正反作用：<del>要想使得回路是负反馈，各个环节最后的乘积要为负（正作用为+，负作用为—）</del> 对象输出变大，控制器输出也变大，就是正作用</p></li>
</ul></li>
<li><p>参数整定</p>
<p>可以利用积分准则(ISE)来求最佳，但是比较费时。工程整定法如下</p>
<ul>
<li>经验法</li>
<li>临界比例度法(Z-N法)
<ul>
<li>只保留比例作用，调整<span class="math inline">\(K_c\)</span>直到系统振荡，根据临界振荡周期和临界比例增益来求PID参数</li>
<li>限制：需要对象高阶或有纯滞后，否则不会振荡</li>
</ul></li>
<li>响应曲线法：根据一阶纯滞后模型的参数来求PID参数</li>
</ul></li>
</ul>
<h2 id="前馈控制和比例控制">4 前馈控制和比例控制</h2>
<p>反馈只有在被控变量产生偏差以后才能校正，不提供预测功能</p>
<p>前馈控制器</p>
<ul>
<li>特点：反应快，开环控制，“专用”控制器</li>
<li>结构形式
<ul>
<li>静态前馈，只要稳态下实现补偿，是一个定值</li>
<li>动态前馈，即使工作点转移也能有“全补偿”的性能</li>
<li>单独的前馈不太好用，所以一般和反馈一起使用，构成<em>前馈-反馈控制</em>
<ul>
<li>对前馈来说，降低了对模型精度的要求</li>
<li>对反馈来说，对干扰做了及时的粗调</li>
</ul></li>
</ul></li>
<li>线性、非线性？
<ul>
<li>要根据系统的特性(能量守恒、物料守恒)来选择不同前馈变量之间的关系(<span class="math inline">\(+、 - 、\div、\times\)</span>)</li>
</ul></li>
</ul>
<p>其中一种特殊的方法——比值控制，工业生产中很多过程可以通过保持物料的流量比来保证<strong>产品质量</strong></p>
<ul>
<li>定比值控制
<ul>
<li>开环：无法保证两流量比值</li>
<li>单闭环：PI控制器，但主流量不可控，所以总流量不能控制</li>
<li>双闭环：有设定值，能控制主流量</li>
</ul></li>
<li>变比值控制
<ul>
<li>干扰造成最后产品质量的误差，很难通过人工手工调节比值</li>
<li>根据工艺参数<span class="math inline">\(y\)</span>自动改变比值</li>
</ul></li>
<li>其他问题
<ul>
<li>实现方式
<ul>
<li>相乘<span class="math inline">\(\times\)</span>方案：将流量作为设定值</li>
<li>相除<span class="math inline">\(\div\)</span>方案：将比值作为设定值，尽量少用</li>
</ul></li>
<li>逻辑提降：双交叉控制</li>
</ul></li>
</ul>
<h2 id="其他典型控制系统">5 其他典型控制系统</h2>
<p>过程变得复杂时，在单回路PID上改进</p>
<h3 id="串级控制">5.1 串级控制</h3>
<p>用途和串级类似，也是用来克服干扰。主要就是增加第二测量点，能更快检测干扰并克服。</p>
<ul>
<li>主控制器接受设定值，副控制器输出控制信号</li>
<li>副回路具有快速调节作用</li>
<li>主回路对副对象有较好的<a href="系统品质对对象特性变化越不敏感，系统就越鲁棒">鲁棒性</a> 。因为只要副回路增益够大</li>
<li>系统设计
<ul>
<li>原则:
<ul>
<li>尽量多的干扰放在副回路中</li>
<li>副回路滞后不能太大</li>
<li>具有非线性和时变的特征放入副回路</li>
</ul></li>
<li>控制器选型
<ul>
<li>主控制器PID</li>
<li>副回路大部分时候用PI</li>
</ul></li>
<li>正反作用：反正都是要让两个回路构成负反馈</li>
<li>抗积分饱和：用负变量的测量值作为反馈信号</li>
<li>微分先行：如果给定值频繁变化，那么直接加在控制器里的微分结果会有很大的跳变。所以“先行”，加在测量变送的后面，这样就不会有跳变。</li>
</ul></li>
</ul>
<h3 id="均匀控制">5.2 均匀控制</h3>
<p>要解决的问题：怎样将一个变化较剧烈的流量换成一个变化平缓的流量？</p>
<ul>
<li>加一个缓冲罐，但是要增加设备、可能产生副反应</li>
<li>均匀控制：让液面平稳变化，所以相比单纯的液面控制来说，比例度宽，积分时间大</li>
</ul>
<h3 id="选择控制超驰控制">5.3 选择控制(超驰控制)</h3>
<p>主要用于设备<em>软保护</em>，也就是引入选择器，当参数达到极限时的控制手段。</p>
<p>设计步骤：</p>
<ol type="1">
<li>首先根据<em>控制阀</em>的特性确定<em>控制器</em>的正反特性</li>
<li>根据<em>控制器</em>的特性确定<em>选择器</em>的性质（LS）</li>
</ol>
<p>抗积分饱和：</p>
<ul>
<li>限幅法：高低值限幅器</li>
<li><strong>外反馈法</strong>（用在<strong>选择控制</strong>中）：采用合适的外部信号作为反馈信号
<ul>
<li>当控制器1工作时，对1来说反馈信号是自己，对2来说反馈信号是外部</li>
</ul></li>
<li>积分切除法：开环情况下自动切除积分作用</li>
</ul>
<h3 id="分程和阀位控制">5.4 分程和阀位控制</h3>
<p>分程就是一台控制器操纵几个阀门。目的：</p>
<ul>
<li>扩大控制阀的可调范围，改善控制系统的品质
<ul>
<li>有些场合可调范围特别大，所以在高低负荷下都不能好好工作，</li>
<li>选两个同向阀，组合之后，扩大可调范围</li>
</ul></li>
<li>满足工艺操作的要求
<ul>
<li>e.g. 有时需加热、有时又要移走热量，就要配置两个控制阀</li>
<li>设计步骤
<ol type="1">
<li>根据阀的气开气关特性，选择控制器的正反作用</li>
<li>根据节能要求，确定分程区间</li>
</ol></li>
</ul></li>
</ul>
<hr />
<p>生产上存在多个变量都能影响同一被控变量的情况。</p>
<p>有良好动态性能的变量，静态性能差</p>
<blockquote>
<p>e.g. 加热炉内温度可以通过两种手段改变</p>
<ul>
<li>加水冷却，动态性能好，但能量损失大，静态性能差</li>
<li>改变进料多少，动态性能不佳，但静态性能好</li>
</ul>
</blockquote>
<p>为了协调这些矛盾，引入<strong>阀位控制</strong></p>
<ul>
<li>加水冷却回路的阀门开度<strong>要小</strong>，通过参数整定，使其动作缓慢（宽比例度、大积分时间）</li>
<li>燃料阀是普通控制</li>
</ul>
<h3 id="非线性补偿方法">5.5 非线性补偿方法</h3>
<p>大多数控制过程都有一定非线性，因此要引入补偿，常用的补偿方法：</p>
<ul>
<li>控制阀特性补偿：实现广义对象增益近似线性</li>
<li>串级控制</li>
<li>引入中间变量</li>
<li>变增益控制器</li>
</ul>
<p><span class="math inline">\(pH\)</span>控制实例：</p>
<ul>
<li>单回路PID控制，在<span class="math inline">\(pH=7\)</span>附近容易振荡</li>
<li>带有不灵敏区的非线性PID，在<span class="math inline">\(pH=7\)</span>附近控制器增益变小</li>
<li>引入非线性变化的线性PID，不用<span class="math inline">\(pH\)</span>控制，而直接控制浓度</li>
</ul>
<h2 id="多回路控制系统">6 多回路控制系统</h2>
<p>当有多个操纵变量，多个被控变量时，如何选择输入输出就很难判断。</p>
<p>在设计之前，对过程的耦合程度有了充分了解之后再进行设计</p>
<h3 id="相对增益">6.1 相对增益</h3>
<p>相对增益<span class="math inline">\(\lambda_{11}\)</span>为开环增益<span class="math inline">\(K_{11}\)</span>(回路2开环)与闭环增益<span class="math inline">\(K&#39;_{11}\)</span>(回路2闭环)之比。</p>
<blockquote>
<p>计算：</p>
<ol type="1">
<li>计算开环增益矩阵<span class="math inline">\(K\)</span>，其中<span class="math inline">\(K _ { i j } = \left. \frac { \partial y _ { i } } { \partial u _ { j } } \right| _ { \Delta y_ { e } = 0 }\)</span></li>
<li>计算$ =  ^ { - 1 } $</li>
<li>相对增益矩阵<span class="math inline">\(\left\{ \mu _ { i j } \right\} = \mathrm { K } \bullet \mathrm { H } ^ { T }\)</span>，其中<span class="math inline">\(\bullet\)</span>为点乘，即对应位置的相乘</li>
</ol>
</blockquote>
<p>含义：其他通道开环时，通道<span class="math inline">\(u_j-y_i\)</span>的静态增益为<span class="math inline">\(K_{ij}\)</span>，当其他回路闭环时，该通道静态增益变为<span class="math inline">\(\frac1{\lambda_ij}\)</span>倍</p>
<p>因此，相对增益越接近1越好，说明耦合越小</p>
<hr />
<p>有了相对增益矩阵，如何进行配对？</p>
<p>首先接近1的先配对，然后将这一通道断开</p>
<h3 id="耦合系统中的控制器参数整定">6.2 耦合系统中的控制器参数整定</h3>
<h3 id="解耦控制方案设计">6.3 解耦控制方案设计</h3>
<p>本质：设计一个计算网络，用它去抵消过程中的关联。</p>
<p>基于方框图的解耦器：</p>
<ul>
<li><p><strong>串级解耦</strong></p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/串级解耦.png" alt="串级解耦" /><figcaption aria-hidden="true">串级解耦</figcaption>
</figure>
<ul>
<li><p>初始化问题，怎么样设置初值以满足无扰动地从"手动"投入"自动"？</p>
<p>根据<span class="math inline">\(u_1,u_2\)</span>观察框图，反推<span class="math inline">\(v_1,v_2\)</span></p></li>
<li><p>运行约束问题，当<span class="math inline">\(u_1,u_2\)</span>中有一个受到比如控制阀上下限这样地约束，就不能很好地达到控制效果。</p></li>
</ul></li>
<li><p><strong>前馈解耦</strong></p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/前馈解耦.png" alt="前馈解耦" /><figcaption aria-hidden="true">前馈解耦</figcaption>
</figure>
<p>因为串级解耦的一些问题，因此工业中常用<strong>前馈解耦</strong></p>
<ul>
<li>当某一变量受约束时，使相应控制回路等价于开环</li>
<li>但是含有可能不稳定的回路</li>
</ul></li>
</ul>
<h2 id="基于模型的控制">7 基于模型的控制</h2>
<p>史密斯预估器：自己进行机理建模，将纯滞后给消除掉</p>
<p>但是对于模型的准确度要求较高，因此改进加入预测误差滤波器<span class="math inline">\(G _ { f } ( s ) = \frac { 1 } { T _ { f } s + 1 }\)</span></p>
<h2 id="锅炉设备中汽包水位的控制">8 锅炉设备中汽包水位的控制</h2>
<p>汽包水位时锅炉运行的主要指标，不能太低（容易干烧），也不能太高（容易结垢）</p>
<p>控制方法：</p>
<ul>
<li>单冲量：只控制给水，但由于假水位现象，可能效果不好</li>
<li>双冲量：根据蒸汽流量来纠正虚假水位引起的误动作，但静态补偿比较困难，而且给水系统的干扰难以克服</li>
<li>三冲量：引入给水信号，消除给水系统的干扰</li>
</ul>
<h2 id="精馏塔">9 精馏塔</h2>
<h3 id="基础知识">9.1 基础知识</h3>
<ul>
<li>单一组分液体，在封闭容器中，经过一定时间，系统达到平衡时的气相绝对压力</li>
<li>分离度<span class="math inline">\(S = \frac { x _ { D } } { 1 - x _ { D } } \times \frac { 1 - x _ { B } } { x _ { B } }\)</span></li>
</ul>
<h3 id="控制问题">9.2 控制问题</h3>
<ul>
<li>目标：控制产品纯度(大多数只有一端出料)、增加产品产率(产品量与进料的比值)</li>
<li>被控变量<span class="math inline">\(CV\)</span>，产品质量、液位
<ul>
<li>光谱分析，可以直接得到纯度</li>
<li>相对稳定时，<em>灵敏板温度</em>也可以简介反映纯度</li>
<li>不稳定时，选择灵敏板温度和塔顶温度之差</li>
</ul></li>
<li>操作变量<span class="math inline">\(MV\)</span>，塔顶产品量<span class="math inline">\(D\)</span>，回流量$L $</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/精馏塔.png" alt="精馏塔" /><figcaption aria-hidden="true">精馏塔</figcaption>
</figure>
<h3 id="控制方案">9.3 控制方案</h3>
<ul>
<li><p><strong>变量配对</strong></p>
<ul>
<li>就近原则：<a href="顶部的操作变量来控制顶部的被控变量">上管上</a>，下管下</li>
<li>耦合程度要低</li>
</ul></li>
<li><p><strong>物料平衡控制</strong></p>
<p>当精馏塔进料变化不大，或者纯度要求不高时，可采用<strong>纯物料平衡控制</strong></p>
<ul>
<li><span class="math inline">\(CV\)</span>：<span class="math inline">\(L_D, L_B\)</span>顶部和底部液位</li>
<li><span class="math inline">\(MV\)</span>：可以用<span class="math inline">\(D,L,B,Q_H\)</span>塔顶产品量、塔顶回流量、塔底产品量和加热蒸汽量</li>
<li>方案1：<span class="math inline">\(D \to L_D\)</span>,<span class="math inline">\(B \to L_B\)</span>
<ul>
<li>两液位回路无耦合</li>
<li>干扰因素<span class="math inline">\(V\)</span>对纯度影响较大</li>
</ul></li>
<li>方案2：<span class="math inline">\(L\to L_D\)</span>,<span class="math inline">\(B\to L_B\)</span>
<ul>
<li>两液位回路无耦合</li>
<li>干扰因素<span class="math inline">\(V\)</span>对纯度影响较小</li>
<li>不适合小回流比产品</li>
</ul></li>
</ul></li>
<li><p><strong>塔顶产品纯度控制</strong></p>
<p>当精馏塔进料变化较大，或者纯度要求高时，可选择<strong>精馏段控制目标</strong>，塔底还是物料平衡控制</p>
<ul>
<li><p><span class="math inline">\(CV\)</span>：<span class="math inline">\(L_D, L_B,T_R\)</span>顶部和底部液位，塔顶产品纯度</p></li>
<li><p><span class="math inline">\(MV\)</span>：可以用<span class="math inline">\(D,L,B,Q_H\)</span>塔顶产品量、塔顶回流量、塔底产品量和加热蒸汽量</p></li>
<li><p>方案1：<span class="math inline">\(B\to L_B\)</span>，<span class="math inline">\(L \rightarrow T _ { R} , D \rightarrow L _ { D }\)</span></p>
<ul>
<li><p><span class="math inline">\(L\)</span>对<span class="math inline">\(T_R\)</span>的控制快而且强</p></li>
<li><p>回流量频繁波动</p></li>
</ul></li>
<li><p>方案2：<span class="math inline">\(B\to L_B\)</span>，<span class="math inline">\(D \rightarrow T _ { R } , L \rightarrow L _ { D }\)</span></p>
<ul>
<li><p><span class="math inline">\(D\)</span>对<span class="math inline">\(T_R\)</span>的控制比较慢</p></li>
<li><p>有利于平稳操作</p></li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>Control</category>
        <category>Process Control</category>
      </categories>
      <tags>
        <tag>control</tag>
        <tag>process</tag>
      </tags>
  </entry>
  <entry>
    <title>倒立摆的控制设计</title>
    <url>/2019/07/16/Control/Project/InvertedPendulum/</url>
    <content><![CDATA[<h2 id="题目要求">题目要求</h2>
<p>设计并制作一套简易的旋转倒立摆及其控制机构</p>
<ul>
<li>基本要求
<ol type="1">
<li>摆杆从自然下垂状态开始，驱动电机带动旋转臂作往复旋转，使摆角达到或超过<strong>60°</strong></li>
<li>摆杆从自然下垂状态开始，尽快增大摆杆的摆动幅度，直至完成<strong>圆周运动</strong></li>
<li>外力拉起摆杆至165°左右，撤除外力，启动控制旋转使摆杆<strong>保持倒立不少于5秒钟</strong></li>
</ol></li>
<li>发挥部分
<ol type="1">
<li>摆杆从自然下垂状态开始，驱动电机带动旋转臂作往复旋转，使摆杆倒立并保持10秒钟</li>
<li>倒立状态下，施加干扰后能继续保持</li>
<li>倒立状态下，旋转臂做圆周运动</li>
</ol></li>
</ul>
<h2 id="程序控制">程序控制</h2>
<h3 id="基本输出输出">基本输出输出</h3>
<p>输入：</p>
<ul>
<li>编码器输入
<ul>
<li>A相，方波，数字信号</li>
<li>B相，方波，数字信号</li>
</ul></li>
<li>摆杆传感器
<ul>
<li>模拟量直接输出，模拟量，模拟信号</li>
</ul></li>
</ul>
<p>输出</p>
<ul>
<li>电机
<ul>
<li>IN1，布尔值，数字信号</li>
<li>IN2，布尔值，数字信号</li>
<li>PWM，方波，数字信号</li>
</ul></li>
</ul>
<h3 id="基本动作">基本动作</h3>
]]></content>
      <categories>
        <category>Control</category>
        <category>Project</category>
      </categories>
      <tags>
        <tag>control</tag>
      </tags>
  </entry>
  <entry>
    <title>古典音乐--Coursera笔记</title>
    <url>/2019/08/09/Life/Music/classic-music/</url>
    <content><![CDATA[<h2 id="overview">Overview</h2>
<h3 id="与流行音乐的区别">与流行音乐的区别</h3>
<ol type="1">
<li>用的乐器</li>
<li>有无歌词</li>
<li>节奏(节制、明显)</li>
<li>长短、重复</li>
<li>有无固定的表演内容</li>
</ol>
<a id="more"></a>
<h3 id="音乐与情感">音乐与情感</h3>
<p>音乐可以影响我们的情感</p>
<ul>
<li>强调某种信息</li>
<li>渲染某种环境</li>
</ul>
<p>音乐就是一段被安排的声音序列</p>
<p>什么是声音呢？声波传递到我们的耳朵，低音和高音是在频率上的变化，声音通过空气进入我们的耳朵，耳蜗接受震动，测出频率，告诉大脑。</p>
<p>音乐如何刺激我们？ 影响神经元，改变身体中各种化学元素的分泌。No Drugs，Just Music</p>
<ul>
<li>比如说有时候我们会感到战栗——有论文解释：感到战栗时，大脑某些部分的血流量会变化</li>
</ul>
<h3 id="为什么我们会喜欢我们所喜欢的">为什么我们会喜欢我们所喜欢的</h3>
<p>当我们去听音乐时，我们有一个期待——<strong><em>Music Template</em></strong></p>
<p>这种期待是从何而来的的？</p>
<ul>
<li>教育，<strong>成长的环境</strong>及在其中所听到的音乐，我们经常听到某种音乐，所以感到舒适</li>
<li>天性，研究表明，婴儿在听到合适的音乐之后会感到舒适、心跳会变缓，营养吸收增强</li>
</ul>
<p>有一些音乐世界所共用的规则</p>
<ul>
<li>频率和幅度的关系，一般来说呈反比，频率越小，幅度越大，声音也就越响</li>
</ul>
<h3 id="西方音乐的语法">西方音乐的语法</h3>
<p>一些音乐的属性，不属于物理，而是属于文化的一些规定</p>
<ol type="1">
<li>Leading Tone</li>
<li>Large Leap</li>
<li>Harmony</li>
<li>Chord Progression</li>
</ol>
<h2 id="rhythm-melody-harmony">Rhythm Melody Harmony</h2>
<h3 id="rhythm">Rhythm</h3>
<p>节奏出现在音乐中，也出现在生活中（比如心跳）</p>
<p>流行乐往往有很强的beat，经典音乐也有beat，但往往是被压抑的，不明显的</p>
<p>beat，也就是节拍，在被我们听到时往往是是被大脑分成一部分一部分的，比如2，3，4个节拍算1组</p>
]]></content>
      <categories>
        <category>Life</category>
        <category>Music</category>
      </categories>
      <tags>
        <tag>skills</tag>
      </tags>
  </entry>
  <entry>
    <title>聆听音乐</title>
    <url>/2019/08/30/Life/Music/listen-to-music/</url>
    <content><![CDATA[<h2 id="introduction">1 Introduction</h2>
<p>导言</p>
]]></content>
      <categories>
        <category>Life</category>
        <category>Music</category>
      </categories>
      <tags>
        <tag>skills</tag>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>音乐的乐理基础——数学角度</title>
    <url>/2019/08/09/Life/Music/music-engineering/</url>
    <content><![CDATA[<h2 id="声学基础">1 声学基础</h2>
<p>音乐由声波构成，声波是一种机械波。声波以某种频率进行频率和强弱的变化构成了音乐</p>
<ul>
<li>频率：标准计量单位为赫兹<span class="math inline">\(Hz\)</span>，即一秒内峰的个数</li>
<li>振幅：音量的大小</li>
</ul>
<h3 id="声音的复合">1.1 声音的复合</h3>
<ul>
<li>纯音：以固定频率进行简谐振动</li>
<li>复合音：有多个纯音组成，音乐由大量不同的复合音构成。产生方式有
<ul>
<li>谐波叠加</li>
<li>拍音叠加</li>
</ul></li>
</ul>
<p>最基本的纯音组合<span class="math inline">\(\to\)</span>单音，组合<span class="math inline">\(\to\)</span>拍音</p>
<a id="more"></a>
<h4 id="谐波-overtone">谐波 Overtone</h4>
<p>在音乐领域中往往称为<strong>泛音</strong></p>
<p>一个标准的正弦波可以称为基波，频率是基波整数倍的波是谐波</p>
<p>钢琴的<strong>一个</strong>键或者小提琴的<strong>一根</strong>弦都能产生<strong>多个谐波</strong>，合成之后叫做<strong>单音</strong></p>
<p>比若说小提琴声音的形成过程，典型的<strong>谐波叠加</strong>，<a href="https://github.com/hujunhan/cloudimage/blob/master/audio/violin-wave.wav">下载之后用播放器播放</a></p>
<h4 id="拍音">拍音</h4>
<p>另一种复合音，由两个或多个<strong>单音</strong>叠加，一般要求这两个音的<strong>振幅相近</strong></p>
<p>纯八度的拍音是由频率是<span class="math inline">\(1:2\)</span>的两个单音构成的</p>
<h2 id="十二平均律和五线谱">2 十二平均律和五线谱</h2>
<p>人类三大乐器有</p>
<ul>
<li><strong>弦乐</strong>--音律学的发展起源
<ul>
<li>用琴弦振动发出声音，长短、粗细、密度都决定了振动的频率</li>
<li>一般来说，频率和长度成反比</li>
</ul></li>
<li>管乐</li>
<li>打击乐</li>
</ul>
<p>为了保证音乐的表达效果，所以要定出</p>
<ul>
<li>相对音高，将不同的单音组合起来——使用<strong>十二平均律</strong></li>
<li>绝对音高，使得在不同地方演奏的效果相同——使用<strong>五线谱</strong></li>
</ul>
<h3 id="十二平均律">2.1 十二平均律</h3>
<p>作用：规定两个单音的相对音高</p>
<p>定义：</p>
<ul>
<li><strong>纯八度</strong>：频率为<span class="math inline">\(1:2\)</span>的两个单音之间的<strong>音程</strong></li>
<li>将一个纯八度分为<strong>12份</strong>，每份称为1个<strong>半音</strong>，两份称为1个<strong>全音</strong></li>
<li><strong>音程</strong>：两个音之间的频率差矩，单位为<strong>全音</strong>，计算方式为<span class="math inline">\(f_x=f_0*2^\frac{x}{12}\)</span></li>
</ul>
<table>
<thead>
<tr class="header">
<th>相差音数</th>
<th>0.5</th>
<th>1</th>
<th>1.5</th>
<th>2</th>
<th>2.5</th>
<th>3</th>
<th>3.5</th>
<th>4</th>
<th>4.5</th>
<th>5</th>
<th>5.5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>音程名称</strong></td>
<td><strong>小二度</strong></td>
<td><strong>大二度</strong></td>
<td><strong>小三度</strong></td>
<td><strong>大三度</strong></td>
<td><strong>纯四度</strong></td>
<td><strong>三全音</strong></td>
<td><strong>纯五度</strong></td>
<td><strong>小六度</strong></td>
<td><strong>大六度</strong></td>
<td><strong>小七度</strong></td>
<td><strong>大七度</strong></td>
<td><strong>纯八度</strong></td>
</tr>
</tbody>
</table>
<h3 id="五线谱">2.2 五线谱</h3>
<p>作用：记录任何形式的音乐</p>
<p>定义：</p>
<ul>
<li><p>音符：一个音符表达一个单音，每个音符有绝对的音高</p>
<ul>
<li><strong>符头</strong>--决定了音高</li>
<li>符杆--连接作用</li>
<li>符尾--见机行事，符头高了就在下，符头低了就在上</li>
</ul></li>
<li><p>五线谱：五条线，从下到上是<strong>频率</strong>的变化，从左到右是<strong>时间</strong>的变化</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/music-5-A-G.png" /></p>
<p>半、全意味着两个音符之间的音程是全音还是半音</p></li>
<li><p>谱号：五线谱最左边，规定了线和间上的音符的<strong>音高</strong></p></li>
<li><p>升降记号，在音符后面添加标记</p>
<ul>
<li><strong>升号</strong> #</li>
<li><strong>降号</strong> b</li>
</ul></li>
</ul>
<p>一共有7个音符</p>
<table>
<thead>
<tr class="header">
<th>音名</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>唱名</td>
<td>La</td>
<td>Si</td>
<td>Do</td>
<td>Re</td>
<td>Mi</td>
<td>Fa</td>
<td>So</td>
</tr>
</tbody>
</table>
<p>相邻的同名音符之间的音程是八度，也就是频率高了一倍</p>
<p><strong>规定</strong>：</p>
<ul>
<li><p>第二间的La，为A，频率为<span class="math inline">\(440Hz\)</span>，所以以它为基准，其他音符的频率就可以推导出来了</p></li>
<li><p>C4位于高音五线谱的下加一线，往高依次是D4、E4、F4，往下依次是B3、A3</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/music-c.png" /></p></li>
<li><p>A4的频率是440<span class="math inline">\(Hz\)</span>，所以A音的频率为下表</p>
<table>
<thead>
<tr class="header">
<th>基准音名</th>
<th>A0</th>
<th>A1</th>
<th>A2</th>
<th>A3</th>
<th>A4</th>
<th>A5</th>
<th>A6</th>
<th>A7</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>频率(Hz)</td>
<td>27.5</td>
<td>55</td>
<td>110</td>
<td>220</td>
<td>440</td>
<td>880</td>
<td>1760</td>
<td>3520</td>
</tr>
</tbody>
</table>
<p>所以可以根据A的频率计算其他几个音的频率</p></li>
<li><p>若两个键之间是一个音程，那中间就可以有一个半音，比如Bb==A#</p>
<ul>
<li>有两个音没有必要升，E升半音就是F，B升半音就是C</li>
</ul></li>
</ul>
<h3 id="和声">2.3 和声</h3>
<p>定义：由超过一个单音所组合而成的声音，所以定义和<strong>拍音</strong>非常相似</p>
<ul>
<li>西方古典音乐理论中，和声主要研究的是<strong>两个单音</strong>构成的和声，三个以上单音一般称为和弦</li>
</ul>
<p>有的和声比较和谐，有的比较刺耳，究其原因就是因为拍音。</p>
<p>相邻两个音之间的频率是以指数变化的，所以近似的频率比，周期所产生的最小公倍数会相差较大。所以最小公倍数小的，就比较和谐</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">音程</th>
<th style="text-align: center;">近似频率比</th>
<th style="text-align: center;">近似整数比</th>
<th style="text-align: center;">最小公倍数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">小二度</td>
<td style="text-align: center;">1:1.06</td>
<td style="text-align: center;">15:16</td>
<td style="text-align: center;">240</td>
</tr>
<tr class="even">
<td style="text-align: center;">大二度</td>
<td style="text-align: center;">1:1.12</td>
<td style="text-align: center;">8:9</td>
<td style="text-align: center;">72</td>
</tr>
<tr class="odd">
<td style="text-align: center;">小三度</td>
<td style="text-align: center;">1:1.19</td>
<td style="text-align: center;">5:6</td>
<td style="text-align: center;">30</td>
</tr>
<tr class="even">
<td style="text-align: center;">大三度</td>
<td style="text-align: center;">1:1.26</td>
<td style="text-align: center;">4:5</td>
<td style="text-align: center;">20</td>
</tr>
<tr class="odd">
<td style="text-align: center;">纯四度</td>
<td style="text-align: center;">1:1.34</td>
<td style="text-align: center;">3:4</td>
<td style="text-align: center;">12</td>
</tr>
<tr class="even">
<td style="text-align: center;">三全音</td>
<td style="text-align: center;">1:1.41</td>
<td style="text-align: center;">7:10</td>
<td style="text-align: center;">70</td>
</tr>
<tr class="odd">
<td style="text-align: center;">纯五度</td>
<td style="text-align: center;">1:1.50</td>
<td style="text-align: center;">2:3</td>
<td style="text-align: center;">6</td>
</tr>
<tr class="even">
<td style="text-align: center;">小六度</td>
<td style="text-align: center;">1:1.59</td>
<td style="text-align: center;">5:8</td>
<td style="text-align: center;">40</td>
</tr>
<tr class="odd">
<td style="text-align: center;">大六度</td>
<td style="text-align: center;">1:1.68</td>
<td style="text-align: center;">3:5</td>
<td style="text-align: center;">15</td>
</tr>
<tr class="even">
<td style="text-align: center;">小七度</td>
<td style="text-align: center;">1:1.78</td>
<td style="text-align: center;">5:9</td>
<td style="text-align: center;">45</td>
</tr>
<tr class="odd">
<td style="text-align: center;">大七度</td>
<td style="text-align: center;">1:1.89</td>
<td style="text-align: center;">8:15</td>
<td style="text-align: center;">120</td>
</tr>
<tr class="even">
<td style="text-align: center;">纯八度</td>
<td style="text-align: center;">1:2</td>
<td style="text-align: center;">1:2</td>
<td style="text-align: center;">2</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Life</category>
        <category>Music</category>
      </categories>
      <tags>
        <tag>skills</tag>
      </tags>
  </entry>
  <entry>
    <title>How to Read Academic Paper</title>
    <url>/2019/12/26/Life/Skills/how-to-read-paper/</url>
    <content><![CDATA[<h2 id="three-pass-approach">Three-Pass Approach</h2>
<p>Key idea: read a paper up tp 3 passes, each pass accomplishes specific goals</p>
<h3 id="the-first-pass">The First Pass</h3>
<p>quick scan, decide whether you need to do any more passes, take about 5-10 minutes</p>
<ol type="1">
<li>read the title and abstract, introduction carefully</li>
<li>read section headings</li>
<li>read the conclusions</li>
<li>glance the references</li>
</ol>
<p>After reading, you should get <em>five Cs</em></p>
<ul>
<li>category</li>
<li>context</li>
<li>correctness</li>
<li>contributions</li>
<li>clarity</li>
</ul>
<h3 id="the-second-pass">The Second Pass</h3>
<p>read the paper with greater care, but ignore the details such as proofs, take up to 1 hour,</p>
<ol type="1">
<li>look carefully at the figures, diagrams</li>
<li>mark relevant unread references</li>
</ol>
<p>After this pass, able to grasp the content.</p>
<p>Sometimes you can not understand the paper if there are some unfamiliar terminology</p>
<h3 id="the-third-pass">The Third Pass</h3>
<p>Key: try to <em>virtually re-implement</em> the paper: making the same assumptions, re-create the work</p>
<ol type="1">
<li>identify and challenge every assumption in every statement</li>
<li>think about how you yourself would present such a idea</li>
</ol>
<p>This pass would take 4-5 hours for beginners.</p>
<h2 id="literature-survey">Literature Survey</h2>
<ol type="1">
<li>Use an academic search such as Google Scholar, find 3-5 <strong>recent</strong> papers in the area
<ul>
<li>Do one pass on each paper, find a thumbnail summary of the recent work</li>
</ul></li>
<li>Find <strong>shared citations (key papers)</strong> and repeated author names in the bibliography.
<ul>
<li>Go to the websites of the key researchers an find the <strong>top conferences</strong> in that field</li>
</ul></li>
<li>Go to the websites of the top conferences and find <strong>high-quality related work</strong>
<ul>
<li>these papers and key papers constitute the first version of your survey</li>
</ul></li>
</ol>
]]></content>
      <categories>
        <category>Life</category>
        <category>Skills</category>
      </categories>
      <tags>
        <tag>skills</tag>
        <tag>academic</tag>
      </tags>
  </entry>
  <entry>
    <title>游泳进阶--自由泳</title>
    <url>/2019/07/25/Life/Skills/how-to-swim-freestyle/</url>
    <content><![CDATA[<h2 id="自由泳简介">自由泳简介</h2>
<p>6月末开始学习游泳，首先学的是蛙泳。经过6次练习之后，掌握了基本的技巧，能够实现蹬腿换气的连续运作。</p>
<p>但是蛙泳的速度不快——我以较为平缓的节奏蛙泳大概速度为50分钟每1000米。初次之外，蛙泳还对关节会有损伤，因此我开始学习自由泳。</p>
<blockquote>
<p>自由泳（freestyle），严格地来说不是一种游泳姿势，而是竞技游泳的一种比赛项目，它的竞赛规则对游泳姿势几乎没有任何限制，而<strong>爬泳</strong>这种姿势<strong>结构合理，阻力小，速度均匀、快速，是最省力、速度最快</strong>的一种游泳姿势。所以人们在这种对泳姿几乎没有任何限制的比赛项目里往往会使用爬泳这种阻力小、速度快的泳姿，所以在现在，通常把自由泳和爬泳等同看待</p>
<p>1896年第一届奥运会自由泳被列为正式的比赛项目。20世纪50年代以前，游泳运动员都非常重视两腿打水的作用，一般都是两臂轮流划水1次就打腿6次。后来科研材料证明打腿的能量消耗比划臂大得多，而<strong>推动身体前进的动力主要来自臂部的划水动作</strong>。因此以臂为主的现代自由泳技术重视臂的划水动作和两臂的配合。</p>
</blockquote>
<a id="more"></a>
<h2 id="首先练习自由泳腿">首先练习自由泳腿</h2>
<p>主要动作可以称为<strong>鞭腿</strong></p>
<ul>
<li>想象甩毛巾的动作，反映在动作上就是<strong>大腿带动小腿</strong></li>
<li>大腿要有收的动作，是为了更好地甩出去，收回来的时候要有大腿拖着小腿的感觉</li>
</ul>
<p>练习的效果应该是每一下打腿都能够起到向前的作用</p>
<p>练好之后再尝试<strong>侧身打腿</strong></p>
<ul>
<li>绷直，身体呈直线--大腿、臀部、脚</li>
<li>手要对着<strong>前面</strong>和<strong>后面</strong>，不要用手带动转体（手摆在另外一边）</li>
</ul>
<h2 id="然后练习转体">然后练习转体</h2>
<ol type="1">
<li>站在一堵墙面前，用肩左右转体触碰墙壁，找到转体的感觉</li>
<li>然后练习转体与打腿的配合</li>
<li>然后练习转体与侧身打腿的配合</li>
</ol>
<h2 id="ref">Ref</h2>
<p><a href="https://baike.baidu.com/item/%E8%87%AA%E7%94%B1%E6%B3%B3/1710776?fr=aladdin">自由泳-百度百科</a></p>
]]></content>
      <categories>
        <category>Life</category>
        <category>Skills</category>
      </categories>
      <tags>
        <tag>skills</tag>
        <tag>swim</tag>
      </tags>
  </entry>
  <entry>
    <title>学会游泳--蛙泳</title>
    <url>/2019/06/14/Life/Skills/how-to-swim/</url>
    <content><![CDATA[<h2 id="学会之后的总结">学会之后的总结</h2>
<ul>
<li>胆子要大，不要怕呛水</li>
<li>要多模仿他人，有即时的负反馈</li>
<li>腿部动作和手部动作可以分开来单独做，不一定需要依一定的相位交替进行
<ul>
<li>腿部主要就是蹬腿，想象身后有个人，伸腿去蹬他</li>
<li>手部的动作主要是为了产生向上的力去换气，所以不需要特别用力</li>
</ul></li>
</ul>
<h2 id="第一步-熟悉水中环境">第一步： 熟悉水中环境</h2>
<h3 id="克服恐惧">0 克服恐惧</h3>
<p>要想学会游泳，首先要克服的是自己的恐惧，不要害怕溺水，做好以下几步以防溺水</p>
<ul>
<li>与他人（会游泳）同行</li>
<li>不要在流动的水中游泳，比如河流或海洋</li>
<li>待在安全的深度区</li>
<li>避免在恶劣天气下游泳</li>
<li>不要在水温过低的情况下游泳</li>
</ul>
<a id="more"></a>
<h3 id="呼气">1 呼气</h3>
<p>练习时要练习两种呼气</p>
<ul>
<li>下水时<strong>鼻子呼气</strong>
<ul>
<li>如果鼻子只是憋着，那么到蛙泳时，头会往水里砸，这时候就算憋着水也会涌进来，所以在<strong>下水的瞬间</strong>呼气可以<strong>保持鼻子不进水</strong></li>
</ul></li>
<li>出水时嘴巴呼气
<ul>
<li>出水后通过嘴巴吸气效率较高，所以在出水前开始嘴巴呼气让嘴巴略微张开</li>
</ul></li>
</ul>
<h3 id="掌握漂浮">2 掌握漂浮</h3>
<p>下水后，手扶着泳池的边，让腿漂浮在身后。如果腿下沉了不要急，多试几次。</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/swim-float-leg.png" /></p>
<p>腿的漂浮成功之后尝试仰浮（趴着）、背浮（躺着），直到你能够让半个身体漂浮</p>
<ul>
<li>耳朵在水中，而鼻子嘴巴在空气中是正常的情况</li>
<li>为了保持稳定，可以将手臂张开保持<span class="math inline">\(T\)</span>型</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/swim-float-T.png" /></p>
<h3 id="保持镇定">3 保持镇定</h3>
<p>记住自己是安全的，因为就算你在很深的水域或者你的四肢都动不了，你也能靠你的<strong>背</strong>浮起来。不要慌张地摆动手或者急促的呼吸</p>
<h3 id="尝试水下呼气">4 尝试水下呼气</h3>
<p>深吸一口气，然后下沉到水下，慢慢地用鼻子呼气，应该是一串小气泡</p>
<ul>
<li>如果不习惯用鼻子呼气，可以先用手捏住鼻子用嘴呼气</li>
</ul>
<h2 id="蛙泳">蛙泳</h2>
<h3 id="动作">0 动作</h3>
<ol type="1">
<li>主要收小腿，次要收大腿，收完之后脚掌应该平着屁股</li>
<li>翻腿，往两边翻开</li>
<li>蹬夹，踹。想想向后用脚掌踹墙</li>
<li>伸直</li>
<li>停顿个一两秒</li>
</ol>
<p>蹬夹，精髓在于画个圈，蹬和收要连贯</p>
<h3 id="蹬腿">1 蹬腿</h3>
<p>不管是能够背浮还是只能拉着池边，都可以开始练习蹬腿</p>
<ul>
<li>尝试浅浅地打水，腿伸直，脚趾前伸，两腿交替。应该要感觉到大部分的完全来自脚踝</li>
<li>尝试<strong>蹬</strong>腿，先整条腿伸直，然后屈膝，大腿小腿成直角，然后小腿画半圆</li>
</ul>
<h3 id="爬泳">2 爬泳</h3>
<p>狗刨式游泳，比较简单，速度也不慢</p>
<ol type="1">
<li>先尝试仰泳。仰浮之后浅打水，手做狗刨式动作，要点：
<ul>
<li>手臂落入水中时保持笔直</li>
<li>手指紧闭，手掌放平</li>
</ul></li>
<li>尝试自由泳，背浮之后浅打水，手做狗刨式动作</li>
</ol>
<h3 id="踩水">3 踩水</h3>
<p>踩水相当于原地直立漂浮，两条腿像打蛋一样前后摆动，双手撑在水面上滑动保持平衡</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/swim-float-trend.png" /></p>
<h2 id="身体健康">身体健康</h2>
<p>蛙泳对于膝关节和髋关节压力较大</p>
<h2 id="练习">练习</h2>
<ul>
<li>换气</li>
<li>漂浮站立</li>
<li>重心控制</li>
<li>蹬边漂浮
<ul>
<li>练习一下控制前进方向</li>
</ul></li>
<li>蛙泳腿：收翻、蹬腿</li>
<li>蹬腿和换气的配合：2次蹬腿+1次换气
<ul>
<li>注意：低头马上蹬腿，不要再收腿，抬头不要抬太高（下巴贴着水面）</li>
<li>抬头的时候不要把同时收腿，当<strong>抬头到达顶点时开始收腿</strong>，那么到低头时就可以正好蹬腿了</li>
<li><strong>抬头的时候下半身下沉是很正常的</strong>，这时候赶紧低头蹬腿就浮起来了</li>
</ul></li>
</ul>
<h2 id="ref">Ref</h2>
<p><a href="https://www.wikihow.com/Swim">How to Swim</a></p>
]]></content>
      <categories>
        <category>Life</category>
        <category>Skills</category>
      </categories>
      <tags>
        <tag>skills</tag>
        <tag>swim</tag>
      </tags>
  </entry>
  <entry>
    <title>Install Hexo in New Env</title>
    <url>/2019/07/09/Life/Skills/install-blog/</url>
    <content><![CDATA[<h2 id="overview">Overview</h2>
<p>每次重装电脑都要重新安装Hexo的环境，步骤比较繁琐，所以记录下来方便之后再利用</p>
<a id="more"></a>
<h2 id="scripts">Scripts</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.安装Nodejs和npm</span></span><br><span class="line"><span class="comment"># Using Ubuntu</span></span><br><span class="line">curl -sL https://deb.nodesource.com/setup_12.x | sudo -E bash -</span><br><span class="line">sudo apt-get install -y nodejs</span><br><span class="line">npm -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.安装Hexo-cli</span></span><br><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.建站</span></span><br><span class="line"><span class="comment">#文件夹名称为blog</span></span><br><span class="line"><span class="comment">#hexo 版本为3.9</span></span><br><span class="line">hexo init blog</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line"><span class="comment">## 3.1 拷贝markdown源文件</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/hujunhan/blogsave.git <span class="built_in">source</span>/_posts/.</span><br><span class="line"><span class="comment">##测试</span></span><br><span class="line">hexo server</span><br><span class="line"></span><br><span class="line"><span class="comment">## 3.2 添加主题Next</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br><span class="line"></span><br><span class="line"><span class="comment">## 3.3 安装数学公式渲染器</span></span><br><span class="line">npm un hexo-renderer-marked --save</span><br><span class="line"><span class="comment">###安装pandoc，在ubuntu下</span></span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">wget https://github.com/jgm/pandoc/releases/download/2.7.3/pandoc-2.7.3-1-amd64.deb</span><br><span class="line">sudo dpkg -i pandoc-2.7.3-1-amd64.deb</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm i hexo-renderer-pandoc --save</span><br><span class="line"></span><br><span class="line"><span class="comment">## 3.4 安装一些其他的包</span></span><br><span class="line">npm uninstall hexo-generator-index --save</span><br><span class="line">npm i hexo-generator-index2 hexo-auto-category hexo-blog-encrypt hexo-deployer-git  hexo-generator-searchdb  --save</span><br><span class="line"></span><br><span class="line"><span class="comment">## 3.5 建立分类、tag页面</span></span><br><span class="line">hexo new page categories</span><br><span class="line">hexo new page tags</span><br><span class="line">sed -i <span class="string">&#x27;3a type: tags&#x27;</span> <span class="built_in">source</span>/tags/index.md</span><br><span class="line">sed -i <span class="string">&#x27;3a type: categories&#x27;</span> <span class="built_in">source</span>/categories/index.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.设置上传相关</span></span><br><span class="line">git config --global user.email <span class="string">&quot;hujh@zju.edu.cn&quot;</span></span><br><span class="line">git config --global user.name <span class="string">&quot;hujunhan&quot;</span></span><br><span class="line"><span class="comment">#在新环境中设置密钥</span></span><br><span class="line">ssh-keygen <span class="comment">#生成密钥</span></span><br><span class="line">cat /home/coding/.ssh/id_rsa.pub  <span class="comment">#读取密钥</span></span><br><span class="line"><span class="comment">#到Github中设置</span></span><br></pre></td></tr></table></figure>
<h2 id="deploy">Deploy</h2>
<h2 id="custom-domain">Custom Domain</h2>
<p>Prerequisite: A custom domain</p>
<p>设置步骤:</p>
<ol type="1">
<li>在域名购买商处设置一条解析规则, 记录设置为CNAME(用于github.io)或者A(用于IPv4地址)</li>
<li>在github的项目处设置Custom Domain, 这会在项目根目录下新建一个CNAME文件, 文件内容就是想要的Custom Domain.</li>
<li>因为每次Hexo deploy之后CNAME文件都会被删除, 所以需要在Hexo项目中加入CNAME文件来解决这个问题. 在blog/source/目录下新建CNAME文件, 文件内容是想要的Custom Domain.</li>
</ol>
]]></content>
      <categories>
        <category>Life</category>
        <category>Skills</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>安装Padavan固件</title>
    <url>/2020/01/19/Life/Skills/setup-padavan/</url>
    <content><![CDATA[<h2 id="intro">Intro</h2>
<p>Padavan是一个路由器固件，相比一般路由器的出厂固件来说会多很多功能，<del>尤其是SSR等功能</del>~</p>
<h2 id="步骤">步骤</h2>
<ol type="1">
<li><p>准备工作</p>
<ul>
<li><p>下载Breed</p>
<p>这是引导器，类似于GRUB，用它来引导Padavan系统</p></li>
<li><p>下载Padavan固件</p>
<p>根据使用的路由器硬件来选择相应的固件。本次使用的是极路由3</p>
<p>下载地址<a href="http://opt.cn2qq.com/padavan/">点这</a> 前缀RT-AC1200HP-GPIO-12-JI3，估计是根据华硕的AC1200改的</p>
<a id="more"></a></li>
<li><p>（OPTIONAL）开启路由器开发者模式</p>
<p>有些路由器需要特殊操作才能刷入固件，比如说极路由需要开发者模式，在<strong>插件市场</strong>的<strong>路由器信息</strong>板块下<strong>高级</strong>里申请</p>
<p>申请完安装开发者模式固件，提示信息：root系统的SSH端口号为1022，用户名: root，密码: 路由器后台密码；</p></li>
</ul></li>
<li><p>刷breed固件</p>
<ol type="1">
<li><p>传送breed固件到路由器上，使用scp命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp -p 1022 &#x2F;path&#x2F;to&#x2F;the&#x2F;breed-file.exe root@192.168.199.1:&#x2F;tmp</span><br></pre></td></tr></table></figure></li>
</ol></li>
</ol>
]]></content>
      <categories>
        <category>Life</category>
        <category>Skills</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Anki增强记忆</title>
    <url>/2019/07/18/Life/Skills/use-anki/</url>
    <content><![CDATA[<h2 id="简介">简介</h2>
<p>本文来源于<a href="http://www.ankichina.net/anki20.html">官方文档</a></p>
<p>Anki是一个自定义多功能的记忆方式，减少学习时间，提高学习容量。</p>
<p>基本的方式的“内容-未知”模式。背后用到的概念或者原理是</p>
<ul>
<li>主动召回测试：问一个问题并试图记住答案，这样学习更有效率</li>
<li>大脑的遗忘：大脑会迅速抛弃似乎不太有用的信息，解决方法就是复习</li>
<li>间隔重复：<strong>分散的复习</strong>比<strong>集中的复习</strong>更有效</li>
</ul>
<p>为什么使用Anki：免费、开源、全平台</p>
<a id="more"></a>
<h2 id="基本术语">基本术语</h2>
<ul>
<li><p>卡片：<strong>一问一答</strong>配对成卡片</p></li>
<li><p>牌组：一副牌组包含了<strong>一组卡片</strong>，每个牌组可以有不同的设置</p>
<ul>
<li>牌组下可以有分支，形成一个树状结构</li>
<li>用来放置<strong>较大门类的卡片</strong>，而不是第一课这样的小主题</li>
</ul></li>
<li><p>笔记</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">法语：Bonjour</span><br><span class="line">中文：你好</span><br><span class="line">页码：12</span><br></pre></td></tr></table></figure>
<p>比如一张<em>卡片</em>如上，这张卡片上有3条信息，法语、中文、页码，Anki中这些相关的信息称为<strong><em>笔记</em></strong>，每条信息称为<strong><em>字段</em></strong></p></li>
<li><p>卡片类型：</p>
<p>卡片类型就是一种模板，让Anki根据模板来创建卡片，我们提供模板和笔记，模板类似于下面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">问：&#123;&#123;法语&#125;&#125;</span><br><span class="line">答：&#123;&#123;英语&#125;&#125;&lt;br&gt;</span><br><span class="line">页码：&#123;&#123;页码&#125;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>笔记类型</p>
<p>为不同的材料创建不同的笔记类型，有标准类型，也可以自定义。</p>
<p>一些标准的类型</p>
<ul>
<li>Basic，正-反</li>
<li>Clonze，让选择文本并挖空</li>
</ul></li>
</ul>
<h2 id="添加资料">添加资料</h2>
<h3 id="下载他人共享的记忆库">下载他人共享的记忆库</h3>
<p><a href="https://ankiweb.net/shared/decks/">官方分享</a></p>
<p>但是学习他人的共享库效果并不够高，因为在学习一门复杂学科时，你可能不知道一些背景信息和解释，所以学习起来会感到很困难</p>
<h3 id="自制记忆库">自制记忆库</h3>
<p>创建自己的记忆库是学习一门复杂学科的最为有效的方式</p>
<ol type="1">
<li>添加卡片和笔记
<ul>
<li>我们往Anki添加笔记，Anki为我们创建卡片。</li>
<li>在<strong>同一笔记类型</strong>中，Anki检查<strong>第一字段</strong>的唯一性</li>
<li><strong>保持卡片简短，方便复习</strong></li>
<li><strong>不要记没有理解的</strong></li>
</ul></li>
</ol>
<h3 id="正确使用牌组">正确使用牌组</h3>
<p><strong>不要</strong>创建许多小的牌组，以保持你的内容有条理</p>
<p><strong>要</strong>使用<strong>标签</strong>或<strong>字段</strong>来分类内容</p>
]]></content>
      <categories>
        <category>Life</category>
        <category>Skills</category>
      </categories>
      <tags>
        <tag>anki</tag>
      </tags>
  </entry>
  <entry>
    <title>TED笔记</title>
    <url>/2020/02/23/Life/TED/TED-20200223/</url>
    <content><![CDATA[<h2 id="three-waves-of-robotics">1 Three Waves of Robotics</h2>
<p><a href="https://www.youtube.com/watch?v=qDVokm_XS3I">The three waves of robotics | Jeremy Wyatt | TEDxRoma</a></p>
<ol type="1">
<li><p>工业机器人</p>
<p>不确定很小, 主要是用机械和数学知识来完成重复劳动</p></li>
<li><p>无人驾驶</p>
<p>主要应用了机器学习, 机器视觉方面的能力, 还有从概率角度来提高机器人的智能程度</p>
<p>无人驾驶的硬件</p>
<ul>
<li>LIDAR: 成本太高, 甚至可能高过车本身</li>
<li>Camera: 成本低, 应用广泛</li>
</ul></li>
<li><p>认识 Cognition</p>
<p>进一步提高机器人的理解能力, 尤其是机器人在看到之前从来没有看到过的东西时, 泛化的理解能力显得更加重要</p></li>
</ol>
<h2 id="important-lesson-from-brain-scan">2 Important Lesson from Brain Scan</h2>
<p><a href="https://www.youtube.com/watch?v=esPRsT-lmw8">The most important lesson from 83,000 brain scans | Daniel Amen | TEDxOrangeCoast</a></p>
<p>大脑扫描(?)的<strong>形状</strong>说明了一些健康问题, 健康的大脑比较饱满, 患有一些疾病的人的大脑形状诡异</p>
<p><strong>精神疾病</strong>检测中并没有好好看过大脑(目前), 这是不正常的. 如果我们要分析大脑的精神情况,我们应该充分利用大脑成像, 来诊断和康复大脑</p>
<p>研究(Brain-Smart Program) 表明通过恰当的治疗, 我们可以提高大脑的正常程度</p>
]]></content>
      <tags>
        <tag>thinking</tag>
      </tags>
  </entry>
  <entry>
    <title>Why L1 Norm is Great</title>
    <url>/2020/03/11/Math/Algebra/L1-norm/</url>
    <content><![CDATA[<h2 id="application">Application</h2>
<h3 id="loss-function">Loss Function</h3>
<p><span class="math display">\[
\min _{\omega}\left\|y-\omega^{T} x\right\|_{1}
\]</span></p>
<h3 id="regularization">Regularization</h3>
<p><span class="math display">\[
\min _{x} f(x)+\|x\|_{1}
\]</span></p>
<h2 id="advantage">Advantage</h2>
<p>We can consider a easy <strong>2D</strong> case, and show why L1 norm is better than L2 norm</p>
<h3 id="loss-function-1">Loss Function</h3>
<figure>
<img src="https://qph.fs.quoracdn.net/main-qimg-ed279c02762abdb8c5fa3db3f200b823.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>L2 norm would strengthen the <strong>error</strong></p>
<h3 id="regularization-1">Regularization</h3>
<figure>
<img src="https://qph.fs.quoracdn.net/main-qimg-2c59dd58f22ace702f43499147ed8641.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>The minimum is always located at one of the <strong>corners</strong> (<strong>Red</strong>)</p>
<ul>
<li><p>A corner is described as having <strong>1 non-zero</strong> coordinate with the <strong>remaining coordinates being zero</strong></p>
<p>So L1 norm would lead to better sparisity</p></li>
</ul>
]]></content>
      <categories>
        <category>Math</category>
        <category>Algebra</category>
      </categories>
      <tags>
        <tag>algebra</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>Linear Algebra for Robotics</title>
    <url>/2019/01/08/Math/Algebra/Math-LinearAlgebra/</url>
    <content><![CDATA[<h2 id="the-big-picture">The Big Picture</h2>
<p>taught in <a href="https://www.youtube.com/watch?v=ggWYkes-n6E">MIT</a></p>
<h3 id="row-space-cat">Row Space = <span class="math inline">\(C(A^T)\)</span></h3>
<p>linear combination, fill the plane <span class="math display">\[
A=\left[\begin{array}{lll}
1 &amp; 2 &amp; 3 \\
4 &amp; 5 &amp; 6
\end{array}\right]
\]</span> Only 2 rows, so can’t fill the 3D, here we introduce null space</p>
<h3 id="null-space-na"><strong>Null Space</strong> = <span class="math inline">\(N(A)\)</span></h3>
<p><span class="math display">\[
A v=\left[\begin{array}{l}
0 \\
0
\end{array}\right]
\]</span></p>
<p>In this situation <span class="math display">\[
 v=\left[\begin{array}{l}
1 \\
-2 \\
1
\end{array}\right]
\]</span> is the null vector, prependicular line</p>
<h3 id="column-space-ca"><strong>Column Space</strong> = <span class="math inline">\(C(A)\)</span></h3>
<p>The column space the whole space</p>
<h3 id="left-space-nat">Left Space =<span class="math inline">\(N(A^T)\)</span></h3>
<h2 id="vectors">Vectors</h2>
<p><span class="math display">\[
\boldsymbol { v } = \left( v _ { x } , v _ { y } , v _ { z } \right)
\]</span></p>
<ul>
<li><p>length of a vector</p>
<ul>
<li>p-norm: <span class="math inline">\(\| v \| _ { p } = \left( \sum _ { i = 1 } ^ { n } \left| v _ { i } \right| ^ { p } \right) ^ { 1 / p }\)</span></li>
<li>Euclidean length: <span class="math inline">\(p=2\)</span></li>
</ul>
<a id="more"></a></li>
<li><p>operation</p>
<ul>
<li><p>dot product <span class="math display">\[
\boldsymbol { a } \cdot \boldsymbol { b } = \boldsymbol { b } \cdot \boldsymbol { a } = \boldsymbol { a } ^ { T } \boldsymbol { b } = \boldsymbol { b } ^ { T } \boldsymbol { a } = \sum _ { i = 1 } ^ { n } a _ { i } b _ { i } = \| a \| _ { 2 } \| b \| _ { 2 } \cos \theta
\]</span></p></li>
<li><p>cross product <span class="math display">\[
\boldsymbol { a } \times \boldsymbol { b } = - \boldsymbol { b } \times \boldsymbol { a } = \operatorname { det } \left( \begin{array} { l l l } { \hat { \boldsymbol { x } } } &amp; { \hat { \boldsymbol { y } } } &amp; { \hat { z } } \\ { a _ { 1 } } &amp; { a _ { 2 } } &amp; { a _ { 3 } } \\ { b _ { 1 } } &amp; { b _ { 1 } } &amp; { b _ { 3 } } \end{array} \right) = [ a ] _ { \mathbf { x } } \boldsymbol { b } = \| a \| _ { 2 } \| b \| _ { 2 } \sin \theta \hat { \boldsymbol { n } }
\]</span></p></li>
</ul></li>
</ul>
<h2 id="matrices">Matrices</h2>
<p><span class="math display">\[
A = \left( \begin{array} { c c c c } { a _ { 1,1 } } &amp; { a _ { 1,2 } } &amp; { \cdots } &amp; { a _ { 1 , n } } \\ { a _ { 2,1 } } &amp; { a _ { 2,2 } } &amp; { \cdots } &amp; { a _ { 2 , n } } \\ { \vdots } &amp; { \vdots } &amp; { \ddots } &amp; { } \\ { a _ { m , 1 } } &amp; { a _ { n , 2 } } &amp; { \cdots } &amp; { a _ { m , n } } \end{array} \right) , A \in \mathbb { R } ^ { m \times n }
\]</span></p>
<h3 id="square-matrices">Square Matrices</h3>
<ul>
<li><p>Inverse <span class="math inline">\(A A ^ { - 1 } = A ^ { - 1 } A = I _ { n \times n }\)</span></p></li>
<li><p>symmetric <span class="math inline">\(A = A ^ { T }\)</span></p></li>
<li><p>skew-symmetric <span class="math inline">\(A = - A ^ { T }\)</span> <span class="math display">\[
S = [ v ] _ { \times } = \left( \begin{array} { c c c } { 0 } &amp; { - v _ { z } } &amp; { v _ { y } } \\ { v _ { z } } &amp; { 0 } &amp; { - v _ { x } } \\ { - v _ { y } } &amp; { v _ { x } } &amp; { 0 } \end{array} \right)
\]</span></p></li>
<li><p>orthogonal: <span class="math inline">\(A ^ { - 1 } = A ^ { T }\)</span></p>
<ul>
<li>The product of two orthogonal matrices of the same size is also an orthogonal matrix</li>
<li>Group <span class="math inline">\(O(n)\)</span>
<ul>
<li>deteminant <span class="math inline">\(=+1 \to SO(n)\)</span></li>
</ul></li>
</ul></li>
<li><p>normal: <span class="math inline">\(A ^ { T } A = A A ^ { T }\)</span></p>
<ul>
<li>can be diagonalized by an orthogonal matrix</li>
<li>All <strong>symmetric</strong>, <strong>skew-symmetric</strong> and <strong>orthogonal</strong> matrices are normal matrices</li>
</ul></li>
<li><p>determinant: factor by which the transformation changes changes volumes in an n-dimensional space;</p>
<ul>
<li>equal to the product of the eigenvalues: <span class="math inline">\(\operatorname { det } ( A ) = \prod _ { i = 1 } ^ { n } \lambda _ { i }\)</span></li>
</ul></li>
<li><p>trace: <span class="math inline">\(\operatorname { tr } ( A ) = \sum _ { i = 1 } ^ { n } A _ { i i } = \sum _ { i = 1 } ^ { n } \lambda _ { i }\)</span></p>
<ul>
<li>sum of the diagonal elements</li>
<li>sum of the eigenvalues</li>
</ul></li>
</ul>
<h3 id="nonsquare-matrices">Nonsquare Matrices</h3>
]]></content>
      <categories>
        <category>Math</category>
        <category>Algebra</category>
      </categories>
      <tags>
        <tag>algebra</tag>
        <tag>math</tag>
        <tag>robotics</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数的几何理解</title>
    <url>/2019/07/07/Math/Algebra/algebra-geo/</url>
    <content><![CDATA[<h2 id="几何上理解矩阵作为一个变换函数">几何上理解<strong>矩阵</strong>：作为一个变换函数</h2>
<ul>
<li>列向量是对空间的<strong>基底</strong>的变换
<ul>
<li>有<span class="math inline">\(N\)</span>列代表着<strong>输入</strong>是<span class="math inline">\(N\)</span>个基向量</li>
<li>有<span class="math inline">\(M\)</span>行代表着<strong>输出</strong>是用<span class="math inline">\(M\)</span>个数代表的坐标</li>
</ul></li>
</ul>
<a id="more"></a>
<h2 id="几何上理解零空间">几何上理解零空间</h2>
<p>零空间、核，都描述的是一个东西</p>
<p>经过变换之后都变成零向量<span class="math inline">\(\hat{0}\)</span>上的空间</p>
<p>也可以说是，已知变换矩阵<span class="math inline">\(A\)</span>，求下面这个方程的解 <span class="math display">\[
A\hat{x}=\hat{0}
\]</span> ## 几何上理解非方阵：升维或降维</p>
<p>非方阵是<strong>升维</strong>或者<strong>降维</strong></p>
<ul>
<li>注意：升维后虽然在高维空间，但是<strong>张成的空间</strong>还是<strong>原来的维数</strong></li>
</ul>
<h2 id="几何上理解点积">几何上理解点积</h2>
<p>经典解释：配对相乘并相加</p>
<p>几何解释：投影长度</p>
<p>从几何角度也能方便理解为何点积与<strong>顺序无关</strong></p>
<hr />
<p>那么问题来了，怎么理解这两种不同的解释之间的关系呢？为什么相应的坐标相乘和投影是一样的呢？</p>
<p>问题的关键在于<strong>对偶性</strong>：我们需要将矩阵和向量联系在一起看 <span class="math display">\[
1 \times 2 \text { matrices } \longleftrightarrow 2 \mathrm{d}\text{ vectors}
\]</span></p>
<p><span class="math display">\[
\left[\begin{array}{ll}{1} &amp; {-2}\end{array}\right]\longleftrightarrow \left[\begin{array}{c}{1} \\ {-2}\end{array}\right]
\]</span></p>
<p>先介绍<strong>矩阵向量乘积</strong>：把向量<strong>放倒</strong>，<span class="math inline">\(1\times2\)</span>的矩阵就是一个降维的投影，降维成一条直线，在这条直线上取一个单位向量<span class="math inline">\(\hat{u}\)</span></p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/algebra-geo1.png" /></p>
<p>基底<span class="math inline">\(\hat{i}\)</span>的变换等于到<span class="math inline">\(\hat{u}\)</span>的投影，根据对称性，恰好等于<span class="math inline">\(\hat{u}\)</span>到<span class="math inline">\(\hat{i}\)</span>的投影，也就是<span class="math inline">\(u_x\)</span>，同理对另一个基底也是一样的，因此，变换后的<span class="math inline">\(\hat{i}，\hat{i}\)</span>的位置就是<span class="math inline">\(\left[\begin{array}{ll}{u_{x}} &amp; {u_{y}}\end{array}\right]\)</span></p>
<p>所以矩阵向量乘积可以理解为投影 <span class="math display">\[
\left[\begin{array}{ll}{u_{x}} &amp; {u_{y}}\end{array}\right]\left[\begin{array}{l}{x} \\ {y}\end{array}\right]=u_{x} \cdot x+u_{y} \cdot y
\]</span> 具体含义就是如图所示</p>
<p>那么<strong>点积</strong>，其实就是<em>矩阵向量乘积</em>的<strong>另一种定义</strong>，把矩阵竖起来 <span class="math display">\[
\left[\begin{array}{c}{u_{x}} \\ {u_{y}}\end{array}\right] \cdot\left[\begin{array}{l}{x} \\ {y}\end{array}\right]=u_{x} \cdot x+u_{y} \cdot y
\]</span></p>
<h2 id="几何上理解叉积">几何上理解叉积</h2>
<h3 id="常规解释">常规解释</h3>
<p><span class="math display">\[
\overrightarrow{\mathbf{v}} \times \overrightarrow{\mathbf{w}}=平行四边形的面积
\]</span></p>
<p>这里的平行四边形指的是以<span class="math inline">\(\overrightarrow{\mathbf{v}}\)</span>和<span class="math inline">\(\overrightarrow{\mathbf{w}}\)</span>为边的平行四边形</p>
<ul>
<li>如果v在w的右边，则面积是正的。反之面积为负</li>
<li><span class="math inline">\(\overrightarrow{\mathbf{v}} \times \overrightarrow{\mathbf{w}}=-\overrightarrow{\mathbf{w}} \times \overrightarrow{\mathbf{v}}\)</span></li>
</ul>
<hr />
<p>三维的叉积如何计算？ <span class="math display">\[
\left[\begin{array}{l}{v_{1}} \\ {v_{2}} \\ {v_{3}}\end{array}\right] \times\left[\begin{array}{l}{w_{1}} \\ {w_{2}} \\ {w_{3}}\end{array}\right]=\operatorname{det}\left(\left[\begin{array}{ccc}{\widehat{\imath}} &amp; {v_{1}} &amp; {w_{1}} \\ {\hat{\jmath}} &amp; {v_{2}} &amp; {w_{2}} \\ {\hat{k}} &amp; {v_{3}} &amp; {w_{3}}\end{array}\right]\right)
\]</span></p>
<ul>
<li>注意: 这里将向量写作矩阵的列，而教科书中大多数将向量写成矩阵的行。这两种做法没有差异，因为转置不改变行列式的值。这里只是为了更加直观</li>
<li>第一列的元素比较奇怪，在下一小节中解释</li>
</ul>
<h3 id="从线性变换解释">从线性变换解释</h3>
<p>类比二位的点积情况</p>
<p>把第一列的元素理解成<strong>变量</strong>，后面两列理解成<strong>底面积</strong>，这样就可以把叉积理解成一个<strong>体积</strong>(行列式的几何意义)</p>
<ol type="1">
<li>还是利用对偶性，定义一个从三维到一维的线性变换</li>
</ol>
<p>存在一个<span class="math inline">\(1\times3\)</span>的矩阵来表示这个变换</p>
<ol start="2" type="1">
<li><p>找到<strong>对偶向量</strong><span class="math inline">\(p\)</span></p>
<p>使得这个向量和一个向量点乘时，可以满足 <span class="math display">\[
\left[\begin{array}{l}{p_{1}} \\ {p_{2}} \\ {p_{3}}\end{array}\right] \cdot\left[\begin{array}{l}{x} \\ {y} \\ {z}\end{array}\right]=\operatorname{det}\left(\left[\begin{array}{ccc}{x} &amp; {v_{1}} &amp; {w_{1}} \\ {y} &amp; {v_{2}} &amp; {w_{2}} \\ {z} &amp; {v_{3}} &amp; {w_{3}}\end{array}\right]\right)
\]</span></p></li>
<li><p>说明这个对偶向量的意义就是叉积</p></li>
</ol>
<h2 id="几何上理解基变换">几何上理解基变换</h2>
<p>基变换是为了帮助我们理解如何在<strong>不同坐标系</strong>之间进行<strong>转化</strong></p>
<p>以B基底在A中的坐标作为列向量的矩阵可以看作一个变换，将B坐标系中的向量转换为A中表示。相反的操作只要求逆就可以了</p>
<p>那么为什么要进行基变换这样的操作呢？</p>
<ul>
<li>有的坐标系不标准，对其进行旋转、平移操作需要重新定义
<ul>
<li>因为我们平时定义的变换矩阵都是在标准的欧式坐标系下的，比如旋转90°：<span class="math inline">\(\left[\begin{array}{ll}{0} &amp; {-1} \\ {1} &amp; {0}\end{array}\right]\)</span>在其他坐标系下是不能使用的，为了能够复用这些矩阵，我们可以不标准的基底先转换成标准的基底，再转换回去</li>
</ul></li>
</ul>
<h2 id="几何上理解特征值与特征向量">几何上理解特征值与特征向量</h2>
<p>如果特征值为1，特征向量也可以理解为旋转的旋转轴 <span class="math display">\[
A \overrightarrow{\mathbf{v}}=\lambda \overrightarrow{\mathbf{v}}
\]</span></p>
<p><span class="math display">\[
(A-\lambda I) \overrightarrow{\mathbf{v}}=\overrightarrow{0}
\]</span></p>
<p>要找的是非零的v使得等式成立，回顾之前的定义，就需要前面的矩阵有零空间，秩要小于n，行列式等于0，因为只有这样，才能让v变成零向量。所以说，求解特征值、特征向量的过程就是求解<strong>有零空间的变换</strong>的过程</p>
<h2 id="几何上理解克莱姆法则">几何上理解克莱姆法则</h2>
<p>求解线性方程组</p>
<ul>
<li>高斯消元</li>
<li>克莱姆法则</li>
</ul>
<p>正交变换，也可以理解成旋转。两个向量的点积在正交变换之后保持不变</p>
<p>我们可以把不同轴上的坐标值理解成<strong>体积或者面积</strong>的高，底或底面积是由另外的几个<strong>单位基底</strong>构成的</p>
<p>为什么要把坐标值和面积或者体积联系起来呢？</p>
<ul>
<li><p>做矩阵变换后，面积会变化，但是面积伸缩的比例都等于给定的行列式。</p>
<p>也就是变换后的体积=原来的y乘变换的行列式 <span class="math display">\[
\text{Signed Area}=\operatorname{det}(A) y
\]</span></p>
<p><span class="math display">\[
y=\frac{\text { Area }}{\operatorname{det}(A)}
\]</span></p>
<p>式子中的Area只需要把变换A中相对应的“高”换成变换后的输出，然后求行列式，自然就等于变换之后的体积或面积了</p></li>
<li><p>因此，这种求y的方式本质上就是<strong>把y理解成单位体积或面积的倍数</strong></p></li>
</ul>
<h2 id="几何上理解抽象空间">几何上理解抽象空间</h2>
<p>行列式与特征向量的定义不依赖特定的坐标系</p>
<p>空间是什么？</p>
<p>函数其实是一种向量，因为向量和函数都有两种性质其实只有以下两个，或者说线性的严格定义</p>
<ul>
<li><p>可加性 <span class="math display">\[
(f+g)(x)=f(x)+g(x)
\]</span></p></li>
<li><p>成比例 <span class="math display">\[
(2 f)(x)=2 f(x)
\]</span></p></li>
</ul>
<p>对向量的<strong>线性变换</strong>也可以作用于函数上，对函数的线性变换也可叫做<strong>算子</strong></p>
<ul>
<li>求导是线性的
<ul>
<li><span class="math inline">\(\frac{d}{d x}\left(x^{3}+x^{2}\right)=\frac{d}{d x}\left(x^{3}\right)+\frac{d}{d x}\left(x^{2}\right)\)</span></li>
<li><span class="math inline">\(\frac{d}{d x}\left(4 x^{3}\right)=4 \frac{d}{d x}\left(x^{3}\right)\)</span></li>
</ul></li>
</ul>
<p>当前空间：全体多项式</p>
<ul>
<li><p>基函数 <span class="math inline">\(1,x^2,x^3....\)</span></p></li>
<li><p>求导的线性变换矩阵 <span class="math display">\[
\left[\begin{array}{ccccc}{0} &amp; {1} &amp; {0} &amp; {0} &amp; {\cdots} \\ {0} &amp; {0} &amp; {2} &amp; {0} &amp; {\cdots} \\ {0} &amp; {0} &amp; {0} &amp; {3} &amp; {\cdots} \\ {0} &amp; {0} &amp; {0} &amp; {0} &amp; {\cdots} \\ {\vdots} &amp; {\vdots} &amp; {\vdots} &amp; {\vdots} &amp; {\ddots}\end{array}\right]
\]</span></p></li>
<li><p>e.g</p>
<p>对一个函数求导</p>
<p><span class="math display">\[
\frac{d}{d x}\left(1 x^{3}+5 x^{2}+4 x+5\right)
\]</span></p>
<p><span class="math display">\[
\left[\begin{array}{ccccc}{0} &amp; {1} &amp; {0} &amp; {0} &amp; {\cdots} \\ {0} &amp; {0} &amp; {2} &amp; {0} &amp; {\cdots} \\ {0} &amp; {0} &amp; {0} &amp; {3} &amp; {\cdots} \\ {0} &amp; {0} &amp; {0} &amp; {0} &amp; {\cdots} \\ {\vdots} &amp; {\vdots} &amp; {\vdots} &amp; {\vdots} &amp; {\ddots}\end{array}\right]\left[\begin{array}{c}{5} \\ {4} \\ {5} \\ {1} \\ {\vdots}\end{array}\right]=\left[\begin{array}{c}{1 \cdot 4} \\ {2 \cdot 5} \\ {3 \cdot 1} \\ {0} \\ {\vdots}\end{array}\right]
\]</span> 结果就是 <span class="math display">\[
\frac{d}{d x}\left(1 x^{3}+5 x^{2}+4 x+5\right)=3 x^{2}+10 x+4
\]</span></p></li>
</ul>
<hr />
<p>所以数学家将向量的概念抽象出来，抽象成8条规则，只要满足这8条规则，就是向量空间了</p>
<p>这样的好处是</p>
<ul>
<li>相当于编程时的接口，大家只要满足一定规则就可以利用</li>
<li>方便数学家抽象地研究向量空间，任何新的发现都可以运用到其他向量空间中</li>
</ul>
]]></content>
      <categories>
        <category>Math</category>
        <category>Algebra</category>
      </categories>
      <tags>
        <tag>algebra</tag>
        <tag>math</tag>
        <tag>robotics</tag>
      </tags>
  </entry>
  <entry>
    <title>Practical Linear Algebra -- Overview</title>
    <url>/2020/03/09/Math/Algebra/practical-algebra-0-intro/</url>
    <content><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Top-down teaching method</p>
<p>Why study numerical linear algebra?</p>
<ul>
<li>important in computer science</li>
</ul>
<p>4 things need consideration</p>
<ul>
<li>memory</li>
<li>speed</li>
<li>accuracy</li>
<li>scalability</li>
</ul>
<p>That means there will be trade-off while designing</p>
<a id="more"></a>
<h2 id="matrix-computations">Matrix Computations</h2>
<p>mainly 2 type of computation</p>
<ul>
<li><p>Matrix products</p>
<ul>
<li><p>Matrix-Vector Products: e.g. <strong>Markov Chain</strong>, from one state to another state, there will be a probability matrix</p></li>
<li><p>Matrix-Matrix Products: e.g. calculate different <strong>situation</strong></p>
<ul>
<li><p>images can be <strong>represented</strong> by matrices</p></li>
<li><p><strong>convolution</strong></p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/20200319175825.png" alt="image-20200309154943071" /><figcaption aria-hidden="true">image-20200309154943071</figcaption>
</figure>
<p>in matrix multiplication viewpoint</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/20200319175832.png" alt="image-20200309155010166" /><figcaption aria-hidden="true">image-20200309155010166</figcaption>
</figure></li>
</ul></li>
</ul></li>
<li><p>Matrix decompositions</p>
<ul>
<li>Topic modeling: SVD, QR</li>
<li>Background removal: robust PCA, SVD</li>
<li>PageRank algorithm</li>
</ul></li>
</ul>
<h2 id="accuracy-how-computer-store-numbers">Accuracy — How Computer Store <strong>Numbers</strong></h2>
<p>Why accuracy is a problem?</p>
<ul>
<li>Since computer store numbers <strong>finite</strong> and <strong>discrete</strong></li>
<li>Big problem while repeating an operation since each operation could <strong>multiply</strong> the error</li>
</ul>
<p>Floats and doubles are <strong>not equidistant</strong></p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/20200319175839.png" alt="image-20200309160331880" /><figcaption aria-hidden="true">image-20200309160331880</figcaption>
</figure>
<p>Machine Epsilon: Half the distance between 1 and the next larger number</p>
<ul>
<li>defined by IEEE standards</li>
<li><span class="math inline">\(\varepsilon_{\text {machine}}=2^{-53} \approx 1.11 \times 10^{-16}\)</span></li>
</ul>
<h3 id="conditioning-and-stability">Conditioning and Stability</h3>
<p><strong>We need to know how small change in input will influence the output</strong></p>
<blockquote>
<p><strong>"A stable algorithm gives nearly the right answer to nearly the right question."</strong> --Trefethen</p>
<p>since we can not tell the computer the “right” number</p>
</blockquote>
<p><strong>Conditioning</strong>: perturbation behavior of a mathematical problem (e.g. least squares)</p>
<p><strong>Stability</strong>: perturbation behavior of an algorithm used to solve that problem on a computer (e.g. least squares algorithms, householder, back substitution, gaussian elimination)</p>
<ul>
<li>e.g. while calculating eigen value, a <strong>small</strong> change in the input will get totally wrong answer</li>
</ul>
<h3 id="approximation-accuracy">Approximation accuracy</h3>
<p>Most of the time, we just <strong>don’t need</strong> to do highly matrix computations at scale,</p>
<ul>
<li>machine learning, more <strong>efficient</strong></li>
<li>Bloom filter algorithm, <strong>AdBlock</strong>, would give false positives, <strong>reduction</strong> in <strong>memory</strong> use of thousands of times</li>
</ul>
<h2 id="memory-use-how-computer-store-matrices">Memory Use – How Computer Store <strong>Matrices</strong></h2>
<p>A key way to save memory: just store the <strong>non-zero elements</strong>, this is called <strong>sparse</strong> storage. This is suited to sparse matrices that most elements are zero</p>
<p>The opposite, is <strong>dense</strong> storage, store every elements</p>
<h2 id="speed-how-computer-compute-matrices">Speed – How Computer Compute Matrices</h2>
<p>Some key points to be considerd</p>
<ul>
<li>Computational complexity: the big O notation, <strong>algorithm</strong></li>
<li>Vectorization: Modern GPU and CPU, use low-level APIs: BLAS, LAPACK, <strong>hardware</strong></li>
<li>Scaling to multiple cores and nodes</li>
<li>Locality: move data around, <strong>hardware</strong></li>
</ul>
<h2 id="scalability">Scalability</h2>
<p>Use multiple core and machine</p>
]]></content>
      <categories>
        <category>Math</category>
        <category>Algebra</category>
      </categories>
      <tags>
        <tag>algebra</tag>
        <tag>math</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Practical Linear Algebra -- NFM &amp; SVD</title>
    <url>/2020/03/10/Math/Algebra/practical-algebra-1-SVD/</url>
    <content><![CDATA[<h2 id="motivation">Motivation</h2>
<p>We want to decompose a matrix using an outer <strong>product of two vectors</strong></p>
<h2 id="svd-singular-value-decomposition">SVD Singular Value Decomposition</h2>
<h3 id="motivation-1">Motivation</h3>
<p>we except the topics to be <strong>orthogonal</strong>, so it can express most information</p>
<h3 id="idea">Idea</h3>
<figure>
<img src="https://nbviewer.jupyter.org/github/fastai/numerical-linear-algebra/blob/master/nbs/images/svd_fb.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<a id="more"></a>
<h3 id="application">Application</h3>
<ul>
<li>recommendation</li>
<li>calculate pseudoinverse</li>
<li>data compression</li>
<li>PCA</li>
</ul>
<h2 id="nmf-non-negative-matrix-factorization">NMF Non-negative Matrix Factorization</h2>
<h3 id="motivation-2">Motivation</h3>
<p>It’s hard to explain face image while using PCA since there is <strong>negative</strong> value</p>
<p>So this method avoid negative value</p>
<p>Benefits: fast and easy to use</p>
<h3 id="idea-1">Idea</h3>
<p>Deprecate orthogonal idea, another idea: constrain them to be non-negative</p>
<p>Goal: Do decomposition <span class="math display">\[
V \approx W H
\]</span> Approach: add <strong>penalty</strong> to punish negative elements, that means the result will be just a <strong>approximation</strong>, and <strong>not-unique</strong></p>
<p>Using SGD(Stochastic Gradient Descent), add</p>
<h3 id="application-1">Application</h3>
<ul>
<li>Face decomposition</li>
<li>bioinformatics</li>
<li>Topic modeling</li>
</ul>
<h2 id="faster-svd">Faster SVD</h2>
<h3 id="motivation-3">Motivation</h3>
<ul>
<li>Normal SVD is pretty <strong>slow</strong>, we need to speed it up</li>
<li>Data are often <strong>missing</strong> or <strong>inaccurate</strong></li>
<li>Take advantage if <strong>GPUs</strong></li>
</ul>
<p>We are just interested in the <strong>largest</strong> singular values</p>
<p>So introduce randomized algorithms that</p>
<ul>
<li>more stable</li>
<li>needed matrix-vector products can be done in parallel</li>
<li>performance guaranteed</li>
</ul>
<h3 id="idea-2">Idea</h3>
<p>Use a smaller matrix</p>
<ol type="1">
<li><p>Before: calculate SVD of <span class="math inline">\(A(m\times n)\)</span></p></li>
<li><p>Basic <strong>Math</strong>: <strong>Johnson-Lindenstrauss Lemma</strong></p>
<blockquote>
<p>a small set of points in a high-dimensional space can be embedded into a space of much lower dimension in such a way that distances between the points are nearly preserved.</p>
</blockquote></li>
<li><p>After: calculate SCD of <span class="math inline">\(B(m,r)=AQ\space,\space r&lt;&lt;n\)</span></p></li>
</ol>
<h3 id="computation">Computation</h3>
<ol type="1">
<li><p>Find an approximation <span class="math inline">\(Q\)</span> to the <strong>range</strong> of <span class="math inline">\(A\)</span>, here range means linear combination.</p>
<p>That means <span class="math inline">\(Q\)</span> has similar column space with <span class="math inline">\(A\)</span> but fewer columns <span class="math display">\[
A\approx Q Q^tA
\]</span></p></li>
<li><p>Construct <span class="math inline">\(B=Q^TA\)</span>, which is small</p></li>
<li><p>Compute the SVD of <span class="math inline">\(B=S \Sigma V^{T}\)</span></p></li>
<li><p>Since <span class="math inline">\(A\approx Q Q^T A=QB=QS \Sigma V^{T}\)</span></p>
<p>if we set <span class="math inline">\(U=QS\)</span>, we can get <span class="math display">\[
A\approx U\Sigma V^T
\]</span></p></li>
<li><p>Done!</p></li>
</ol>
<p>But how do we get <span class="math inline">\(Q\)</span> in step 1?</p>
<ol type="1">
<li>Take a bunch of random vector <span class="math inline">\(w_i\)</span> and form a matrix <span class="math inline">\(W\)</span>, in this way ,<span class="math inline">\(AW\)</span> represent the space that column of <span class="math inline">\(A\)</span> can <strong>span</strong>.</li>
<li>Calculate <span class="math inline">\(AW=QR\)</span>, where <span class="math inline">\(Q\)</span> form an orthonormal basis for <span class="math inline">\(Aw\)</span></li>
</ol>
]]></content>
      <categories>
        <category>Math</category>
        <category>Algebra</category>
      </categories>
      <tags>
        <tag>algebra</tag>
        <tag>math</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Practical Linear Algebra -- Robust PCA</title>
    <url>/2020/03/10/Math/Algebra/practical-algebra-2-PCA/</url>
    <content><![CDATA[<h2 id="why-pca">Why PCA?</h2>
<p>We often deal with high-dimentional data sets. Using PCA is handy for eliminating dimenstions</p>
<h2 id="application-background-removal">Application: Background Removal</h2>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/20200319175701.png" alt="img" style="zoom:150%;" /></p>
<p>There is a video, we want to remove the background</p>
<h3 id="load-the-data">Load the Data</h3>
<p>We can scale the image to <span class="math inline">\(60\times 80\)</span>, and stack the image to a tall column <span class="math inline">\(1\times 4800\)</span></p>
<p>If the video contains <span class="math inline">\(11300\)</span> images, then the video can be represented as a <span class="math inline">\(11300\times 4800\)</span> matrix</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/20200319175717.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="first-attempt-svd">First Attempt: SVD</h2>
<p>Preserver only 2 feature</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> decomposition</span><br><span class="line">u, s, v = decomposition.randomized_svd(M, <span class="number">2</span>)</span><br><span class="line">u.shape, s.shape, v.shape</span><br><span class="line"><span class="comment">#((4800, 2), (2,), (2, 11300))</span></span><br><span class="line">low_rank = u @ np.diag(s) @ v</span><br><span class="line">low_rank.shape</span><br><span class="line"><span class="comment">#(4800, 11300)</span></span><br><span class="line">plt.imshow(low_rank, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.imshow(np.reshape(low_rank[:,<span class="number">140</span>], dims), cmap=<span class="string">&#x27;gray&#x27;</span>);<span class="comment">#get one image from the video</span></span><br></pre></td></tr></table></figure>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/20200319175724.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/20200319175731.png" alt="img" style="zoom:150%;" /></p>
<p>Great, we got a good result</p>
<h2 id="pca">PCA</h2>
<ul>
<li><p>Classical PCA (SVD) : seeks the best rank-<span class="math inline">\(k\)</span> estiamte <span class="math inline">\(L\)</span> (Low Rank) of <span class="math inline">\(M\)</span>, this is what we do <strong>above</strong></p>
<ul>
<li>Minimizing <span class="math inline">\(||M-L||\)</span></li>
<li>Can <strong>only</strong> handle small noise</li>
</ul></li>
<li><p>Robust PCA, factors a matrix into the sum of 2 matrices, <span class="math inline">\(M=L+S\)</span>, <strong>L</strong>ow rank + <strong>S</strong>parse</p>
<ul>
<li>Low rank: there is a lot of <strong>redundant</strong> information, in this case, is the background</li>
<li>Sparse: without the background, only people in the image, that means most of the elements in <span class="math inline">\(S\)</span> would be <strong>zero</strong></li>
</ul></li>
</ul>
<h3 id="robust-pca">Robust PCA</h3>
<p>Goal: <span class="math display">\[
minimize ||L\|_{*}+\lambda\|S\|_{1} \\
subject\ to \ L+S=M
\]</span></p>
<ul>
<li><span class="math inline">\(||\space||_1\)</span> is the <strong>L1 norm</strong>, for a matrix, L1 norm equals to the maximum absolute column norm
<ul>
<li><strong>Why</strong> L1 norm? we need <span class="math inline">\(S\)</span> to be sparse, and L1 norm would lead to <strong>better sparsity</strong>
<ul>
<li>Why L1 lead to better sparsity? See another blog..</li>
</ul></li>
</ul></li>
<li><span class="math inline">\(||\space||_*\)</span> is the <strong>nuclear norm</strong>, is the L1 norm of the singular values, minimize the result will lead to low rank</li>
</ul>
]]></content>
      <categories>
        <category>Math</category>
        <category>Algebra</category>
      </categories>
      <tags>
        <tag>algebra</tag>
        <tag>math</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Practical Linear Algebra -- LU Factorization</title>
    <url>/2020/03/12/Math/Algebra/practical-algebra-3-LU/</url>
    <content><![CDATA[<h2 id="motivation">Motivation</h2>
<p>While implementing <em>Randomized SVD</em>, we used LU factorization, that is factors a matrix into the product of a <strong>lower triangular</strong> matrix and an <strong>upper triangular</strong> matrix. <span class="math display">\[
A=LU
\]</span> Why LU is useful?</p>
<p>We can solve <span class="math inline">\(Ax=b\)</span> problem faster</p>
<ol type="1">
<li>find <span class="math inline">\(A=LU\)</span></li>
<li>solve <span class="math inline">\(Ly=b\)</span></li>
<li>solve <span class="math inline">\(Ux=y\)</span></li>
</ol>
<h2 id="calculation">Calculation</h2>
<p><span class="math display">\[
A=\left(\begin{array}{cccc}
1 &amp; -2 &amp; -2 &amp; -3 \\
3 &amp; -9 &amp; 0 &amp; -9 \\
-1 &amp; 2 &amp; 4 &amp; 7 \\
-3 &amp; -6 &amp; 26 &amp; 2
\end{array}\right)
\]</span></p>
<p>Using <strong>Gaussian Elimination</strong>, after Gaussian Elimination, we will get a <strong>upper triangular matrix</strong>, so we can regard the <strong>combination of eliminiation operation</strong> is a <strong>lower triangular matrix</strong> that is <span class="math inline">\(L_{m-1} \ldots L_{2} L_{1} A=U\)</span> <span class="math display">\[
L U=\left[\begin{array}{cccc}
1 &amp; 0 &amp; 0 &amp; 0 \\
3 &amp; 1 &amp; 0 &amp; 0 \\
-1 &amp; 0 &amp; 1 &amp; 0 \\
-3 &amp; 4 &amp; -2 &amp; 1
\end{array}\right] \cdot\left[\begin{array}{cccc}
1 &amp; -2 &amp; -2 &amp; -3 \\
0 &amp; -3 &amp; 6 &amp; 0 \\
0 &amp; 0 &amp; 2 &amp; 4 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{array}\right]
\]</span></p>
<h3 id="partial-pivoting">Partial Pivoting</h3>
<p>Note: LU factorization is stable, but not <em>backward</em> stable <span class="math display">\[
A=\left[\begin{array}{cc}
10^{-20} &amp; 1 \\
1 &amp; 1
\end{array}\right]
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L1, U1 = GaussianElimination(A)</span><br><span class="line">L2, U2 = LU(A)</span><br><span class="line">np.allclose(L1, L2)</span><br><span class="line"><span class="comment">#true</span></span><br><span class="line">np.allclose(U1, U2)</span><br><span class="line"><span class="comment">#true</span></span><br><span class="line">np.allclose(A, L2 @ U2)</span><br><span class="line"><span class="comment">#false...means not backward stable</span></span><br></pre></td></tr></table></figure>
<p>we can get more stable answer by switching the order of the rows <span class="math display">\[
A=\left[\begin{array}{cc}
1 &amp; 1 \\
10^{-20} &amp; 1
\end{array}\right]
\]</span> How? <strong>Multiplying by a permutation matrix P</strong> <span class="math display">\[
\left[\begin{array}{ll}
0 &amp; 1 \\
1 &amp; 0
\end{array}\right] \cdot\left[\begin{array}{cc}
10^{-20} &amp; 1 \\
1 &amp; 1
\end{array}\right]=\left[\begin{array}{cc}
1 &amp; 1 \\
10^{-20} &amp; 1
\end{array}\right]\\
PA=A&#39;
\]</span> At each step, choose the largest value in column k, and move that row to be row k.</p>
]]></content>
      <categories>
        <category>Math</category>
        <category>Algebra</category>
      </categories>
      <tags>
        <tag>algebra</tag>
        <tag>math</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Practical Linear Algebra -- Sparse Matrices</title>
    <url>/2020/03/13/Math/Algebra/practical-algebra-4-Sparse/</url>
    <content><![CDATA[<h2 id="introduction">Introduction</h2>
<p><em>In practice, most large matrices are sparse — almost all entries are zeros.</em></p>
<p>e.g. web link, word occurrence</p>
<p>Problem</p>
<ul>
<li><strong>Space</strong>: require a lot of memory</li>
<li><strong>Time</strong>: a waste of time since most of the operations involve zero</li>
</ul>
<h3 id="when">When</h3>
<p>In practice, we will get a sparse matrix since we choose specific <strong>encoding schemes</strong></p>
<ul>
<li>one-hot encoding, binary vectors, in recommender system, computer vision</li>
<li>count encoding, frequency, in NLP</li>
<li>TF-IDF, normalized frequency</li>
</ul>
<h3 id="solution">Solution</h3>
<p>Use an alternate data structure: only store data of non-zero values</p>
<ul>
<li><strong>Old</strong> data structure: Row and Column index mapped to a value</li>
<li><strong>New</strong> data structure: Compressed Sparse Row. Represent matrix using 3 one-dimensional arrays
<ul>
<li>row</li>
<li>colunm</li>
<li>value</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>Math</category>
        <category>Algebra</category>
      </categories>
      <tags>
        <tag>algebra</tag>
        <tag>math</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 ICM D</title>
    <url>/2019/01/25/Math/Modeling/2019ICM/</url>
    <content><![CDATA[<h2 id="problem">Problem</h2>
<p><strong>Goal</strong>: design <strong>evacuation plans</strong> at the Louvre in Paris * Quic * Safely</p>
<p><strong>Difficuties</strong>: <strong>Diversity</strong> of visitors</p>
<ul>
<li>Language</li>
<li>Group</li>
<li>Disabled</li>
</ul>
<p><strong>Basic information</strong>:</p>
<ul>
<li>5 floors, 2 of which are underground</li>
<li>Entrance
<ul>
<li>pyramid: main and most used</li>
<li>Passage Richelieu</li>
<li>Carrousel du Louvre</li>
<li>Portes Des Lions</li>
</ul></li>
<li>Some other exit points, but may cause security problem</li>
</ul>
<p><strong>What to do</strong>:</p>
<ul>
<li>Design a <em>adaptable</em> model</li>
<li>Indentify potential <em>bottlenecks</em></li>
<li><em>Validate</em> your model</li>
<li>How to <em>implement</em> it</li>
</ul>
]]></content>
      <categories>
        <category>Math</category>
        <category>Modeling</category>
      </categories>
      <tags>
        <tag>model</tag>
      </tags>
  </entry>
  <entry>
    <title>First Step to Optimization</title>
    <url>/2019/09/07/Math/Modeling/Optimization-tutorial/</url>
    <content><![CDATA[<h2 id="overview">Overview</h2>
<h3 id="what-is-an-optimization-problem">What is an optimization problem</h3>
<p>Goal: Find the <em>best</em> solution to a problem out of a large set of possible solutions</p>
<p>Elements:</p>
<ul>
<li><p>objective: the goal, the value you want to optimize</p>
<p>We need to define a function to calculates the value</p></li>
<li><p>constrains: the restrictions on the set of possible solution</p></li>
</ul>
<h2 id="linear-optimization">Linear Optimization</h2>
<p>Computing the best solution to a problem modeled as a set of linear relationships</p>
<p>These problems often arise in engineering disciplines</p>
<a id="more"></a>
<h3 id="example">Example</h3>
<p>Goal: minimize <span class="math inline">\(3x+4y\)</span> with following constrains</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><em>x</em> + 2<em>y</em></th>
<th style="text-align: center;">≤</th>
<th style="text-align: center;">14</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">3<em>x</em> – <em>y</em></td>
<td style="text-align: center;">≥</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;"><em>x</em> – <em>y</em></td>
<td style="text-align: center;">≤</td>
<td style="text-align: center;">2</td>
</tr>
</tbody>
</table>
<h2 id="constraint-optimization">Constraint Optimization</h2>
<p>Identifying feasible solutions out of a large set of candidates, where problem can be modeled in terms of <strong>arbitrary constrains</strong></p>
<p>This optimization <strong>focus on the constraints and variable</strong>s rather than the objective function. It just want to find out a <strong>feasible solution</strong>, not a optimal solution</p>
<h3 id="example-1-employee-scheduling">Example 1 Employee Scheduling</h3>
<p>Problem: employee scheduling</p>
<p>Background: create weekly schedules for their employees.</p>
<blockquote>
<p>e.g. a company runs three 8-hour shifts per day and assigns three of its four employees to different shifts each day, while giving the fourth the day off</p>
<p>possible schedules: <span class="math inline">\(4!=24\)</span></p>
<p>possible schedules in a week: <span class="math inline">\(24^7\)</span></p>
<p>So we need to narrow down the solution space</p>
</blockquote>
<h2 id="routing">Routing</h2>
<p>Find efficient paths for transporting items through a complex network.</p>
<p>The network usually represented by a graph like the one below</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/opti-routing.png" /></p>
<p>There are mainly 2 types of routing problem:</p>
<ul>
<li><p>node-routing: the goal is to visit the node</p></li>
<li><p>arc-routing: the goal is to visit the arc</p></li>
</ul>
<p>e.g.1 Google Map’s Street view: Google need to construct the shortest route for the team to reduce the travel length. This is a <strong>arc-routing problem</strong></p>
<p>e.g.2 A company needs to deliver packages to various locations using a fleet of vehicles. Each arc has a weight, the problem is to find a set of paths that <strong>include every destination while minimizing the total cost</strong>. This is a node-routing problem</p>
<p>TODO: ADD MORE DETAILS</p>
<h2 id="pack">Pack</h2>
<p>The goal is to find the best way to pack a set of items of given sizes into containers with fixed capacities</p>
<p>There are mainly 2 packing problems:</p>
<ul>
<li><p>Knapack problems</p>
<p>multiple containers (called knapack), items have <em>values</em> as well as <em>sizes</em>,</p>
<p>goal: maximize the total value</p></li>
<li><p>bin packing</p>
<p>multiple containers (called bin) with equal capacity.</p>
<p>goal: minimizing the number of bins</p></li>
</ul>
<h2 id="assignment-problem">Assignment Problem</h2>
<p>A group of workers has to perform a set of tasks. For each worker and task, there is a fixed cost for that worker to perform the task. The goal is to minimize the total cost.</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/opti-assi.png" /></p>
<p>And there will be a cost matrix</p>
<h2 id="scheduling">Scheduling</h2>
<h3 id="the-job-shop-problem">The Job Shop Problem</h3>
<p>Multiple jobs are processed on several machines. Each job consists of a sequence of tasks, which must be performed in a given order, and each task must be processed on a specific machine.</p>
<p>Several constraints :</p>
<ul>
<li>No task for a job can be started until the previous task for that job is completed.</li>
<li>A machine can only work on one task one time</li>
<li>A task, once started, must run to completion</li>
</ul>
<p>For each task, it can be labeled by a pair of numbers <span class="math inline">\((m,p)\)</span> where <span class="math inline">\(m\)</span> is the number of the machine that the task must processed and <span class="math inline">\(p\)</span> is the processing time of the task</p>
<p>e.g. in a factory, there are 3 jobs</p>
<ul>
<li>job 0 = [(0, 3), (1, 2), (2, 2)]</li>
<li>job 1 = [(0, 2), (2, 1), (1, 4)]</li>
<li>job 2 = [(1, 4), (2, 3)]</li>
</ul>
<p>and the solution can be illustrate like this</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/opti-jsp.png" /></p>
]]></content>
      <categories>
        <category>Math</category>
        <category>Modeling</category>
      </categories>
      <tags>
        <tag>model</tag>
      </tags>
  </entry>
  <entry>
    <title>Fermat&#39;s Principle</title>
    <url>/2019/08/12/Math/Physics/fermats-principle/</url>
    <content><![CDATA[<h2 id="overview">1 Overview</h2>
<blockquote>
<p><strong>Fermat's principle</strong>, or the <strong>principle of least time</strong>, named after French mathematician <a href="https://en.wikipedia.org/wiki/Pierre_de_Fermat">Pierre de Fermat</a>, is the principle that the path taken between two points by a ray of light is the path that can be traversed in the least time.</p>
</blockquote>
<p>##2 Solve with Calculus</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/fermat-calculus.png" /></p>
<h2 id="solve-with-mechanics">3 Solve with Mechanics</h2>
<p>The main idea: Nature will make the system in some state that has <strong>least energy</strong>.</p>
<p>So we can just find out the point where the <strong>forces balanced</strong></p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/fermat-mechanics.png" /></p>
]]></content>
      <categories>
        <category>Math</category>
        <category>Physics</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>Brachistochrone Curve</title>
    <url>/2019/08/12/Math/Physics/quickest-down/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>最速降线或捷线问题是历史上第一个出现的变分法问题，也是变分法发展的一个标志。此问题是1696年约翰·伯努利在写给他哥哥雅克布·伯努利的一封公开信中提出的。问题的提法是：设A和B是铅直平面上不在同一铅直线上的两点，在所有连接A和B的平面曲线中，求出一条曲线，使仅受重力作用且初速度为零的质点从A点到B点沿这条曲线运动时所需时间最短</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/Brachistochrone.gif" /></p>
<h2 id="物理学角度的求解">物理学角度的求解</h2>
<ol type="1">
<li><p>由于能量守恒，所以粒子的速度正比于到顶端的距离的平方根</p></li>
<li><p>所以可以把粒子看成光子，根据<strong>费马原理</strong>，用时最短的路径可以用<strong>斯涅尔定理</strong>解出</p>
<p>所以也可以这样描述这条曲线：处处满足斯涅尔定理 <span class="math display">\[
\frac{sin(\theta)}{\sqrt{y}}=constant
\]</span></p></li>
<li><p>上述的曲线就是旋轮线</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/quickest-down-how.png" /></p></li>
</ol>
]]></content>
      <categories>
        <category>Math</category>
        <category>Physics</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>参数估计简述</title>
    <url>/2019/07/14/Math/Statistics/para-esti/</url>
    <content><![CDATA[<h2 id="基本概念">基本概念</h2>
<ul>
<li>估计量：用来估计总体参数的统计量
<ul>
<li>求法：矩估计、最大似然估计法</li>
</ul></li>
<li>估计值：根据一个样本算出来的统计量的值</li>
<li>点估计：用样本统计量<span class="math inline">\(\hat{\theta}\)</span>的某个取值作为总体参数<span class="math inline">\(\theta\)</span>的估计值</li>
<li>区间估计：在<strong>点估计的基础</strong>上，给出总体参数的一个<strong>区间范围</strong></li>
<li>置信区间：在区间估计中，由样本统计量构造的总体参数的估计区间</li>
<li>对参数估计的评价
<ul>
<li>无偏，<span class="math inline">\(E(\hat{\theta})=\theta\)</span></li>
<li>更有效，<span class="math inline">\(D(\hat{\theta_1})&lt;D(\hat{\theta_2})\)</span></li>
<li>一致性，<span class="math inline">\(\hat{\theta}\)</span>依概率收敛于<span class="math inline">\(\theta\)</span></li>
</ul></li>
</ul>
<h2 id="矩估计">矩估计</h2>
<blockquote>
<p>矩：所考虑的随机变量的幂的期望值</p>
<ul>
<li><p>一阶矩：期望，<span class="math inline">\(E(x)=\int_{-\infty}^{\infty} x f(x) d x\)</span></p></li>
<li><p>二阶矩：方差，<span class="math inline">\(\operatorname{Var}(x)=\int_{-\infty}^{\infty}[x-E(x)]^{2} f(x) d x\)</span></p></li>
<li><p>三阶矩：偏态，<span class="math inline">\(S(x)=\int_{-\infty}^{\infty}[x-E(x)]^{3} f(x) d x\)</span></p></li>
<li><p>样本矩：<span class="math inline">\(\mu_{n}^{\prime} \approx \frac{1}{N} \sum_{i=1}^{N} X_{i}^{n}\)</span></p>
<p>通过这种方法求矩不需要先估计其概率分布</p></li>
</ul>
</blockquote>
<p>用样本矩估计相应的总体矩，用样本矩的函数聚集总体矩相应的函数</p>
<blockquote>
<p>e.g. 已知分布函数<span class="math inline">\(f(x;\theta)\)</span>，和一些样本<span class="math inline">\(X_i\)</span></p>
<ol type="1">
<li>求出<span class="math inline">\(f\)</span>的期望，其中有<span class="math inline">\(\theta\)</span></li>
<li>求出样本的期望，是具体的数字或者<span class="math inline">\(X_i\)</span>中的信息</li>
<li>用那些信息表示<span class="math inline">\(\theta\)</span></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>Math</category>
        <category>Statistics</category>
      </categories>
      <tags>
        <tag>statistics</tag>
      </tags>
  </entry>
  <entry>
    <title>显著性检验简述</title>
    <url>/2019/07/14/Math/Statistics/signifi-test/</url>
    <content><![CDATA[<h2 id="什么是显著性检验">什么是显著性检验</h2>
<p>显著性检验是“统计假设检验”（Statistical hypothesis testing）的一种，显著性检验是用于检测科学实验中<strong>实验组</strong>与<strong>对照组</strong>之间是否有差异以及差异是否显著的办法。</p>
<p>这个方法的基本原理：小概率事件在一次试验中实际上是不会发生的。也就是<strong>小概率原理</strong></p>
<p>一般而言，把要检验的假设称之为原假设（null hypothesis），记为<span class="math inline">\(H_0\)</span>；把与<span class="math inline">\(H_0\)</span>相对应（相反）的假设称之为备择假设，记为<span class="math inline">\(H_1\)</span>。</p>
<ul>
<li><strong>原假设为真，结论显示为假，称为弃真错误，概率为</strong><span class="math inline">\(\alpha\)</span>
<ul>
<li>通常考察的概率都是<span class="math inline">\(\alpha\)</span>，这样的假设检验称为显著性检验，<span class="math inline">\(\alpha\)</span>也就称为显著性水平</li>
</ul></li>
<li>原假设为假，结论显示为真，称为纳伪错误，概率为<span class="math inline">\(\beta\)</span></li>
</ul>
<a id="more"></a>
<h2 id="为什么要做显著性检验">为什么要做显著性检验</h2>
<p>因为我们平常所做的统计都是基于<strong>有限数量的样本</strong>，但假设却是对<strong>总体</strong>给出的。为了了解我们的<strong>假设是否符合实际情况</strong>，所以通过做显著性检验</p>
<ul>
<li>如果样本的情况和我们对总体的假设的显著性差异大于<span class="math inline">\(p\)</span>值，说明假设和样本的情况是一致的</li>
<li>如果小于<span class="math inline">\(p\)</span>值，我们就拒绝原假设</li>
</ul>
<h2 id="怎么做显著性检验">怎么做显著性检验</h2>
<p>显著性检验有两种</p>
<ul>
<li><strong>参数检验</strong>：检验参数是否正确，这里的参数可以是自己随便给的，也可以是之前根据参数估计出来的。要求样本是正态分布的，且正态总体拥有相同的方差</li>
<li>非参数检验：应用基于秩的非参数检验</li>
</ul>
<p>参数检验本质上就是考虑<span class="math inline">\(p\)</span>值的大小</p>
<h2 id="通过例子来理解假设检验">通过例子来理解假设检验</h2>
<p>神经学家要测试一种药物对反应时间的效果，分别对100只老鼠注射一单位剂量的药物然后对其进行神经刺激，然后记录反应时间，已知没有注射药物的老鼠的平均反应时间为1.2秒，结果测出：100只注射药物的老鼠的平均反应时间为1.05秒，（样本的标准差为0.05秒）</p>
<ol type="1">
<li><p>确定原假设</p>
<ul>
<li><span class="math inline">\(H_0\)</span>：药物对反应时间无效果，平均反应时间为<span class="math inline">\(\mu=1.2s\)</span></li>
<li><span class="math inline">\(H_1\)</span>：药物对反应时间有效果，平均反应时间为<span class="math inline">\(\mu=1.05s\)</span></li>
</ul></li>
<li><p>确定显著水平：<span class="math inline">\(\alpha=0.05\)</span></p></li>
<li><p>确定<strong>检验统计量</strong>并给出<strong>拒绝域</strong></p>
<ul>
<li><p>因为这里的样本数较多，100，所以可以认为是正态分布，用<span class="math inline">\(z\)</span>统计量来检验</p>
<p>根据<span class="math inline">\(z=\frac{\overline{x}-\mu}{S E}=-3\)</span></p></li>
<li><p>拒绝域：根据0.025查表的<span class="math inline">\(z\)</span>的临界值<span class="math inline">\(z=-1.96\)</span></p></li>
</ul></li>
<li><p>根据样本计算检验统计量是否在拒绝域内</p>
<p>在，拒绝零假设</p></li>
</ol>
]]></content>
      <categories>
        <category>Math</category>
        <category>Statistics</category>
      </categories>
      <tags>
        <tag>statistics</tag>
      </tags>
  </entry>
  <entry>
    <title>Brains, Minds and Machines Summer Course 0</title>
    <url>/2020/03/22/Philosophy/Brains,%20Minds%20and%20Machines%20Summer%20Course/0-introduction/</url>
    <content><![CDATA[<h2 id="introduction">Introduction</h2>
<p><a href="https://ocw.mit.edu/resources/res-9-003-brains-minds-and-machines-summer-course-summer-2015/instructor-insights/maintaining-intellectual-coherence-across-a-wide-range-of-topics/">ref</a></p>
<p>课程目的: 教育学生在人工智能领域养成跨学科思维, 体现在计算机科学</p>
<p>因为这也是一个跨学科的问题, 所以在学习与思考时一定不能忘了主题, 我们可以在脑海中记住几个问题</p>
<ul>
<li>大脑如何处理感觉信息来产生智能行为? 我们如何设计相似的计算机算法?</li>
<li>人类知识的结构和形式是什么? 是如何存储表现和组织的?</li>
<li>人类的思维是如何通过进化的</li>
<li>人类大脑有着非常多的功能, 很general, 这是怎么做到的</li>
<li>这些功能是否有着一些共性呢?</li>
</ul>
<p>关于MIT实验室的: Why? 虽然通过机器学习和深度学习, 技术方面的发展有了长足的进步, 但是我们离真正理解人类的智能<strong>还很远.</strong> <strong>智能Intelligence</strong>的<strong>定义</strong>还是非常不完善的. Mission: 在不同层面: 计算层面</p>
]]></content>
      <tags>
        <tag>tips</tag>
        <tag>cs</tag>
      </tags>
  </entry>
  <entry>
    <title>Human Cognitive Neuroscience by Nancy Kanwisher</title>
    <url>/2020/03/22/Philosophy/Brains,%20Minds%20and%20Machines%20Summer%20Course/1-1-cognitive-neuroscience/</url>
    <content><![CDATA[<p>有多种实现智能的方式: computation, circuits</p>
<blockquote>
<p>any device that perceives its environment and takes actions that maximize its chance of successfully achieving its goals.</p>
<p>AI is whatever hasn't been done yet</p>
<p>These sub-fields are based on technical considerations, such as particular goals (e.g. "<a href="https://en.wikipedia.org/wiki/Robotics">robotics</a>" or "<a href="https://en.wikipedia.org/wiki/Machine_learning">machine learning</a>"),[<a href="https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Problems_of_AI-15">15]</a> the use of particular tools ("<a href="https://en.wikipedia.org/wiki/Logic">logic</a>" or <a href="https://en.wikipedia.org/wiki/Artificial_neural_network">artificial neural networks</a>), or deep philosophical differences.[<a href="https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Biological_intelligence_vs._intelligence_in_general-16">16]</a>[<a href="https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Neats_vs._scruffies-17">17]</a>[<a href="https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Symbolic_vs._sub-symbolic-18">18]</a> Subfields have also been based on social factors (particular institutions or the work of particular researchers).[<a href="https://en.wikipedia.org/wiki/Artificial_intelligence#cite_note-Fragmentation_of_AI-14">14]</a></p>
</blockquote>
<h2 id="architecture">Architecture</h2>
<p>大脑是如何工作的? 可能</p>
<ul>
<li>瑞士军刀, 一个区域负责一个功能</li>
<li>通用: 可以处理多种功能</li>
</ul>
<p>我们为什么要关注大脑的这些功能组件呢? 因为这是关于大脑和智能的基本问题, 这是一种处理复杂问题的途径(bottom-up), 了解不同组件可以帮助我们理解</p>
<a id="more"></a>
<h3 id="history">History</h3>
<ol type="1">
<li><p>Spearman 1904, 对学生进行智能测试</p>
<p>一个人如果能够更好地比较两个声音的大小, 那么他也能在数学考试中取得更好的成绩(强相关), 这是IQ测试的基本原理(各种智能是相互关联的)</p></li>
<li><p>Gall 1958</p>
<p>将大脑分成不同的部分</p></li>
<li><p>Leision 1794</p>
<p>将大脑的某一部分伤害, 发现其他智能行为还是好的. 说明不同位置的大脑是有不同功能的</p></li>
</ol>
<h2 id="methods">Methods</h2>
<h3 id="fmri">fMRI</h3>
<p>有着最好的空间精细度, 原始数据: 大概有30000个3d点.</p>
<p>测试速度是很慢的, 可能测到的是6秒前的数据. 数据意义只有在比较时才会产生.</p>
<p>背后的信号产生机制(Blood-oxygen-level-dependent)还是不明确的</p>
<ul>
<li>神经元活动增加<span class="math inline">\(\to\)</span>局部血流增加<span class="math inline">\(\to\)</span>血红蛋白的氧含量变化<span class="math inline">\(\to\)</span>MRI信号变强</li>
</ul>
<p>Meaning: 我们可以更好地了解大脑每个部分的不同功能, 进展十分迅速. 甚至在1990年我们都只能识别出两三个区域, 包括注意力, 现在我们已经能够定义十几个区域了</p>
<p>Important problem:</p>
<ul>
<li>映射关系, 大脑的区域X和特定的功能Y之间是怎么样的映射, many X for Y? X for how many Y?</li>
<li>充分性</li>
<li>天生的?</li>
</ul>
<p>语音实验：实验表明有一块区域只是对<strong>音素</strong>相应，而非<strong>语言</strong></p>
<ul>
<li>一块特定区域只做和语音相关的功能，比如听语句。当做其他事（不需要语言）时活跃度就很小</li>
<li>Language<span class="math inline">\(\not=\)</span>Thought</li>
<li>有很多区域我们还不了解</li>
<li>有一些区域是通用的（IQ/General），在做困难的工作时这些区域就会被激活（John Duncan）</li>
</ul>
]]></content>
      <tags>
        <tag>tips</tag>
        <tag>cs</tag>
      </tags>
  </entry>
  <entry>
    <title>Computation Neural Model</title>
    <url>/2020/04/05/Philosophy/Brains,%20Minds%20and%20Machines%20Summer%20Course/1-2-neural-circuits/</url>
    <content><![CDATA[<h2 id="neural-circuits">Neural Circuits</h2>
<p>What they want to do?</p>
<p>Learn some algorithm from our brain and translate them into computer code</p>
<p>Some feature of brain-based computations</p>
<ul>
<li>work for many decades</li>
<li>parallel computation</li>
<li>interaction</li>
</ul>
<p>How to study brain at different <strong>scales</strong></p>
<ul>
<li>Large to small: EEGDamp</li>
<li><strong>A central question in neuroscience:</strong> what’s the <strong>right</strong> level of abstraction</li>
</ul>
<p>Bottom-Up method, first study single neurons. Some model</p>
<ul>
<li>filter operation</li>
<li>integrate-and-fire circuit (easy to implement)</li>
<li>Hodgkin-Huxley unit</li>
<li>Multi-compartmental models</li>
<li>Spines, channels</li>
</ul>
<p>Circuits</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/20200406153829.png" alt="image-20200406153827627" /><figcaption aria-hidden="true">image-20200406153827627</figcaption>
</figure>
<p>Something like this</p>
<p>Visual system shows an approximately hierarchical architecture.</p>
<ul>
<li>V1 part is important</li>
<li>Timing of the response, latency 50~60ms</li>
<li>What pathway and Where pathway</li>
</ul>
<p>First order approximation: immediate recognition</p>
<ul>
<li><strong>behavior</strong>, we recognize objects within ~150ms</li>
<li><strong>physiology</strong>, visually selective responses to complex shapes within ~150ms</li>
<li><strong>computation</strong>, bottom-up computational models (maybe inspire deep learning)</li>
</ul>
<h2 id="feedback-signal">Feedback Signal</h2>
<h3 id="basic-mechanisms-in-v1">Basic Mechanisms in V1</h3>
<p><strong>Feedback signal enhance surround suppression</strong></p>
<p>signals from higher part</p>
<p>visual cortex orientation tuning, there is a Gabor function can describe the system</p>
<p>There are so many models can explain the situation</p>
<ul>
<li>feed-forward model</li>
<li>feed-back? (by cooling v2/v3 cortex) NO</li>
</ul>
<h3 id="visual-search">Visual Search</h3>
<p><strong>Tuned feedback signals can instantiate visual search and feature-based attention</strong></p>
<p>to see particular face/color</p>
<p>go through some linear and non-linear computation</p>
<ol type="1">
<li>filter 4 orientation</li>
<li>local max</li>
<li>filter</li>
<li>filter</li>
<li>comparison</li>
</ol>
<h2 id="questions">Questions</h2>
<p>Reasons for optimism</p>
<ul>
<li>Wiring diagram</li>
<li>Strength in numbers</li>
<li>Source code</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Tutorial:Decoding to Understand Neural</title>
    <url>/2020/04/06/Philosophy/Brains,%20Minds%20and%20Machines%20Summer%20Course/tutorial-neural-decoding/</url>
    <content><![CDATA[<h2 id="motication">Motication</h2>
<ul>
<li>have some idea about how brain works</li>
<li>run a experiment and make neural recordings</li>
<li>get a buch of data</li>
</ul>
<p><strong>convert data into answers</strong></p>
<h2 id="decoding">Decoding?</h2>
<p>Alternative name: readout MVPA</p>
<p>predict stimulus/behavior from neural activity</p>
<p>Classifier:</p>
<ol type="1">
<li>see some image, record the eeg</li>
<li>train pattern classifier</li>
<li>predict</li>
</ol>
<p>this a analog to the real brain</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/20200406185819.png" alt="image-20200406185816001" style="zoom:50%;" /></p>
<h2 id="neural-content">Neural Content</h2>
<p>Start with a simply experiment</p>
<p>Confusion Matrices, predict pretty well</p>
<p>different classifiers? both good</p>
<ul>
<li>MCC</li>
<li>EDist(good)</li>
<li>SVM</li>
</ul>
<h3 id="abstract-representations">Abstract representations</h3>
<p>Different angles/language/color, we can still tell</p>
<p>Example: position invariance experiment</p>
<ul>
<li>train upper, better accuracy upper, but not bad at middle and lower</li>
<li>different pose ML/MF/AL/AM</li>
</ul>
<h2 id="data-analsis">Data analsis</h2>
<p>neural content: what information</p>
<p>coding: what feature does brain process</p>
]]></content>
      <tags>
        <tag>tips</tag>
        <tag>cs</tag>
      </tags>
  </entry>
  <entry>
    <title>Introduction to Linguist</title>
    <url>/2019/11/16/Philosophy/Linguistics/Overview/</url>
    <content><![CDATA[<h2 id="introduction">Introduction</h2>
<p>5 Topics:</p>
<ul>
<li><p>Syntax: the structure of language,</p>
<ul>
<li>subj, verb, object</li>
<li>English: SVO; Japanese: SOV</li>
<li>create a syntax tree</li>
</ul></li>
<li><p>Semantics: the meaning of language</p></li>
<li><p>Morphology: the structure of words</p>
<ul>
<li><p>Birds, Pets, the difference between <em>s</em></p>
<a id="more"></a></li>
</ul></li>
<li><p>Phonetics: peoperties of sounds</p></li>
<li><p>Phonogy: patterns of sounds</p>
<ul>
<li>pay/bay/ebay, bay sounds like pay</li>
</ul></li>
</ul>
<h2 id="syntax-1">Syntax 1</h2>
<h3 id="word-order">Word order</h3>
<p>English word order is SVO (subject verb object)</p>
<h3 id="grammaticality">Grammaticality</h3>
<ul>
<li>prescriptive: what should be said/writen</li>
<li>descriptive: observation about what is said</li>
</ul>
]]></content>
      <categories>
        <category>Philosophy</category>
      </categories>
      <tags>
        <tag>Philosophy</tag>
        <tag>Linguist</tag>
      </tags>
  </entry>
  <entry>
    <title>Acoustics</title>
    <url>/2020/01/03/Philosophy/Linguistics/acoustic/</url>
    <content><![CDATA[<h2 id="physics">Physics</h2>
<p>Sound is a pressure wave, pressure fluctuations move through space,but each air particle moves only a small distance.</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/ling-soundwaves.png" style="zoom:50%;" /></p>
<blockquote>
<p>While using a microphone to capture sounds, the physics behind it is <strong>AIR PRESSURE</strong>, so the waveform files (.wav/.mp3…) will have negative and positive value!</p>
</blockquote>
<h2 id="spectrums">Spectrums</h2>
<p>The spectrums of a sound plays a center role in determining its <strong>quality</strong></p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/ling-spectrums.png" style="zoom:50%;" /></p>
<a id="more"></a>
<p>we can represent the sound in frequency plot</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/ling-ai-spectrums.png" style="zoom:50%;" /></p>
<ul>
<li>the quality of a vowel depends on the <strong>shape</strong> of its spectrum</li>
<li>the peaks are called <strong>formants</strong></li>
<li>the quality depends primarily on the first three formant</li>
</ul>
<h2 id="spectrogram">Spectrogram</h2>
<p>A spectrogram is a visual representation of the <strong>spectrum</strong> of frequencies of a signal as it <strong>varies with time</strong>. When applied to an audio signal, spectrograms are sometimes called sonographs, voiceprints, or voicegrams.</p>
<p>Time-Frequency Plot</p>
<h2 id="auditory">Auditory</h2>
<h3 id="loudness">Loudness</h3>
<p>Loudness depends on <strong>amplitude</strong> of the sound wave <span class="math inline">\(\to\)</span> Amplitude is usually measured in the terms of <strong>root-mean-square(over some time window)</strong></p>
<p>perceived loudness is more closely related to <strong>intensity</strong>, proportional to the square of the amplitude, relative intensity in dB = <span class="math inline">\(20log(\frac{x}{r})\)</span></p>
<p>Loudness of pure tone (&gt;40 dB) in Sones: <span class="math display">\[
N=2^{\frac{(dB-40)}{10}}
\]</span></p>
<h2 id="sampling">Sampling</h2>
<p>What sampling rate? Due to Nyquist Theorem, twice that frequency</p>
<p>Since the highest frequency ears can perceive is about <span class="math inline">\(20kHz\)</span>, we must sample at <span class="math inline">\(2\times20kHz=40kHz\)</span></p>
<p>However, almost all of the information relevant to speech sounds is below <span class="math inline">\(10kHz\)</span>, so <span class="math inline">\(20kHz\)</span> sampling rate is enough</p>
<p>In practical, we use a sampling rate of <span class="math inline">\(44.1kHz\)</span></p>
]]></content>
      <categories>
        <category>Philosophy</category>
      </categories>
      <tags>
        <tag>Philosophy</tag>
        <tag>Linguist</tag>
      </tags>
  </entry>
  <entry>
    <title>Speech Analysis</title>
    <url>/2020/03/29/Philosophy/Linguistics/speech-analysis/</url>
    <content><![CDATA[<p>语音是一种常见的信息<strong>交流</strong>方式，但是语音是非常多变的（相比于文本），语音包含了语言、方言、音调等信息，在提供了更多信息的同时也给分析加大了难度。如何正确分析语音是一项困难的工作。</p>
<h3 id="语音的表示">语音的表示</h3>
<p>如下图所示，语音可以表示为振幅随时间的变化</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/20200329144002.jpg" /></p>
<p>再扩大一点，语音也可以看成是一系列基本发音单位（Phoneme）的集合</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/20200329144225.png" /></p>
<p>如果放大语音信号，我们可以看出来语音是由不同的音素组成的。不同的音素来源也是不同的。比如说<code>w</code>、<em>l</em>是由声带的<strong>周期性振动</strong>产生的，所以被归类为浊音素。清类（unvoiced）和浊类（voiced）是基于声带振动对语音进行的广义分类。</p>
<h2 id="时频分析">时频分析</h2>
<p>通过短时傅里叶变换（STFT），我们可以计算语音的时频图，本质就是将一段语音分成很多小的帧（frame），然后对这一小段帧进行傅里叶变换。</p>
<p>那为什么要这样将语音分成比较小的帧呢？因为语音的时间特性变化非常快，是一种非平稳（简单来说就是无法预测）的信号，不能对此进行傅里叶变换。而在小的帧中，我们假设语音信号是平稳的，并且在帧内不会有太大变化</p>
<p>根据nyquist采样定理，我们能观察到的最大频率是采样率的一半</p>
<blockquote>
<p>语音实验中的采样频率是48kHz，所以能观测到的就是24kHz</p>
</blockquote>
<h3 id="trade-off">Trade-off</h3>
<p>如何选择帧的大小是一个值得考虑的问题</p>
<ul>
<li>选择较小的帧，可以获得更好的时间分辨率，但是样本少导致傅里叶变换时其中包含了很少的频率分量</li>
<li>选择较大的帧，时间频率较低，但是采样数较高，频率分辨率就高了</li>
</ul>
]]></content>
      <tags>
        <tag>Philosophy</tag>
        <tag>Linguist</tag>
      </tags>
  </entry>
  <entry>
    <title>Speech Perception</title>
    <url>/2020/01/03/Philosophy/Linguistics/speech-perception-1/</url>
    <content><![CDATA[<h3 id="introduction">Introduction</h3>
<p>Problem of the Listener: <strong>Extract</strong> meaning from the acoustic signal</p>
<ul>
<li>involves the recognition of words</li>
<li>identifying the perceptual cues that listeners use</li>
</ul>
<h3 id="cues">Cues</h3>
<ul>
<li>aspirated and unaspirated stops in Mandarin differ in VOT
<ul>
<li>Are listeners senstive to these differences?</li>
</ul></li>
<li>Most test: manipulate the acoustic property synthetically and see if perceptual response is affected</li>
</ul>
<p>Properties of cues:</p>
<ul>
<li>cues combine to distinguish sounds</li>
<li>individual cues can vary in strength</li>
</ul>
<h2 id="categorical">Categorical</h2>
<p>Listeners only have access to category labels, so stimuli can only be distinguished if they are identified as belonging to different categories</p>
<p>Why significant?</p>
<ul>
<li>the categorical perception pattern <strong>contrasts</strong> with the pattern observedd in psychophysical experiments using <strong>non-speech</strong> stimuli
<ul>
<li>This contrast was used to aruge that speech perception is <strong>“special”</strong></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>Philosophy</category>
      </categories>
      <tags>
        <tag>Philosophy</tag>
        <tag>Linguist</tag>
      </tags>
  </entry>
  <entry>
    <title>Audio Stretch</title>
    <url>/2020/03/11/Philosophy/Neuroscience/audio-stretch/</url>
    <content><![CDATA[<h2 id="总览">总览</h2>
<p><a href="https://www.mathworks.com/help/audio/ref/stretchaudio.html">Ref</a></p>
<p>Audio stretch, 也可以称为TSM (time scale modification)</p>
<p>用途:</p>
<ul>
<li>拉长或缩短信号, 并且不损失信息</li>
<li>将两个语音信号拉成相同的长度, 方便做平均</li>
</ul>
<h2 id="算法">算法</h2>
<h3 id="phase-vocoder">Phase Vocoder</h3>
<p><strong>频域上的拉伸</strong>, 基本想法就是将音频做时频分析, 分成很多小段, 保留音高Pitch. 经过相位移动之后重建波形算法的主要难点和复杂之处在于如何使重叠加法重建中连续窗口的对齐</p>
<figure>
<img src="https://www.mathworks.com/help/audio/ref/stretchaudio_vocoder.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="wsola----waveform-similarity-overlap-add">WSOLA -- Waveform Similarity Overlap-Add</h2>
<p>时域上的拉伸, 是OLA算法的拓展</p>
<ul>
<li>OLA stand for overlap and add, 是一个简单的叠加算法, 对音频进行分帧, 然后进行合成
<ul>
<li>存在问题1: 音频不连续</li>
<li>存在问题2: 会造成部分信号幅值改变</li>
</ul></li>
<li>WSLOLA, 特点是音频分帧之后不直接叠加, 而是在一定范围内找待叠加的音频帧, 找到最相思的去合成</li>
</ul>
]]></content>
      <tags>
        <tag>neuroscience</tag>
      </tags>
  </entry>
  <entry>
    <title>ERP Overview</title>
    <url>/2020/03/31/Philosophy/Neuroscience/erp-intro/</url>
    <content><![CDATA[<h2 id="what-is-erp">What is ERP?</h2>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3016705/">ref</a></p>
<p><strong>定义</strong>：Event-related potentials (ERPs) 事件相关电位，是由特定刺激而导致的脑中的电位。宏观反映了大量定向相同的神经元（百万级别）在处理信息时同步放电产生的突触电位的总和。</p>
<p><strong>前因</strong>：ERP可以由多种事件诱发：感官上的，认知的，运动事件</p>
<p><strong>后果</strong>：在人类大脑中，ERP主要可以分为两类</p>
<ul>
<li>Early waves，一个波峰在刺激发生之后的100毫秒左右。这种ERP是<strong>外源性</strong>的，因为这个响应主要取决于外部刺激的物理性质</li>
<li>Later parts，在之后的响应一般是<strong>内源性</strong>的、认知性的</li>
</ul>
<p><strong>表现形式</strong>：和latency相关的amplitude，eeg信号</p>
<a id="more"></a>
<h2 id="calculation">Calculation</h2>
<p>通过EEG记录了多次大脑对单一刺激的响应。但是由于EEG记录过程中，有随机的脑活动和其他生物信号以及电磁干扰（比如电路噪声、荧光灯）等会对记录的ERP信号造成噪声干扰。将多次响应平均在一起，可以达到去噪的效果，求出平均的大脑响应</p>
<p>ERP的计算有两个假设</p>
<ol type="1">
<li>所要求的ERP信号是有着不变得到延迟和形状的</li>
<li>噪声是零均值的</li>
</ol>
<h2 id="different-erp-waveforms">Different ERP Waveforms</h2>
<p>下面所说的信号形式中P for Positive，N for Negative，数字代表延迟（毫秒）</p>
<p>按顺序出现</p>
<ol type="1">
<li>P50</li>
<li>N100</li>
<li>P200</li>
</ol>
<h2 id="analysis">Analysis</h2>
<p>We want to compute from <strong>Raw Data</strong> to <strong>ERP</strong></p>
<p>原始数据： 低信噪比； 期望的ERP：高信噪比、</p>
<p>处理顺序</p>
<ol type="1">
<li><p>清理、手工移除</p>
<p>去除眼动、眨眼等</p></li>
<li><p>滤波</p></li>
<li><p>切片</p></li>
<li><p>Baseline Correction</p></li>
<li><p>平均</p></li>
</ol>
]]></content>
      <tags>
        <tag>neuroscience</tag>
      </tags>
  </entry>
  <entry>
    <title>Background for Neuroscience</title>
    <url>/2020/03/22/Philosophy/Neuroscience/neuroscience-intro/</url>
    <content><![CDATA[<ul>
<li><p>Neuron</p>
<p>Action potenitals: spiking or firing</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/20200328184546.png" alt="image-20200322163123664" /><figcaption aria-hidden="true">image-20200322163123664</figcaption>
</figure></li>
<li><p>Anatomy</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/20200328184555.png" alt="image-20200322163256644" /><figcaption aria-hidden="true">image-20200322163256644</figcaption>
</figure></li>
<li><p>Recordings</p>
<ul>
<li><p><strong>invasive</strong>(most accurate): it could be single unit or multi-unit</p>
<p>ECoG: very rare</p></li>
<li><p><strong>neuroimaging</strong>: MEG/EEG/fMRI(good spatial resolution but bad time accuracy)</p>
<p>Why it works: nice properties that neurons in the <strong>same orientation</strong></p></li>
</ul></li>
</ul>
<a id="more"></a>
<ul>
<li><p>Visual system</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/20200328184603.png" alt="image-20200322164400363" /><figcaption aria-hidden="true">image-20200322164400363</figcaption>
</figure>
<ul>
<li>Ventral Stream: <strong>what</strong> is the object</li>
<li>Dorsal Stream: <strong>where</strong> is the object</li>
</ul>
<p>feed-forward, feed-back connection</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/20200328184610.png" alt="image-20200322164604869" /><figcaption aria-hidden="true">image-20200322164604869</figcaption>
</figure>
<p>真正的神经网络可能也是层级的, 一层处理某一项功能, 比如浅层的来识别物体种类, 深层的识别物体位置.</p>
<p>如果要通过计算机实现上述的模型, 会用到一个分层的前馈模型</p>
<ul>
<li><p>CNN</p></li>
<li><p>简单的cell: 映射</p></li>
<li><p>复杂的cell: 类似于卷积</p>
<p>Max Pooling: 池化作用于图像中不重合的区域, 所以pooling之后会变小</p></li>
</ul></li>
</ul>
]]></content>
      <tags>
        <tag>neuroscience</tag>
      </tags>
  </entry>
  <entry>
    <title>Timing Synchronization in EEG Experiments</title>
    <url>/2020/01/13/Philosophy/Neuroscience/neusci-funda/</url>
    <content><![CDATA[<h2 id="introduction">Introduction</h2>
<p>https://sccn.ucsd.edu/~mgrivich/Synchronization.html</p>
<p>Goal: properly <strong>synchronize</strong> events in the EEG experiments and <strong>validate</strong> the sychronization.</p>
<p>Why? verify that the timing of all data points is known with sufficient precision. Some key points such as the playing of a sound, the display of an image.</p>
<a id="more"></a>
<p>Error</p>
<ul>
<li>constant offset</li>
<li>drift: as time passes, the difference increase</li>
<li>jitter:</li>
</ul>
<h2 id="general-principles">General Principles</h2>
<ol type="1">
<li>When possible, use hardware synchronization</li>
<li>streaming, in general, 50ms is easily achievable, and 1ms accuracy is achievable with effort</li>
<li>behavior must be validated</li>
</ol>
<h2 id="audio-synchronization">Audio Synchronization</h2>
<p>Playing audio is not reliable with respect to timing. Latencies of 100+/-50 ms are common.</p>
]]></content>
      <categories>
        <category>Philosophy</category>
      </categories>
      <tags>
        <tag>neuroscience</tag>
      </tags>
  </entry>
  <entry>
    <title>音素的表示与分类</title>
    <url>/2020/03/03/Philosophy/Neuroscience/phoneme-repre-class/</url>
    <content><![CDATA[<h2 id="intro">Intro</h2>
<p>人类可以可靠地分辨许还做不到. 背后的生物学机制还不清楚, 但是有实验证据表明有这其中有大脑皮层的加工. 关键问题在于基础的语音信息是否足够充分来支持音素的分类</p>
<p>视觉系统中的研究表明100个cell就可以鲁棒地分类物体了. 对于语音系统的研究主要是时间上的特征分析, 因为音素是时频的pattern.</p>
<p>结果: 记录了许多对于语音信号的A1神经响应, 分析得到</p>
<ul>
<li>时变的响应可以被识别到</li>
<li>常见的语音特征确实被加工了</li>
</ul>
]]></content>
      <categories>
        <category>Philosophy</category>
      </categories>
      <tags>
        <tag>neuroscience</tag>
      </tags>
  </entry>
  <entry>
    <title>时频图计算</title>
    <url>/2020/03/08/Philosophy/Neuroscience/spectrogram/</url>
    <content><![CDATA[<h2 id="intro">Intro</h2>
<p>对象：非稳定信号，频谱会随着时间的推移而变化</p>
<p>利用短时傅里叶变换来计算时频图, 可以观察随着时间变化的频谱信号</p>
<p>基本的计算步骤如下</p>
<ol type="1">
<li>将信号分割成许多个短的有交叠（Overlapping）的片段, 长度为<em>NSC=length/N</em></li>
<li>将每个片段都用窗函数滤波, 比如hamming窗，Kaiser窗</li>
<li>计算每个片段的FFT, 点数为<span class="math inline">\(max(256,2^p)\)</span>, 其中<span class="math inline">\(p=log_{2}{NSC}\)</span></li>
</ol>
]]></content>
      <categories>
        <category>Philosophy</category>
      </categories>
      <tags>
        <tag>neuroscience</tag>
      </tags>
  </entry>
  <entry>
    <title>TRF计算</title>
    <url>/2020/02/05/Philosophy/Neuroscience/trf-clac/</url>
    <content><![CDATA[<h2 id="系统的表示方法">系统的表示方法</h2>
<p>定义: 对于某个语音刺激(比如说音素), 将大脑假设成一个线性时不变系统, 大脑的整体响应是对语音刺激的响应加上其他的噪声(实验中应该尽量减小噪声)</p>
<a id="more"></a>
<p><span class="math display">\[
R(t)=TRF(t)*S(t)+Noise(t)
\]</span> <span class="math inline">\(𝑅(𝑡)\)</span>表示大脑总的神经响应Response , <span class="math inline">\(𝑇𝑅𝐹\)</span>表示时间响应函数, <span class="math inline">\(*\)</span> 表示卷积, <span class="math inline">\(𝑆(𝑡)\)</span>表示语音刺激Stimulus, <span class="math inline">\(Noise(𝑡)\)</span>表示测量过程中引入的噪声干扰</p>
<h2 id="已知条件">已知条件</h2>
<p>我们的最终目的是求出<span class="math inline">\(TRF(t)\)</span>函数, 现在已知的有</p>
<ul>
<li><span class="math inline">\(S(t)\)</span>, 通过对播放的语音信号进行处理, 获取各个音素开始的时间, 我们可以知道语音刺激的函数</li>
<li><span class="math inline">\(R(t)\)</span>, 通过脑电传感器我们获得了被试者的脑电信号</li>
<li>通过滤波函数对脑电信号进行去噪, 获得<span class="math inline">\(R(t)-Noise(t)\)</span></li>
</ul>
<p>所以我们可以计算出<span class="math inline">\(TRF(t)\)</span>, 计算的方法是最小二乘法, 也就是实际脑电信号和通过<span class="math inline">\(TRF\)</span>计算出的脑电信号误差要最小.</p>
<p>因为我们获取的脑电信号和播放的语音刺激都是数字信号, 所以我们用离散形式来表示关系. 为了便于表示, 经过滤波之后的脑电信号记为<span class="math inline">\(y(n)\)</span>, 语音刺激记为<span class="math inline">\(x(n)\)</span>, 时间响应函数记为<span class="math inline">\(h(n)\)</span>, 误差项记为<span class="math inline">\(e(n)\)</span>, 可以得到 <span class="math display">\[
y(n)=x(x)*h(n)+e(n)
\]</span> 为了计算h, 可以将卷积写成矩阵乘积形式: <span class="math display">\[
\left[\begin{array}{c}
{y_{0}} \\
{y_{1}} \\
{\vdots} \\
{y_{N}}
\end{array}\right]=\left[\begin{array}{cccc}
{x_{0}} &amp; {x_{-1}} &amp; {\cdots} &amp; {x_{-k}} \\
{x_{1}} &amp; {x_{0}} &amp; {\cdots} &amp; {x_{-k+1}} \\
{\vdots} &amp; {\vdots} &amp; {\ddots} &amp; {\vdots} \\
{x_{N}} &amp; {x_{N-1}} &amp; {\cdots} &amp; {x_{0}}
\end{array}\right]\left[\begin{array}{c}
{h_{0}} \\
{h_{1}} \\
{\vdots} \\
{h_{k}}
\end{array}\right]+\left[\begin{array}{c}
{e_{0}} \\
{e_{1}} \\
{\vdots} \\
{e_{N}}
\end{array}\right]
\]</span> 其中矩阵的行数<span class="math inline">\(N\)</span>表示神经响应的长度</p>
<p>矩阵的列数<span class="math inline">\(k\)</span>表示系统的阶数, 也就是神经响应函数的长度</p>
<p>用向量表示为 <span class="math display">\[
\vec{y}=X h+\vec{e}
\]</span></p>
<h2 id="最小二乘法">最小二乘法</h2>
<p>计算方法是让各个误差项的平方和<span class="math inline">\(E_{sum}\)</span>最小, 可得 <span class="math display">\[
E_{sum}=\sum_{i=0}^{N} e_{i}^{2}=\vec{e}^{T} \vec{e}
\]</span></p>
<p>又有</p>
<p><span class="math display">\[
\vec{e}^{T}=(\vec{y}-X h)^{T}=h^{T} X^{T}-\vec{y}^{T}
\]</span></p>
<p>可以得到</p>
<p><span class="math display">\[
\begin{aligned}
E_{sum} &amp;=\vec{e}^{T} \vec{e} \\
&amp;=\left(h^{T} X^{T}-\vec{y}^{T}\right)(\vec{y}-X h) \\
&amp;=\left(h^{T} X^{T} \vec{y}-\vec{h}^{T} X^{T} X h-\vec{y}^{T} \vec{y}+\vec{y}^{T} X h\right)
\end{aligned}
\]</span> 为了取得误差和最小, 我们对上式对<span class="math inline">\(h\)</span>求导, 当求导式子等于0时, 误差最小. 因为<span class="math inline">\(h^{T} X^{T} \vec{y}, \vec{h}^{T} X^{T} X h, \vec{y}^{T} X h\)</span>都是标量, 所以得到的公式为 <span class="math display">\[
\begin{aligned}
\frac{\partial E_{sum}}{\partial h} &amp;=\frac{\partial\left(2 h^{T} X^{T} \vec{y}-h^{T} X^{T} X h-\vec{y}^{T} \vec{y}\right)}{\partial h} \\
&amp;=\frac{\partial\left(2 h^{T} X^{T} \vec{y}\right)}{\partial h}-\frac{\partial\left(h^{T} X^{T} X h\right)}{\partial h}\\
&amp;=\vec{y}^{T} X-h^{T} X^{T} X=0
\end{aligned}
\]</span> 最终我们可以得到 <span class="math display">\[
h=\left(X^{T} X\right)^{-1} X^{T} \vec{y}
\]</span></p>
]]></content>
      <categories>
        <category>Philosophy</category>
      </categories>
      <tags>
        <tag>neuroscience</tag>
      </tags>
  </entry>
  <entry>
    <title>读「中国国家治理的制度逻辑--组织学研究」</title>
    <url>/2020/02/28/Philosophy/Politics/china-politics-zhou/</url>
    <content><![CDATA[<h2 id="绪论">绪论</h2>
<p>作者多年来从组织社会学的角度来认识和解读中国国家与社会的关系, 近几年,他不满足于数据与量化研究, 开始转向田野研究, 希望获得更加真实的情况.</p>
<blockquote>
<p>学术研究的意义不在发现和批评荒谬，而在发掘和解释荒谬背后的逻辑</p>
<p>--黄仁宇</p>
</blockquote>
<p>研究的方法:</p>
<ul>
<li><p>理论, 提供了视角和分析工具</p>
<p>作者一直选取组织研究学的方法, 因为他比较拿手, 而且可以提供独特的角度</p></li>
<li><p>比较, 启发我们在不同文化与社会中的特色, 所以研究得益于其他社会背景下的研究成果</p></li>
</ul>
<a id="more"></a>
<h2 id="导论-制度逻辑">1 导论: 制度逻辑</h2>
<p>问题的提出:</p>
<ul>
<li>为什么中国文明生存时间很久</li>
<li>为什么中国文明存在长期停滞徘徊的经历</li>
<li>为什么中国社会近几十年突然迸发巨大活力</li>
</ul>
<p><strong>假设</strong>: 当代中国的一些政治现象<strong>可能存在</strong>着稳定共享的制度逻辑, 这些现象包括</p>
<ul>
<li>宏观上: 中央和地方关系, 运动式的治理整顿, 政治教育运动, 法律制度和官僚制度的发展举步维艰</li>
<li>微观上: 主要是基层的问题, 比如政策执行中的不利, 变通与共谋</li>
</ul>
<p><strong>研究角度与方法:</strong></p>
<ul>
<li>角度: 组织学研究</li>
<li>方法: 从微观着眼, 近距离的田野观察</li>
</ul>
<p><strong>基本思路:</strong></p>
<ol type="1">
<li><p>中国政体的突出特点: 一统体制</p>
<p>存在矛盾: 一统体制和有效治理, 中央管辖权和地方治理区间的紧张与不兼容. 矛盾无法解决, 只能找到一个平衡点</p></li>
<li><p>体制的维系机制: 官僚体制, 一统观念制度</p>
<p>但是在当代中国, 这些体制受到了多重挑战(官僚组织不堪重负, 一统制观念受到多元社会的碰撞挑战), 所以有一些现象产生, 是对挑战的应对</p></li>
<li><p>虽然这些机制缓和了矛盾, 但是衍生了其他后果</p>
<ul>
<li>集权和放权</li>
<li>制度逻辑限制了制度创新</li>
</ul></li>
</ol>
<h3 id="国家治理的深刻矛盾">国家治理的深刻矛盾</h3>
<p>国家治理的两个线索(这里的国家指<strong>国家政权</strong>而不是民族)</p>
<ul>
<li>中央与地方权利</li>
<li>国家与民众间关系</li>
</ul>
<p>中国长久以来是一统制, <strong>矛盾体现在中央统辖权与地方治理权之间</strong></p>
<ul>
<li><p>统辖权: 推行政策意图, 资源与人事安排</p>
<p>集中程度越高, 就相应程度上削弱地方治理权</p></li>
<li><p>有效治理: 基层政府解决实际问题</p>
<p>有效的治理能力意味着治理权的扩张</p></li>
</ul>
<p>既然存在这样的矛盾, 那么是怎么<strong>维系</strong>的呢</p>
<ul>
<li>官僚组织制度, 确保中央与地方步调一致
<ul>
<li>中性意义, 作为一种特有的组织形式, 通过专业化人员和正式规章制度来贯彻落实自上而下的政策指令</li>
<li>中国官僚的制度核心是人事安排和资源调配</li>
<li>单一的组织制度形式无法单独有效实施一统体制的权利, 所以需要观念制度</li>
</ul></li>
<li>观念制度, 等级结构与文化认同, 共享价值
<ul>
<li>认同和顺从中央权威</li>
<li>历史上, 儒教文化扮演了这样的角色, 因小农生产方式的同构性而获得长期稳定基础</li>
<li>当代, 马列主义, 通过思想教育来维系</li>
</ul></li>
</ul>
<p>维系的效果例子: 计划生育</p>
<ul>
<li>直接效果明显</li>
<li>成功原因:
<ul>
<li>建立了庞大的计生官僚</li>
<li>中央采取激励机制</li>
<li>大规模宣传教育</li>
</ul></li>
<li>代价:
<ul>
<li>行政成本, 人力资源, 社会动员, 政府注意力</li>
</ul></li>
</ul>
<hr />
<p><em>第一单元: 国家治理逻辑的制度分析</em></p>
<h2 id="官僚体制-韦伯理论视角">2 官僚体制: 韦伯理论视角</h2>
<h2 id="治理模式-一个控制权理论">3 治理模式: 一个"控制权"理论</h2>
<h2 id="运动型治理机制">4 运动型治理机制</h2>
<hr />
<p><em>第二单元: 国家治理逻辑与政府行为</em></p>
<h2 id="政府内部上下级谈判">5 政府内部上下级谈判</h2>
<h2 id="基层政府间的共谋现象">6 基层政府间的"共谋现象"</h2>
<h2 id="拼凑应对-多重逻辑下的基层政府行为">7 "拼凑应对": 多重逻辑下的基层政府行为</h2>
<h2 id="逆向软预算约束">8 逆向软预算约束</h2>
<hr />
<p><em>第三单元: 国家治理与中国社会</em></p>
<h2 id="集体债务之路-官僚制逻辑到社会逻辑">9 集体债务之路: 官僚制逻辑到社会逻辑</h2>
<h2 id="多重逻辑下的村庄选句">10 多重逻辑下的村庄选句</h2>
<h2 id="无组织的利益和集体行为">11 无组织的利益和集体行为</h2>
<h2 id="国家治理逻辑与中国未来">12 国家治理逻辑与中国未来</h2>
]]></content>
      <categories>
        <category>Philosophy</category>
        <category>Politics</category>
      </categories>
      <tags>
        <tag>politics</tag>
      </tags>
  </entry>
  <entry>
    <title>直流电机的控制</title>
    <url>/2019/07/06/Robotics/Hardware/TB6612motor/</url>
    <content><![CDATA[<h2 id="直流电机的结构与原理">直流电机的结构与原理</h2>
<p>(编码器)+定子+转子+电刷+(减速器)</p>
<p>在电刷上施加直流电压U，施加洛伦兹力，不断重复</p>
<p>一般直流电机的转速都是一分钟几千上万转的，所以一般需要安装减速器。</p>
<p>减速器是一种相对精密的机械零件，使用它的目的是降低转速，增加转矩</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/motor.png" /></p>
<a id="more"></a>
<ul>
<li>只有左右两根电机线决定了电机转速
<ul>
<li>因此控制施加在两边的电压大小和极性就可以实现调试和换向</li>
</ul></li>
<li>中间四根线都是编码器测速用的</li>
</ul>
<h2 id="编码器的使用">编码器的使用</h2>
<p>编码器是将角位移或者角速度转换成一连串电数字脉冲的<strong>旋转式传感器</strong></p>
<p>根据输出类型分类</p>
<ul>
<li>增量式</li>
<li>绝对式</li>
</ul>
<p>根据检测原理分类</p>
<ul>
<li>光学（光电编码器）、磁式（霍尔编码器）、感应式、电容式</li>
</ul>
<h3 id="编码器的原理光电霍尔">编码器的原理（光电、霍尔）</h3>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/encoder.png" /></p>
<p>目的：获取AB相输出的方波信号</p>
<h3 id="编码器倍频技术">编码器倍频技术</h3>
<p>目的：真正把编码器的精度提高4倍</p>
<p>常规办法：只测量信号A<strong>或者</strong>信号B的上升沿<strong>或者</strong>下降沿</p>
<p>四倍频方法：测量信号A<strong>和</strong>信号B的上升沿<strong>和</strong>下降沿</p>
<h3 id="编码器信号的采集">编码器信号的采集</h3>
<p>编码器的输出是标准的方波，通过单片机直接读取</p>
<p>软件中的处理方法</p>
<ul>
<li>STM32，硬件计数</li>
<li>51，通过外部中断读取</li>
</ul>
<h2 id="直流电机的控制">直流电机的控制</h2>
<p>使用PID控制器，因为我们是软件实现，所以是离散式的PID控制器，在采样时间很短的情况下，可以考虑</p>
<ul>
<li>一阶差分代替一阶微分</li>
<li>累加代替积分</li>
</ul>
<h3 id="位置的闭环控制">位置的闭环控制</h3>
<h3 id="速度的闭环控制">速度的闭环控制</h3>
]]></content>
      <categories>
        <category>Robotics</category>
        <category>Hardware</category>
      </categories>
      <tags>
        <tag>hardware</tag>
        <tag>motor</tag>
        <tag>encoder</tag>
      </tags>
  </entry>
  <entry>
    <title>Introduction to EEG</title>
    <url>/2020/01/02/Robotics/Hardware/eeg-intro/</url>
    <content><![CDATA[<h2 id="history">1 History</h2>
<ul>
<li>1875, observed from exposed brains</li>
<li>1914, photographed experimentally induced seizures</li>
<li>1934, "human brain waves",</li>
</ul>
<h2 id="why-measure-eeg">2 Why measure EEG</h2>
<p>Greatest advantage: <strong>temporal resolution</strong>, EEG can determine electrical activity in different brain regions</p>
<h2 id="physics">3 Physics</h2>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/eeg-dipoles.png" /></p>
<p>Necessary conditions: Aligned neurons and synchronous activity</p>
<a id="more"></a>
<p>Acquisition:</p>
<ul>
<li>electrode caps</li>
<li>conductive jelly</li>
<li>ruler</li>
<li>EEG amplifier, laptop</li>
</ul>
<h2 id="data-collection">4 Data collection</h2>
<p>Can tell us: precise timing of neural activity, sequence of mental operations</p>
<p>Can NOT tell us: precise brain location of neural activity</p>
<h3 id="analysis">Analysis</h3>
<ul>
<li>ERP: time- &amp; phase-locked potentials</li>
<li>On-going EEG: frequency-domain analysis</li>
</ul>
<h3 id="frequency-domain-analysis">Frequency-domain Analysis</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">EEG Bands(Hz)</th>
<th style="text-align: center;">Distribution</th>
<th style="text-align: center;">Subjective feeling</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Delta: 0.1-3</td>
<td style="text-align: center;">broad or diffused</td>
<td style="text-align: center;">deep, dreamless sleep</td>
</tr>
<tr class="even">
<td style="text-align: center;">Theta: 4-8</td>
<td style="text-align: center;">regional, may involve many lobes</td>
<td style="text-align: center;">intuitive, creative</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Alpha: 8-12</td>
<td style="text-align: center;">regional, usually involves entire lobes</td>
<td style="text-align: center;">relaxed</td>
</tr>
<tr class="even">
<td style="text-align: center;">Gamma: &gt;30</td>
<td style="text-align: center;">very localized</td>
<td style="text-align: center;">focused</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Beta: 12-30</td>
<td style="text-align: center;">localized</td>
<td style="text-align: center;">alertness</td>
</tr>
</tbody>
</table>
<h3 id="time-frequency-analysis">Time-Frequency Analysis</h3>
<p>apply a 'window' to the data, then perform the FFT on this windowed data</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/eeg-spectrogram.png" /></p>
<h2 id="challenge">5 Challenge</h2>
<p>Hard to solve the Inverse Problem:</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/eeg-inverse-problem.png" /></p>
]]></content>
      <categories>
        <category>Robotics</category>
        <category>Hardware</category>
      </categories>
      <tags>
        <tag>hardware</tag>
        <tag>eeg</tag>
      </tags>
  </entry>
  <entry>
    <title>Omnibus F4 pro v3</title>
    <url>/2019/03/15/Robotics/Hardware/hardware-omnibusf4/</url>
    <content><![CDATA[<h2 id="introduction">1 Introduction</h2>
<blockquote>
<p>Upgrade version of OMNIBUS F4, the OMNIBUS F4 Pro (Some shop call it as OMNIBUS F4 PRO V2) added SD card supports, has 5v3A BEC, LC filter for Camera and VTX, build in Current sensor for high Integration Frame.</p>
</blockquote>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/omnibusf4.png" alt="omnibusf4" /><figcaption aria-hidden="true">omnibusf4</figcaption>
</figure>
<a id="more"></a>
<h2 id="specifications">2 Specifications</h2>
<ul>
<li>Processor
<ul>
<li>STM32F405 ARM</li>
</ul></li>
<li>Sensors
<ul>
<li>InvenSense MPU6000 IMU (accel, gyro)</li>
<li>BMP280 barometer</li>
<li>Voltage and current sensor</li>
</ul></li>
<li>Interfaces
<ul>
<li>UARTS</li>
<li>PWM outputs</li>
<li>RC input PWM/PPM, SBUS</li>
<li>I2C port for external compass</li>
<li>USB port</li>
<li>Built-in OSD</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>Robotics</category>
        <category>Hardware</category>
      </categories>
      <tags>
        <tag>hardware</tag>
        <tag>flight-controller</tag>
      </tags>
  </entry>
  <entry>
    <title>Hardware Transmitter</title>
    <url>/2019/03/15/Robotics/Hardware/hardware-transmitter/</url>
    <content><![CDATA[<h2 id="简介">1 简介</h2>
<p>针对一个富斯FS-i6发射机及其接收机来学习接收机方面的知识</p>
<h3 id="发射机">1.1 发射机</h3>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/transmitter.png" alt="flysky-transmitter" /><figcaption aria-hidden="true">flysky-transmitter</figcaption>
</figure>
<a id="more"></a>
<h3 id="接收机">1.2 接收机</h3>
<ul>
<li>型号：FS-iA6B</li>
<li>调制方式：GFSK</li>
<li>数据分辨率：1024级</li>
<li>电源标准：4.0-6.5V DC</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/receiver.png" alt="receiver" /><figcaption aria-hidden="true">receiver</figcaption>
</figure>
<h3 id="基本操作">1.3 基本操作</h3>
<ul>
<li>开机：
<ol type="1">
<li>先开发射机Tx</li>
<li>再开接收机Rx</li>
<li>正常情况下接收机红色指示灯常亮</li>
</ol></li>
<li>关机
<ol type="1">
<li>先关接收机Rx</li>
<li>再关发射机Tx</li>
</ol></li>
</ul>
<h2 id="功能介绍">2 功能介绍</h2>
<h3 id="飞行控制">2.1 飞行控制</h3>
<ul>
<li>油门分左手和右手，我选择的是右手油门</li>
<li>左手的摇杆控制的就是飞行器的倾斜和上下俯仰</li>
<li>右手的摇杆控制飞机水平左右旋转和油门加速减速</li>
</ul>
<h3 id="逆转修正">2.2 逆转修正</h3>
<p>当舵机运动方向与预期相反时，可以使用此功能修正、</p>
<h3 id="油门曲线设置">2.3 油门曲线设置</h3>
<p>针对油门操纵杆的动作调整油门输出曲线，使得发动机达到最佳状态</p>
<h3 id="混控功能mix">2.4 混控功能(Mix)</h3>
<p>当接收机收不到信号或者失去控制时，舵机摆臂需要保持的位置</p>
<h2 id="注意">3 注意</h2>
<ul>
<li><p>发射机天线应和模型垂直，而不是指着飞行器（参考路由器天线摆放）</p></li>
<li><p>一共有4组微调杆</p>
<ul>
<li>通道1：副翼</li>
<li>通道2：升降</li>
<li>通道3：油门</li>
<li>通道4：舵机中位</li>
</ul></li>
<li><p>为保持控制质量，应尽量将接收机的两个天线保持垂直</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/antena-place.png" alt="antena-place" /><figcaption aria-hidden="true">antena-place</figcaption>
</figure></li>
<li><p>接收机对码(Binding)</p>
<ol type="1">
<li>发射机选择<strong>接收机设置</strong>功能，选择<strong>对码</strong>进入对码状态</li>
<li>用对码线插入B/VCC通道</li>
<li>用4.0-6.5V DC电源插入CH1-CH6任意通道，进入对码状态，此时LED闪烁</li>
<li>对码成功，发射机自动退出对码状态</li>
<li>拔掉对码线</li>
</ol></li>
</ul>
]]></content>
      <categories>
        <category>Robotics</category>
        <category>Hardware</category>
      </categories>
      <tags>
        <tag>hardware</tag>
        <tag>transmitter</tag>
      </tags>
  </entry>
  <entry>
    <title>Robotics-Force Control</title>
    <url>/2019/01/01/Robotics/Introduction%20to%20Robotics%20Notes/Robotics-Force/</url>
    <content><![CDATA[<h2 id="introduction">1 Introduction</h2>
<p>Mere position control is not suffice is contact is made between end-effector and environment.</p>
<p>So introduce <strong>hybrid position/force controller</strong> to solve the problem. This method is one formalism through which industrial robots might someday be controlled in order to perform tasks requiring force control.</p>
<a id="more"></a>
<h2 id="application-of-robots-to-assembly-tasks">2 Application of Robots to Assembly Tasks</h2>
<ul>
<li><p>Spot welding</p></li>
<li><p>Spray painting</p></li>
<li><p>Pick and place operations</p></li>
<li><p>Future: assembly-line tasks, force is extremely important.</p>
<p>Currently, the dexterity of manipulators remains <strong>quite low</strong> and limit their appplication in the automated assembly area.</p></li>
</ul>
<p>If we can <strong>measure and control contact forces</strong> generated at the hand, we can <strong>imporove the performance without</strong> using bigger, heavier, and more expensive manipulator.</p>
<h2 id="basic-idea">Basic Idea</h2>
<p>Every manipulation task can be broken down into <strong>subtasks</strong> that are defined by a particular <strong>contact situation</strong> occurring between the manipulator end-effector (or tool) and the work environment.</p>
<p>With each subtask, we can associate a set of <strong>constrains</strong></p>
<ul>
<li>mechanical</li>
<li>geometric</li>
</ul>
]]></content>
      <categories>
        <category>Robotics</category>
        <category>Introduction to Robotics Notes</category>
      </categories>
      <tags>
        <tag>control</tag>
        <tag>robotics</tag>
      </tags>
  </entry>
  <entry>
    <title>Robotics-Linear Control</title>
    <url>/2018/12/27/Robotics/Introduction%20to%20Robotics%20Notes/Robotics-Linear%20Control/</url>
    <content><![CDATA[<h2 id="introduction">1 Introduction</h2>
<p><strong>Premise</strong>: Know the means to calculate joint-position correspond to desired end-effector motions.</p>
<p><strong>Problem</strong>: How to cause the manipulator acually to perform these desired motions.</p>
<p><strong>Solution 1</strong>: Linear control system.</p>
<ul>
<li>In fact, non-linear is more usual, linear control is just a <strong>approximate</strong> methods</li>
<li>It's resonable to make such approximation, so lineat control methods are the ones <strong>most often used in industrial practice.</strong></li>
<li>Learn linear first is good for later study</li>
</ul>
<a id="more"></a>
<h2 id="control-law-partitioning">2 Control-Law Partitioning</h2>
<p>Partitioning Method (2 parts):</p>
<ul>
<li>model-based portion: make use of supposed knowledge of <strong><em>m,b,k</em></strong>, to make the system appear as a unit mass<span class="math inline">\(\to\)</span> servo portion simple.</li>
<li>servo portion: make use of <strong><em>feedback</em></strong> to modify the behavior of the system</li>
</ul>
<p>A open-loop equation of motion for the system: <span class="math display">\[
m \ddot { x } + b \dot { x } + k x = f
\]</span> The model-based portion of the control: <span class="math display">\[
f = \alpha f ^ { \prime } + \beta
\]</span> and we choose(because we want to make the ) <span class="math display">\[
\begin{array} { l } { \alpha = m } \\ { \beta = b \dot { x } + k x } \end{array}
\]</span> finally we get <span class="math inline">\(\ddot { x } = f ^ { \prime }\)</span></p>
<p>Graphiclly,we transform a system like this</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/robotics-linear-control.png" alt="robotics-linear-control" /><figcaption aria-hidden="true">robotics-linear-control</figcaption>
</figure>
<p>into a system easier</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/robotics-lin-con-easier.png" alt="easier-system" /><figcaption aria-hidden="true">easier-system</figcaption>
</figure>
<p>What we need to do is design a control law to compute <span class="math inline">\(f ^ { \prime } = - k _ { v } \dot { x } - k _ { p } x\)</span></p>
<p>so it yields <span class="math display">\[
\ddot { x } + k _ { v } \dot { x } + k _ { p } x = 0
\]</span></p>
<h3 id="conclusion">Conclusion</h3>
<ol type="1">
<li>get the system‘s parameters</li>
<li>find <span class="math inline">\(\alpha ,\beta\)</span></li>
<li>calculate <span class="math inline">\(k_v,k_p\)</span> depend on the requirement</li>
</ol>
<h3 id="trajectory-following-control">3. Trajectory-Following Control</h3>
<p>Know: trajectory, a funciton of time <span class="math inline">\(x_d(t)\)</span> and we can get $x_d, x_d $as well</p>
<p>Define: <span class="math inline">\(e=x_d-x\)</span></p>
<p>Design <span class="math inline">\(f ^ { \prime } = \ddot { x } _ { d } + k _ { v } \dot { e } + k _ { p } e\)</span></p>
<p>Get: <span class="math inline">\(\ddot { x } = \ddot { x } _ { d } + k _ { v } \dot { e } + k _ { p } e\)</span></p>
<p>So, we can choose coefficients and design any response we want</p>
]]></content>
      <categories>
        <category>Robotics</category>
        <category>Introduction to Robotics Notes</category>
      </categories>
      <tags>
        <tag>control</tag>
        <tag>robotics</tag>
      </tags>
  </entry>
  <entry>
    <title>Robotics-Nonlinear Control</title>
    <url>/2019/01/01/Robotics/Introduction%20to%20Robotics%20Notes/Robotics-Nonlinear/</url>
    <content><![CDATA[<h2 id="introduction">1 Introduction</h2>
<p>In linear control, we modeled the manipulator by <span class="math inline">\(n\)</span> independent second-order differential equations.</p>
<p>In this chapter, we will base our controller design on the <span class="math inline">\(n \times 1\)</span> vector differential equation</p>
<a id="more"></a>
<h2 id="nonlinear">2 Nonlinear</h2>
<ol type="1">
<li><p>local linearization</p>
<p>When nonlinearities are not severe, <strong>local linearization</strong> can be used in the <strong>neighborhood</strong> of an operating point.</p>
<p>But, manipulator move among regions so <strong>widely separated</strong> that no linearization valid for all regions can be found.</p></li>
<li><p>moving linearization</p>
<p>move the operating point with the manipulator as it moves, always linearizing about the desired position of the manipulator</p></li>
<li><p>deal with the nonlinear directly</p>
<p>the poles of the system will "move", so we can not select fixed gains. Instead, the gains are also time-varying so it will keep the system critically damped</p></li>
<li><p>Example: nonlinear spring</p>
<p>open loop equation: <span class="math inline">\(m \ddot { x } + b \dot { x } + q x ^ { 3 } = f\)</span></p>
<p>servo portion: <span class="math inline">\(f ^ { \prime } = \ddot { x } _ { d } + k _ { v } \dot { e } + k _ { p } e\)</span></p>
<p>model-based portion: <strong>changed</strong></p>
<p>​ <span class="math inline">\(\begin{array} { l } { \alpha = m } \\ { \beta = b \dot { x } + q x ^ { 3 } } \end{array}\)</span></p></li>
</ol>
<p>##3 Control problem for Manipulators</p>
<p>For manipulator, the model is complicated <span class="math display">\[
\tau = M ( \Theta ) \ddot { \Theta } + V ( \Theta , \dot { \Theta } ) + G ( \Theta )
\]</span> where $$ is the position of all the joints.</p>
<p>If we add friction to the model, we get <span class="math display">\[
\tau = M ( \Theta ) \ddot { \Theta } + V ( \Theta , \dot { \Theta } ) + G ( \Theta ) + F ( \Theta , \dot { \Theta } )
\]</span> where we can use our partitioned controller again: <span class="math display">\[
\tau = \alpha \tau ^ { \prime } + \beta
\]</span> and we choose <span class="math display">\[
\begin{aligned} \alpha &amp; = M ( \Theta ) \\ \beta &amp; = V ( \Theta , \dot { \Theta } ) + G ( \Theta ) + F ( \Theta , \dot { \Theta } ) \end{aligned}
\]</span> servo law: <span class="math inline">\(\tau ^ { \prime } = \ddot { \Theta } _ { d } + K _ { v } \dot { E } + K _ { p } E\)</span> where <span class="math inline">\(E = \Theta _ { d } - \Theta\)</span></p>
<p>finally we get <span class="math display">\[
\ddot { E } + K _ { v } \dot { E } + K _ { p } E = 0
\]</span> This solve the problem in theory, but not in practice because</p>
<ol type="1">
<li>computer do it by <strong>discrete</strong> nature</li>
<li><strong>inaccuracy</strong> in manipulator model</li>
</ol>
<h2 id="current-industrial-robot-control-system">4 Current industrial-robot Control System</h2>
<p>Parameters may be inaccurate. So model-based control law maybe <strong>doesn't make sense</strong></p>
<p>For economic reasons, error driven is more usual.</p>
<ul>
<li><p>individual-joint PID control</p>
<p><em>average</em> gain are chosen</p>
<p><span class="math inline">\(\tau ^ { \prime } = \ddot { \Theta } _ { d } + K _ { v } \dot { E } + K _ { p } E + K _ { i } \int Edt\)</span></p></li>
</ul>
<h2 id="lyapunov-stability-analysis">5 Lyapunov Stability Analysis</h2>
<p>A analytically way to evluate stability but <strong>not</strong> the performance.</p>
]]></content>
      <categories>
        <category>Robotics</category>
        <category>Introduction to Robotics Notes</category>
      </categories>
      <tags>
        <tag>control</tag>
        <tag>robotics</tag>
      </tags>
  </entry>
  <entry>
    <title>Robotics-Trajectory</title>
    <url>/2018/12/25/Robotics/Introduction%20to%20Robotics%20Notes/Robotics-Trajectory/</url>
    <content><![CDATA[<h2 id="introduction">1 Introduction</h2>
<blockquote>
<p>trajectory refers to a time history of <strong>position, velocity, and acceleration</strong> for each degree of freedom.</p>
</blockquote>
<p>Concern:</p>
<ul>
<li>Easy description：just desired goal position and orientation</li>
<li>How to generating and representing in computer</li>
</ul>
<a id="more"></a>
<h2 id="general-consideration">2 General consideration</h2>
<ul>
<li>Huamn-interface. Consider <strong>tool frame</strong> <span class="math inline">\(\{T\}\)</span> , in which a user would think and design path.</li>
<li>Path include many <strong>intermediate <em>points</em></strong> (position and orientation)</li>
<li>Want a <strong><em>smooth</em></strong> path, first derivative even second derivative. <em>jerky motions tend to cause increased wear on the mechanism andcause vibrations by exciting resonances in the manipulator</em></li>
</ul>
<h2 id="joint-space-schemes">3 Joint-Space Schemes</h2>
<p>First <strong>get the via points</strong> and then convert it to a set of joint angle by <strong>inverse kinematics</strong></p>
<p>Joint space schemes is the easiest to compute.</p>
<h3 id="cubic-polynomials">3.1 Cubic Polynomials</h3>
<p>Some constrains:</p>
<ul>
<li><span class="math inline">\(θ(0) = θ_0\)</span> initial</li>
<li><span class="math inline">\(θ(t_f ) = θ_f\)</span> final</li>
<li><span class="math inline">\(\dotθ(0) = 0\)</span> continuous in velocity</li>
<li><span class="math inline">\(\dotθ(t_f ) = 0\)</span> continuous in velocity</li>
</ul>
<p>apply <span class="math display">\[
θ(t) = a_0 + a_1t + a_2t^2 + a_3t^3solve the problem
\]</span> to solve the problem <strong>(between two points)</strong></p>
<h3 id="cubic-polynomials-for-a-path-with-via-points">3.2 Cubic polynomials for a path with via points</h3>
<p>What if we wish to specfify the intermediate via points? <strong>(between many points)</strong></p>
<p>constrains becoms</p>
<ul>
<li><span class="math inline">\(θ(0) = θ_0\)</span> initial</li>
<li><span class="math inline">\(θ(t_f ) = θ_f\)</span> final</li>
<li><span class="math inline">\(\dotθ(0) = \dot\theta_0\)</span> continuous in velocity</li>
<li><span class="math inline">\(\dotθ(t_f ) = \dot\theta_f\)</span> continuous in velocity</li>
</ul>
<p>But how we choose the intermediate velocity? There are some method:</p>
<ol type="1">
<li><p>Specified by user</p></li>
<li><p>Choose by computer</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/via-points.png" alt="via-points" /><figcaption aria-hidden="true">via-points</figcaption>
</figure>
<ul>
<li><p>If the slope of lines change sign at via point <span class="math inline">\(\to\)</span>zero velocity</p></li>
<li><p>if the slope of lines does not change sign<span class="math inline">\(\to\)</span>average velocity</p></li>
</ul></li>
</ol>
<h3 id="linear-function-with-parabolic-blends">3.3 Linear function with parabolic blends</h3>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/parabolic1.png" alt="parabolic-1" /><figcaption aria-hidden="true">parabolic-1</figcaption>
</figure>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/parabolic2.png" alt="parabolic2" /> <span class="math display">\[
\ddotθ\times t_b =\frac{θ_h − θ_b}{t_h − t_b}
\]</span></p>
<p><span class="math display">\[
θ_b = θ_0 + \frac12\ddotθ\times t_b^2
\]</span></p>
<p>There are 2 equations and 6 variabels</p>
<p>So, given <span class="math inline">\(\theta_f ,\theta_0, t_h\)</span>, choose <span class="math inline">\(\ddot\theta\to\)</span>we can calculate <span class="math inline">\(t_b\)</span></p>
<h3 id="linear-function-with-parabolic-blends-for-a-path-with-via-points">3.4 Linear function with parabolic blends for a path with via points</h3>
<p>Consider there an arbitrary number of via points</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/via-points.png" alt="parabolic-viapoints" /><figcaption aria-hidden="true">parabolic-viapoints</figcaption>
</figure>
<h2 id="cartesian-space-schemes">4 Cartesian-Space Schemes</h2>
<ul>
<li><p>In Joint-Space, the spatial shape of path taken by the end-effector will be <strong>complicated</strong></p></li>
<li><p>In Cartesian-Space, we can also specify <strong>shape</strong> of the path. Line</p></li>
<li><p>However, Cartesian schemes are more <strong>computationally expensive</strong> because inverse kinematics must be <strong>solved at real time</strong></p></li>
</ul>
<h2 id="geometric-problems-with-cartesian-paths">5 Geometric Problems with Cartesian Paths</h2>
<ol type="1">
<li><p>Intermediate points unreachable</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/Intermediate-points-unreachable.png" alt="Intermediate-points-unreachable" /><figcaption aria-hidden="true">Intermediate-points-unreachable</figcaption>
</figure></li>
<li><p>High joint rates near singularity</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/high-joint-rate.png" alt="high-joint-rate" /><figcaption aria-hidden="true">high-joint-rate</figcaption>
</figure></li>
<li><p>Start and goal reachable in different solutions</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/different-solution.png" alt="different-solution" /><figcaption aria-hidden="true">different-solution</figcaption>
</figure></li>
</ol>
]]></content>
      <categories>
        <category>Robotics</category>
        <category>Introduction to Robotics Notes</category>
      </categories>
      <tags>
        <tag>robotics</tag>
        <tag>trajectory</tag>
      </tags>
  </entry>
  <entry>
    <title>Basic Control Theory</title>
    <url>/2020/04/05/Robotics/MobileRobots/1-basic-contorl/</url>
    <content><![CDATA[<h2 id="about-the-course">About the Course</h2>
<p>what’s in this course</p>
<ul>
<li><p>control theory</p>
<ul>
<li>mathematical play a important role</li>
</ul></li>
<li><p>robot models</p></li>
<li><p>mobility <strong>controllers</strong></p>
<ul>
<li>How to do, not why to do (Not a AI course)</li>
</ul>
<blockquote>
<p>great! I have learned planning in the school so I can focus on the control theory that boost the overall performance</p>
</blockquote></li>
<li><p>application</p></li>
</ul>
<a id="more"></a>
<h2 id="what-is-control-theory">What is control theory</h2>
<p>system: something that changes over time</p>
<p>control: influence that change</p>
<hr />
<p>Building blocks</p>
<ul>
<li>State: <span class="math inline">\(x\)</span> representation of what the system is currently doing</li>
<li>Dynamics</li>
<li>Reference <span class="math inline">\(r\)</span> what we want the system to do</li>
<li>output: <span class="math inline">\(y\)</span> measurement of system</li>
<li>input: <span class="math inline">\(u\)</span> control signal</li>
<li>Feedback: mapping from output to input</li>
</ul>
<h2 id="model">Model</h2>
<p>model is the approximation the real system.</p>
<p>Why model is <strong>important</strong>? because we need to <strong>design</strong> control theory</p>
<p>How we design control system, there are some objectives</p>
<ul>
<li><strong>stability</strong> BIBO bounded in bounded out</li>
<li><strong>tracking</strong></li>
<li><strong>robustness</strong>: model are not perfect, so we need to tolerant parameter</li>
<li>disturbance rejection</li>
<li>optimality: how to do the thing best</li>
</ul>
<p>In implementation, everything is <strong>discrete</strong>/sampled (Taylor series ) <span class="math display">\[
x_{k+1}=x_k+\delta t\dot x_k
\]</span></p>
<h2 id="cruise-controllers">Cruise-Controllers</h2>
<p>Make a car drive a desired speed <span class="math inline">\(r\)</span></p>
<p>Physics: Newton’s Second Law <span class="math display">\[
F=ma
\]</span></p>
<p>State: velocity <span class="math inline">\(x\)</span>, and we should measure velocity as well</p>
<p>input: gas/brake <span class="math inline">\(u\)</span> <span class="math display">\[
F=cu
\]</span> where <span class="math inline">\(c\)</span> is a electro-mechanical transmission coefficient <span class="math display">\[
cu=m\dot x
\]</span> simple model has big power</p>
<hr />
<p>The expected properties of the control signal:</p>
<ul>
<li>small <span class="math inline">\(e\)</span> error gives small <span class="math inline">\(u\)</span> control signal</li>
<li><span class="math inline">\(u\)</span> should NOT be jerky, so the performance would be smooth</li>
<li><span class="math inline">\(u\)</span> should NOT depend on exact <span class="math inline">\(c\)</span> and <span class="math inline">\(m\)</span>, so this will be a robust control model</li>
</ul>
<h3 id="control-design">Control Design</h3>
<p>we got car model <span class="math inline">\(\dot x=\frac{c}{m}u\)</span></p>
<p>we want <span class="math inline">\(x\to r \space\)</span> as <span class="math inline">\(t\to \infin\)</span></p>
<ul>
<li>Attempt 1: Bang-Bang Control
<ul>
<li>Nope, turns out bumpy ride and burns out <strong>actuators</strong></li>
<li>Problem: <strong>over-reacts to small errors</strong></li>
</ul></li>
<li>Attempt 2: P control <span class="math inline">\(u=ke\)</span>
<ul>
<li>Nope, has steady error</li>
<li>Problem: not <strong>tracking</strong></li>
</ul></li>
<li>Attempt 3: <span class="math inline">\(u=ke+\gamma\frac{m}{c}x\)</span>
<ul>
<li>Nope, yet cancel the steady error</li>
<li>Problem: <strong>not robust</strong></li>
</ul></li>
<li>Attempt 4: PI controller, even, <strong>PID controller</strong></li>
</ul>
<h2 id="pid-controller">PID Controller</h2>
<p>Widely used controller <span class="math display">\[
u(t)=k_{P} e(t)+k_{I} \int_{0}^{t} e(\tau) d \tau+k_{D} \frac{d e(t)}{d t}
\]</span> 3 knobs we can tune <span class="math inline">\(k_P, k_I,k_D\)</span></p>
<ul>
<li>P: contributes to stability,medium-rate responsiveness</li>
<li>I: tracking and disturbance rejection, slow-rate responsiveness
<ul>
<li>may cause <strong>oscillation</strong></li>
</ul></li>
<li>D: Fast-rate responsiveness. Sensitive to noise</li>
</ul>
<h2 id="implementation">Implementation</h2>
<p>First, translate into something implementable</p>
<ul>
<li>find the sample time <span class="math inline">\(\Delta t\)</span></li>
<li>integral： <span class="math inline">\(E_{new}=E_{old}+\Delta te\)</span></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">read e;</span><br><span class="line">e_dot&#x3D;e-old_e;</span><br><span class="line">E&#x3D;E+e;</span><br><span class="line">u&#x3D;kP*e+kD*e_dot+kI*E;</span><br><span class="line">old_e&#x3D;e;</span><br></pre></td></tr></table></figure>
<h2 id="example-quadrotor-altitude-control">Example: Quadrotor Altitude Control</h2>
<p><span class="math display">\[
\ddot x=cu-g
\\u=PID
\]</span></p>
<h2 id="programming-assignments-week-1">Programming Assignments: Week 1</h2>
<p>Why assignments worth my time</p>
<ul>
<li>opportunity to apply the equation</li>
<li>learn Matlab</li>
</ul>
]]></content>
      <tags>
        <tag>control</tag>
        <tag>robotics</tag>
      </tags>
  </entry>
  <entry>
    <title>Mobile Robots</title>
    <url>/2020/04/08/Robotics/MobileRobots/2-mobile-robots/</url>
    <content><![CDATA[<h2 id="how-to-drive-robots">How to Drive Robots</h2>
<p>We mainly need 3 part</p>
<ul>
<li>Controller</li>
<li>Sensors</li>
<li>Robot model</li>
</ul>
<p>Some basic facts we need know</p>
<ul>
<li>the world is changing</li>
<li>controller must be able to respond to environmental conditions</li>
<li>Instead of building one complicated controller, we <strong>divide and conquer</strong> and build some <strong>Behavior</strong>
<ul>
<li>goal-to-goal</li>
<li>obstacles-avoid</li>
<li>line-follow</li>
</ul></li>
</ul>
<a id="more"></a>
<h2 id="robot-model-differential-drive-robots">Robot Model – Differential Drive Robots</h2>
<p>This is a very common type</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/20200408010709.png" alt="image-20200408010708398" /><figcaption aria-hidden="true">image-20200408010708398</figcaption>
</figure>
<p>we need to know some basic parameter <span class="math inline">\(L\)</span> , <span class="math inline">\(R\)</span>, easy to measure</p>
<p>What we <strong>can</strong> control: <span class="math inline">\(v_r\)</span> and <span class="math inline">\(v_l\)</span></p>
<p>What we <strong>want</strong> to control: <strong>position <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span></strong> and <strong>orientation <span class="math inline">\(\phi\)</span></strong></p>
<p>The real <strong>input of the model</strong> is velocity of wheels <span class="math inline">\(v_r\)</span> and <span class="math inline">\(v_l\)</span>. But in this way, the design of controller could be very hard, so we can translate the input to <strong>middle input form</strong></p>
<p>Change <span class="math inline">\(v_r\)</span> and <span class="math inline">\(v_l\)</span> <span class="math inline">\(\to\)</span> <span class="math inline">\(v\)</span> and <span class="math inline">\(w\)</span> <span class="math display">\[
v=\frac{R}{2}(v_l+v_r)
\\ 
w=\frac{R}{L}(v_r-v_l)
\]</span> the <strong>output of the model</strong> is the state of the robot</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/20200408011114.png" alt="image-20200408011112780" /><figcaption aria-hidden="true">image-20200408011112780</figcaption>
</figure>
<p>Then the physic would be simplified <span class="math display">\[
\left\{\begin{array}{l}
\dot{x}=v \cos \phi \\
\dot{y}=v \sin \phi \\
\dot{\phi}=\omega
\end{array}\right.
\]</span></p>
<blockquote>
<p>In this way, we can control the <span class="math inline">\(v\)</span> and <span class="math inline">\(w\)</span> by the controller because <span class="math inline">\(v_r\)</span> and <span class="math inline">\(v_l\)</span> could be calculated by given <span class="math inline">\(v\)</span> and <span class="math inline">\(w\)</span></p>
</blockquote>
<h2 id="odometry">Odometry</h2>
<p>Two possibilities</p>
<ul>
<li>Internal sensors
<ul>
<li><p>Orientation: compass</p></li>
<li><p>Position: accelerometers, gryoscopes</p></li>
<li><p>Wheel Encoders: DRIFT should be noticed</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/20200418154633.png" alt="image-20200417162710138" /><figcaption aria-hidden="true">image-20200417162710138</figcaption>
</figure></li>
</ul></li>
<li>External sensors</li>
</ul>
<h2 id="sensor">Sensor</h2>
<p>Robots need to the world around them</p>
<p>standard sensor suiite, ‘SKIRT’ range</p>
<p>Abstraction, assume we know the <strong>distance</strong> and <strong>direction</strong> to all obstacles around us</p>
<p>Then, we can calculate the position of the obstacles</p>
<p>IR sensor: map from voltage to measured distance.</p>
<h2 id="behavior-based">Behavior-Based</h2>
<p>World is changing and unknown <span class="math inline">\(\to\)</span> Do not make sense to over-plan <span class="math inline">\(\to\)</span> develope a library of useful controller</p>
<p>2 Basic behavior:</p>
<ul>
<li>Go-to-goal</li>
<li>Avoid-obstacal</li>
</ul>
<h2 id="go-to-goal">Go to Goal</h2>
<h3 id="ver.1">Ver.1</h3>
<p>A Differential-drive, wheeled mobile robot</p>
<p>Now we want it to drive in a desired heading, how should we control <span class="math inline">\(w\)</span>?</p>
<p>Control perspective：</p>
<ul>
<li>Reference: <span class="math inline">\(\phi_d\)</span></li>
<li>error: <span class="math inline">\(\phi_d-\phi\)</span></li>
<li>model: <span class="math inline">\(\dot{\phi}=w\)</span></li>
</ul>
<p>Why not use PID? <span class="math display">\[
w=K_pe+K_I\sum ed\tau+K_d\dot e
\]</span> <strong>NO</strong></p>
<h3 id="ver.2">Ver.2</h3>
<p>Since the angle is something <strong>special</strong> we should consider</p>
<ul>
<li>Ensure that <span class="math inline">\(e\)</span> is between <span class="math inline">\([-\pi,\pi]\)</span></li>
<li>Standard strick is to use <strong>atan2</strong></li>
</ul>
<h2 id="obstacle-avoidance">Obstacle Avoidance</h2>
<p>Use the same idea by defining a desired heading</p>
<p>How to combine two goals？</p>
<ul>
<li>Winner takes all = hard switch
<ul>
<li>Easy to analysis</li>
</ul></li>
<li>Blending = combined behaviors
<ul>
<li>Good performance</li>
</ul></li>
</ul>
]]></content>
      <tags>
        <tag>control</tag>
        <tag>robotics</tag>
      </tags>
  </entry>
  <entry>
    <title>Linear System</title>
    <url>/2020/04/21/Robotics/MobileRobots/3-linear-system/</url>
    <content><![CDATA[<h2 id="simple-robot">Simple Robot</h2>
<p>We need a more systematic way in discussion</p>
<p>Give a point mass on a line whose acceleration is directly controlled:</p>
<p>Translate the physics model into state space form, 3 steps</p>
<ol type="1">
<li>Pick the state variables</li>
<li>High order to low order</li>
<li>Put these in terms of state, input and output</li>
</ol>
<p><span class="math display">\[
\dot{x}=\left[\begin{array}{c}
\dot{x}_{1} \\
\dot{x}_{2}
\end{array}\right]=\left[\begin{array}{c}
x_{2} \\
u
\end{array}\right]=\left[\begin{array}{cc}
0 &amp; 1 \\
0 &amp; 0
\end{array}\right]\left[\begin{array}{c}
x_{1} \\
x_{2}
\end{array}\right]+\left[\begin{array}{c}
0 \\
1
\end{array}\right] u
\]</span></p>
<p><span class="math display">\[
y=p=x_1=[1 \space0]x
\]</span></p>
<p>Write in a more <strong>general</strong> form <span class="math display">\[
\begin{aligned}
&amp;\dot{x}=A x+B u\\
&amp;y=C x
\end{aligned}
\]</span> Here, <span class="math inline">\(A\)</span> is given by physics. What we can design is <span class="math inline">\(B\)</span> (how we control the system) and <span class="math inline">\(C\)</span> (how we sensor the system)</p>
<a id="more"></a>
<h2 id="state-space-models-linearization">State-Space Models &amp; Linearization</h2>
<p>We need know how the system works, then we can model it using physics</p>
<p>But sometimes the system is non-linear, so we need linearization` <span class="math display">\[
\dot{x}=f(x, u), \quad y=h(x)
\]</span></p>
<ol type="1">
<li>Find a operating point</li>
<li>Taylor expansion</li>
</ol>
<p><span class="math display">\[
 \dot{\delta} x=f\left(x_{o}+\delta x, u_{o}+\delta u\right)
=f\left(x_{o}, u_{o}\right)+\frac{\partial f}{\partial x}\left(x_{o}, u_{o}\right) \delta x+\frac{\partial f}{\partial u}\left(x_{o}, u_{o}\right) \delta u+ H.O.T
\]</span></p>
<p><span class="math inline">\(H.O.T\)</span> for high order terms</p>
<blockquote>
<p>Sometimes the linearization do not give reasonable models</p>
</blockquote>
<h2 id="solving-ode">Solving ODE</h2>
<p><span class="math display">\[
e^{A t}=\sum_{k=0}^{\infty} \frac{A^{k} t^{k}}{k !}
\]</span></p>
<p>The State Transition Matrix <span class="math display">\[
e^{A\left(t-t_{0}\right)}=\Phi\left(t, t_{0}\right)
\]</span> If we do not apply a control system, then <span class="math inline">\(\dot x=Ax\)</span>, then <span class="math display">\[
 x(t)=\Phi(t, \tau) x(\tau)
\]</span> If we have the controlled system: <span class="math inline">\(\dot x=Ax+Bu\)</span>, then <span class="math display">\[
x(t)=\Phi\left(t, t_{0}\right) x\left(t_{0}\right)+\int_{t_{0}}^{t} \Phi(t, \tau) B u(\tau) d \tau
\]</span> We can verify the answers by checking the initial point and derivation</p>
<p>Why so care about the solution?</p>
<p>Because we can write the <span class="math inline">\(y\)</span> <span class="math display">\[
y=Cx
\]</span></p>
<h2 id="stability">Stability</h2>
<p><span class="math display">\[
\dot{x}=A x \Rightarrow x(t)=e^{A t} x(0)
\]</span></p>
<p>By calculating the eigenvalue of <span class="math inline">\(A\)</span></p>
<p>When all eigenvalue of <span class="math inline">\(A\)</span> is negative: <span class="math display">\[
\operatorname{Re}(\lambda)&lt;0, \forall \lambda \in \operatorname{eig}(A)
\]</span></p>
<h2 id="design-feedback-control">Design Feedback Control</h2>
<p>How? Recall the control system <span class="math display">\[
\begin{aligned}&amp;\dot{x}=A x+B u\\&amp;y=C x\end{aligned}
\]</span> Let <span class="math inline">\(u\)</span> related with <span class="math inline">\(y\)</span>, say <span class="math inline">\(u=-Ky\)</span>, than, the <span class="math inline">\(A\)</span> matrix changes! <span class="math display">\[
\dot x=Ax-BKCx=(A-BKC)x
\]</span> Make sure that <span class="math inline">\(Re(eig(A-BKC))&lt;0\)</span></p>
<h2 id="example">Example</h2>
<h3 id="modeling">Modeling</h3>
<p>For <strong>Physics</strong> <span class="math display">\[
m \ddot{f}=\alpha \dot{f}+\beta f+c p
\]</span> For <strong>Human</strong></p>
<ol type="1">
<li>Pick the state variables</li>
<li>High order to low order</li>
<li>Put these in terms of state, input and output</li>
</ol>
<p>For <strong>Math</strong></p>
<ol type="1">
<li><span class="math inline">\(x=\left[\begin{array}{c} f \\ \dot{f} \end{array}\right] \quad u=p \quad y=f\)</span></li>
<li><span class="math inline">\(\begin{aligned} &amp;\dot{f}=\dot{x}_{\hat{1}}=x_{2}\\ &amp;\ddot{f}=\dot{x}_{2}=\frac{1}{m}\left(\alpha x_{2}+\beta x_{1}+c u\right) \end{aligned}\)</span></li>
<li><span class="math inline">\(\dot{x}=\left[\begin{array}{l} \dot{x}_{1} \\ \dot{x}_{2} \end{array}\right]=\left[\begin{array}{l} x_{2} \\ \frac{1}{m}\left(\alpha x_{2}+\beta x_{1}+c u\right) \end{array}\right]\)</span></li>
</ol>
<p>For <strong>Control</strong> <span class="math display">\[
\begin{array}{l}
x=\left[\begin{array}{c}
f \\
\dot{f}
\end{array}\right] \quad u=p \quad y=f \\
(A, B, C)=\left(\left[\begin{array}{cc}
0 &amp; 1 \\
\frac{\beta}{m} &amp; \frac{\alpha}{m}
\end{array}\right],\left[\begin{array}{c}
0 \\
\frac{c}{m}
\end{array}\right],\left[\begin{array}{cc}
1 &amp; 0
\end{array}\right]\right)
\end{array}
\]</span></p>
<h3 id="linearization">Linearization</h3>
<p>For physics <span class="math display">\[
\ddot{z}=\ell z^{2}+\gamma \dot{z}+c \tau \quad x=\left[\begin{array}{c}
z \\
\dot{z}
\end{array}\right] \quad u=\tau
\]</span> If we want to linearize the system around <span class="math inline">\(x=0\)</span> (<strong>important</strong>!) <span class="math display">\[
\begin{array}{c}
A=\left[\begin{array}{cc}
\frac{\partial f_{1}}{\partial x_{1}} &amp; \frac{\partial f_{1}}{\partial x_{2}} \\
\frac{\partial f_{2}}{\partial x_{1}} &amp; \frac{\partial f_{2}}{\partial x_{2}}
\end{array}\right]_{x=(0,0)}=\left[\begin{array}{cc}
0 &amp; 1 \\
2 \ell x_{1} &amp; \gamma
\end{array}\right]_{x=(0,0)}=\left[\begin{array}{cc}
0 &amp; 1 \\
0 &amp; \gamma
\end{array}\right] \\
B=\left[\begin{array}{c}
\frac{\partial f_{1}}{\partial u} \\
\frac{\partial f_{2}}{\partial u}
\end{array}\right]_{x=(0,0)}=\left[\begin{array}{c}
0 \\
c
\end{array}\right]_{x=(0,0)}=\left[\begin{array}{c}
0 \\
c
\end{array}\right]
\end{array}
\]</span></p>
]]></content>
      <tags>
        <tag>control</tag>
        <tag>robotics</tag>
      </tags>
  </entry>
  <entry>
    <title>Design Contrl</title>
    <url>/2020/04/27/Robotics/MobileRobots/4-control-design/</url>
    <content><![CDATA[<p>We need <span class="math inline">\(x\)</span> but we do have is only <span class="math inline">\(y\)</span>. What can we do?</p>
<ul>
<li>Design <span class="math inline">\(u\)</span> as if we had <span class="math inline">\(x\)</span></li>
<li>Figure out <span class="math inline">\(x\)</span> from <span class="math inline">\(y\)</span></li>
</ul>
<h2 id="assume-we-got-x">Assume We Got <span class="math inline">\(x\)</span></h2>
<p>We can design the <span class="math inline">\(k_1\)</span> and <span class="math inline">\(k_2\)</span> to make the <strong>eigenvalue</strong> of the closed-loop system to be <strong>desired</strong> (<strong>negative</strong>)</p>
<blockquote>
<p>e.g. If we want to the eigen value of the <span class="math inline">\(-1\)</span>, then, <span class="math inline">\(\varphi(\lambda)=(\lambda+1)(\lambda+1)=\lambda^{2}+2 \lambda+1\)</span></p>
<p>and we got <span class="math inline">\(\chi_{A-B K}=\lambda^{2}+k_{2} \lambda+k_{1}\)</span></p>
<p>so just let <span class="math inline">\(k_2=2\)</span> and <span class="math inline">\(k_1=1\)</span>, the system would be stable</p>
</blockquote>
<p>To say it in another way, we place the <strong>pole</strong> of the system on the desired position</p>
<p>Still, we have some question about the method?</p>
<ul>
<li>This method is not always <strong>possible</strong>
<ul>
<li>The system needs to be controllable</li>
</ul></li>
<li>It’s a science and art of <strong>picking</strong> the eigenvalue
<ul>
<li>No clear-cut answer</li>
</ul></li>
</ul>
<a id="more"></a>
<h2 id="controllability">Controllability</h2>
<p>The key matter here is the <span class="math inline">\(B\)</span> matrix, how <em>rich</em> is <span class="math inline">\(B\)</span> that we can control the system.</p>
If we write the system this way $$
<span class="math display">\[\begin{aligned}
\begin{array}{l}
x_{1}=A x_{0}+B u_{0}=B u_{0}\\

x_{2}=A x_{1}+B u_{1}=A B u_{0}+B u_{1} \\
x_{3}=A x_{2}+B u_{2}=A^{2} B u_{0}+A B u_{1}+B u_{2}
\end{array}
\end{aligned}\]</span>
<p><span class="math display">\[
Then we can transform the system into 
\]</span> x=u=[B  AB  ... A^{n-1}B]u $$ if <span class="math inline">\(Rank(\Gamma)=n\)</span>, it’s possible to <strong>fully control</strong> the system</p>
<p>if the system can be <strong>fully controlled</strong>, then we can put <strong>arbitrary pole</strong> <span class="math display">\[
Rank(\Gamma)\to Fully \ Control \to Arbitrary\ Pole
\]</span></p>
<blockquote>
<p>Application: Segway Robots</p>
<p>Segway robots is simply unicycle+Inverted Pendulum+…</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/20200508011707.png" alt="image-20200427204338632" /><figcaption aria-hidden="true">image-20200427204338632</figcaption>
</figure>
<p>Model the system <span class="math display">\[
\begin{array}{l}
x=\left[\begin{array}{lllllll}
x_{1} &amp; x_{2} &amp; v &amp; \psi &amp; \dot{\psi} &amp; \phi &amp; \dot{\phi}
\end{array}\right]^{T} \\
u=\left[\begin{array}{ll}
\tau_{L} &amp; \tau_{R}
\end{array}\right]^{T}
\end{array}
\]</span> After linearization, <span class="math inline">\(Rank(\Gamma)=6&lt;7\)</span>, so the system is not fully controllality</p>
<p>That's because unicycle mess up while linearization around (0,0)</p>
<p>So we can shave off the <span class="math inline">\(x_1\)</span> and <span class="math inline">\(x_2\)</span>. Now the system is fully controlled</p>
<ul>
<li>In this way, we only control the <strong>curvature</strong> of the path</li>
</ul>
</blockquote>
<h2 id="observability">Observability</h2>
<p>Actually, we don’t the real value of <span class="math inline">\(x\)</span>, so we need sensor or observer to estimate <span class="math inline">\(x\)</span></p>
<p>Luenberger observer: predictor + corrector <span class="math display">\[
\dot{ \hat{x}}=A\hat x+L(y-C \hat x)
\]</span> predictor + corrector</p>
<ul>
<li><p>Does it work?</p></li>
<li><p>How to pick <span class="math inline">\(L\)</span></p>
<p>We want to stabilize the estimation error, <span class="math inline">\(e=x-\hat x\)</span> <span class="math display">\[
\dot e=(A-LC)e
\]</span> so the it should be <span class="math inline">\(Re(eig(A-LC))&lt;0\)</span></p></li>
</ul>
<p>The system is completely observable if it is possible to recover the initial state from the output <span class="math display">\[
\Omega=\left[\begin{array}{c}
C \\
C A \\
\vdots \\
C A^{n-1}
\end{array}\right]
\]</span></p>
<p><span class="math display">\[
rank(\Omega)=n
\]</span></p>
<h2 id="put-it-together">Put it Together!</h2>
<p>Now we have good building blocks</p>
<ul>
<li>controllability, observability, state feedback, observers, pole-placement</li>
</ul>
<p>How do we put everything together?</p>
<p>Answer: <strong>Separation Principle</strong></p>
<ol type="1">
<li><p>First of all, we need to make sure that our linear system is CC and CO</p></li>
<li><p>Design state feedback controller as if we had <span class="math inline">\(x\)</span></p>
<p>let <span class="math inline">\(u=-Kx\)</span>, and design <span class="math inline">\(\dot x=(A-BK)x\)</span></p></li>
<li><p>Estimate <span class="math inline">\(x\)</span> using observer, make sure the error estimation is zero</p>
<p><span class="math inline">\(\dot e=(A-LC)e\)</span></p></li>
<li><p>Analyze their joint dynamics, notice that <span class="math inline">\(e=x-\hat x\)</span></p>
<p>Then <span class="math inline">\(\dot{x}=A x-B K \hat{x}=A x-B K(x-e)=(A-B K) x+B K e\)</span></p>
<p>now we want <span class="math inline">\(x\)</span> and <span class="math inline">\(e\)</span> both go to zero <span class="math display">\[
\left[\begin{array}{c}
\dot{x} \\
\dot{e}
\end{array}\right]=\left[\begin{array}{cc}
A-B K &amp; B K \\
0 &amp; A-L C
\end{array}\right]\left[\begin{array}{c}
x \\
e
\end{array}\right]
\]</span> Since this is an upper triangular block-matrix. So the eigenvalues are given by the <strong>diagonal blocks</strong></p>
<p><strong>EVERYTHING WORKS</strong> because they are <strong>separated</strong></p></li>
</ol>
<h2 id="practical-considerations">Practical Considerations</h2>
<ul>
<li><p>Eigenvalue Selection</p>
<ol type="1">
<li>Observer should be faster than the controller.</li>
<li>So we need to make sure the eigenvalue of observer smaller than the controller</li>
</ol></li>
<li><p>Reference Tracking</p>
<ol type="1">
<li>We want to move the robots to <span class="math inline">\(\theta_d\)</span>, so the <span class="math inline">\(e\)</span> became <span class="math inline">\(\begin{array}{c} \theta-\theta{_d} \\\dot \theta \end{array}\)</span></li>
<li>transform the system into regular system, and apply regular methodology</li>
</ol></li>
<li><p>Beyond Pole Placement</p>
<ul>
<li><p>The methodology we developed does not need to be based on pole placement</p></li>
<li><p>e.g. <span class="math inline">\(K\)</span> could be calculated by using LQ optimal control</p>
<p><span class="math inline">\(L\)</span> could be calculated by using the Kalman Filter</p></li>
</ul></li>
</ul>
<h2 id="example">Example</h2>
<h3 id="part-1-design">Part 1: Design</h3>
<p>We have a system <span class="math inline">\(\dot x=Ax\)</span>, and <span class="math inline">\(eig(A)=0\)</span>, so the system is unstable.</p>
<p>Hence we introduce control.</p>
<ol type="1">
<li><p>See what we can control, and write down the <span class="math inline">\(B\)</span> matrix to check is this system controllable by checking the <span class="math inline">\(\Gamma\)</span> Matrix</p>
<ul>
<li>If the system is <strong>uncontrollable</strong>, then we should <strong>introduce more motors</strong></li>
</ul></li>
<li><p>Design state feedback control <span class="math inline">\(u=-Kx\)</span>, we get <span class="math inline">\(\dot x=(A-BK)x\)</span></p>
<ul>
<li>Pick favorite eigen value, calculate <span class="math inline">\(K\)</span></li>
</ul></li>
<li><p>Choose what we can “see”, what we can sensor, measure. In this we get our <span class="math inline">\(C\)</span> matrix to check is this system observable by checking the <span class="math inline">\(\Omega\)</span> matrix</p></li>
<li><p>Design the estimator <span class="math inline">\(\dot {\hat {x}}=A \hat{x}+B u+L(y-C \hat{x})\)</span> we get $e=(A-LC)e $ and calculate <span class="math inline">\(L\)</span></p></li>
</ol>
<h3 id="part-2-executing">Part 2: Executing</h3>
<p>Loop</p>
<ol type="1">
<li>Initialize <span class="math inline">\(t=t_0 ,x=x_o,\hat x=\hat{x_0}\)</span></li>
<li>Start Loop (dt increments)
<ol type="1">
<li>read the output</li>
<li>Compute control signal <span class="math inline">\(u=-K\hat x\)</span></li>
<li>send the control signal to the motors</li>
<li>output and compute control signal <span class="math inline">\(u=-K\hat x\)</span></li>
<li>update the <span class="math inline">\(\hat x\)</span> using <span class="math inline">\(\dot {\hat {x}}=A \hat{x}+B u+L(y-C \hat{x})\)</span> and <span class="math inline">\(\hat{x}_{k+1}=\hat{x}_{k}+d t \hat{x}\)</span></li>
</ol></li>
</ol>
]]></content>
      <tags>
        <tag>control</tag>
        <tag>robotics</tag>
      </tags>
  </entry>
  <entry>
    <title>Hybrid Systems</title>
    <url>/2020/05/08/Robotics/MobileRobots/5-hybrid-systems/</url>
    <content><![CDATA[<h2 id="switches-everywhere">Switches Everywhere</h2>
<p>Why should we switch? The robotics world is very complicated, so we should <strong>change</strong> our model and control method when situation changes.</p>
<ul>
<li>By necessity: the dynamics change</li>
<li>By design: we want the robots to behave differently</li>
</ul>
<p>What we are should deal with while switching?</p>
<ul>
<li>Model</li>
<li>Stability</li>
<li>Compositionality</li>
<li>Traps</li>
</ul>
<a id="more"></a>
<h2 id="model-hybrid-automata">Model: Hybrid Automata</h2>
<p>This is a finite state machine.</p>
<ul>
<li>Dynamics: <span class="math inline">\(\dot x=f_q(x,u)\)</span>, <span class="math inline">\(q\)</span> stand for discrete state</li>
<li>when <span class="math inline">\(x\)</span> is in the guard conditions, state <span class="math inline">\(q\)</span> change</li>
<li>Reset the state</li>
</ul>
<blockquote>
<p>A Simple 2-Mode System <span class="math display">\[
\begin{aligned}
&amp;\dot{x}=A_{1} x=\left[\begin{array}{cc}
-\epsilon &amp; 1 \\
-2 &amp; -\epsilon
\end{array}\right] x\\
&amp;\dot{x}=A_{2} x=\left[\begin{array}{cc}
-\epsilon &amp; 2 \\
-1 &amp; -\epsilon
\end{array}\right] x
\end{aligned}
\]</span></p>
<p><span class="math display">\[
eig(A_i)=-\epsilon+1.41i
\]</span></p>
<p>Both two system is stable.</p>
<p>Now we combine them with a hybrid automata</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/20200508011603.png" alt="image-20200508011600344" style="zoom: 25%;" /></p>
<p>But what if we change the automata</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/20200508011936.png" alt="image-20200508011934625" style="zoom:25%;" /></p>
</blockquote>
<p>Punchlines</p>
<ul>
<li>The combination of two stable modes may be unstable</li>
</ul>
<h2 id="stability">Stability</h2>
<p>If all the individual modes are stable, then</p>
<ul>
<li>Existentially Stable. Since we can pick a mode and never change</li>
</ul>
<p>In practical, we should be aware of the potential danger and <strong>test, test, test!</strong></p>
<h2 id="time-consideration">Time Consideration</h2>
<p>The ball bounces an infinite number of times in finite time</p>
<ul>
<li>Cause simulations crash</li>
<li>hybrid system is undefined beyond this time</li>
<li>Know as the <strong>Zeno Phenomenon</strong></li>
</ul>
<p>How to deal with it?</p>
<ul>
<li>Sliding Mode Control</li>
</ul>
<p>A general example:</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/20200508015747.png" alt="image-20200508015745315" />We should keep <strong>sliding</strong> along the switching surface (along the line )</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/20200508021906.png" alt="image-20200508021905440" /><figcaption aria-hidden="true">image-20200508021905440</figcaption>
</figure>
<ul>
<li>Say this another way: <span class="math inline">\(\frac{\partial g}{\partial x} f_{1}&lt;0 \text { AND } \frac{\partial g}{\partial x} f_{2}&gt;0\)</span></li>
<li>That means <span class="math inline">\(T\)</span> and <span class="math inline">\(f_1\)</span> / <span class="math inline">\(f_2\)</span> are in <strong>different</strong> / <strong>the same</strong> directions</li>
</ul>
<p><strong>Summary: Do a test, it should satisfy $ f_{1}&lt;0   f_{2}&gt;0 $ at <span class="math inline">\(g(x)=0\)</span></strong></p>
<h2 id="regularizations">Regularizations</h2>
<p>What we want: <span class="math inline">\(\frac{dg}{dt}=0\)</span> <span class="math display">\[
\frac{d g}{d t}=\frac{\partial g}{\partial x} \dot{x}=\frac{\partial g}{\partial x}\left(\sigma_{1} f_{1}+\sigma_{2} f_{2}\right)=\sigma_{1} L_{f_{1}} g+\sigma_{2} L_{f_{2}} g=0
\]</span> So <span class="math display">\[
\sigma_{2}=-\sigma_{1} \frac{L_{f_{1}} g}{L_{f_{2}} g}
\]</span> And we add some constraints <span class="math display">\[
\sigma_1+\sigma_2=1
\\ \sigma_1&gt;0 
\\ \sigma_2&gt;0
\]</span> Design</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/20200602192608.png" alt="image-20200508024227963" /><figcaption aria-hidden="true">image-20200508024227963</figcaption>
</figure>
<h2 id="all-in-one">All in One</h2>
<p>Type 1 Zeno: the guard condition is actually the same but flipped</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/20200508101550.png" alt="image-20200508101549040" /><figcaption aria-hidden="true">image-20200508101549040</figcaption>
</figure>
<p>Test pass which means we must do sliding control to avoid Zeno effect</p>
]]></content>
      <tags>
        <tag>control</tag>
        <tag>robotics</tag>
      </tags>
  </entry>
  <entry>
    <title>The Navigation Problem</title>
    <url>/2020/05/09/Robotics/MobileRobots/6-navigation-problem/</url>
    <content><![CDATA[<h2 id="behavior">Behavior</h2>
<p>Use control theory to describe the problem</p>
<ol type="1">
<li><p>We need a model <span class="math display">\[
\dot x=u
\]</span></p></li>
<li><p>We need 2 basic behaviors</p>
<ul>
<li><p>Go-To-Goal: <span class="math inline">\(e=x_g-x\)</span>, <span class="math inline">\(u=Ke\)</span>, <span class="math inline">\(\dot e=-\dot x=-Ke\)</span></p>
<p>A concern: This is a linear controller which means the robot goes faster the further away the goal is. So in practice, make the gain <span class="math inline">\(K\)</span> a function of <span class="math inline">\(e\)</span></p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/20200509170004.png" alt="image-20200509165421125" /><figcaption aria-hidden="true">image-20200509165421125</figcaption>
</figure></li>
<li><p>Avoid-Obstacle:</p>
<p>Concern: the robot drives off to infinity, we care less the closer we get?</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/20200509170011.png" alt="image-20200509165836313" /><figcaption aria-hidden="true">image-20200509165836313</figcaption>
</figure></li>
</ul></li>
<li><p>Figure out the mode transitions</p></li>
</ol>
<a id="more"></a>
<h3 id="hard-switch-vs.-blending">Hard Switch vs. Blending</h3>
<p>This is actually a philosophical question: can robots do two thing at the same time?</p>
<p>Hard Switch</p>
<ul>
<li>Pro: performance guarantees</li>
<li>Con: bumpy ride and will became Zeno problem</li>
</ul>
<p>Blending:</p>
<ul>
<li>Pro: smooth ride</li>
<li>Con: no guarantees</li>
</ul>
<h2 id="boundary-following">Boundary Following</h2>
<p>What is convex: A set is convex if every line in-between two points in the set lies in the set</p>
<p>Non-Convex situation is worse!</p>
<p>How to follow the wall? Maintain a <strong>constant</strong> distance to the obstacle <span class="math display">\[
u_{FW}=\alpha R(\pi/2)u_{AO}
\]</span> Which direction to choose? Clockwise or Counter-Clockwise?</p>
<ul>
<li>No obvious answer</li>
<li>Let go-to-goal behavior decide, still some issue
<ul>
<li>When?</li>
<li>How to decide <span class="math inline">\(\alpha\)</span></li>
</ul></li>
</ul>
<p>The Induced Mode</p>
<p>Design <span class="math display">\[
g(x)=\frac{1}{2}\left(\left\|x-x_{o}\right\|^{2}-\Delta^{2}\right)=0
\]</span> And use the induced mode method in Chapter 5 to calculate what <span class="math inline">\(\dot x\)</span> should be</p>
<p>In fact, the calculation give the same result as we mentioned in Boundary Following</p>
<p>Now the problem is that when should we <strong>stop</strong> following the wall?</p>
<h2 id="complete-system">Complete System</h2>
<p>Enough progress <span class="math inline">\(||x-x_g||&lt;||x(\tau)-x_g)||\)</span></p>
<ul>
<li>where <span class="math inline">\(\tau=\)</span> time that last switch</li>
</ul>
<p>and clear shot to the goal</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/20200520005130.png" alt="image-20200520005129071" /><figcaption aria-hidden="true">image-20200520005129071</figcaption>
</figure>
<p>In theory, this system or framework works, however, there are some practical considerations need to be considered</p>
<ul>
<li>Non-Point-Obstacles
<ul>
<li>How to define the distance to the obstacles?
<ul>
<li>Simply the closest distance</li>
<li>Weigh and add the obstacle vectors (Much better)</li>
<li>Weigh and add depending on distance and direction of travel (Best)</li>
<li>If we have a map, then plan (Most bestest)</li>
</ul></li>
</ul></li>
<li>Fat Guards
<ul>
<li>g(t) should be a line but a range</li>
</ul></li>
<li>Tweak, Tweak, Tweak the parameter</li>
</ul>
]]></content>
      <tags>
        <tag>control</tag>
        <tag>robotics</tag>
      </tags>
  </entry>
  <entry>
    <title>Put All Together</title>
    <url>/2020/05/20/Robotics/MobileRobots/7-put-together/</url>
    <content><![CDATA[<h2 id="abstractions-and-approximations">Abstractions and Approximations</h2>
<p>We have made some assumptions so far</p>
<ul>
<li>Dynamics, <span class="math inline">\(\dot x=u\)</span>, <strong>NOT even close to being reasonable!</strong></li>
<li>Sensors, we can measure distance and angle</li>
</ul>
<p>Recall teh unicycle model, we want to our system behave like $x=u $</p>
<p>How? A Layered Architercture</p>
<ul>
<li>Navigation system can be decoupled along 3 levels of abstraction:
<ul>
<li>Strategic Level: Where should the goal points be (Not in this course)
<ul>
<li>Dijkstra, A*, D*, RRT…</li>
</ul></li>
<li>Operational Level: which direction to move (go-to-goal and avoid-obstacles)</li>
<li>Tactical Level: How to make the robot move in those direction (control design)</li>
</ul></li>
</ul>
<h2 id="transforming-the-unicycle">Transforming the Unicycle</h2>
<p>The unicycle model <span class="math display">\[
\begin{array}{l}
\dot{x}=v \cos \phi \\
\dot{y}=v \sin \phi \\
\dot{\phi}=\omega
\end{array}
\]</span> What if we ignored the orientation and picked a different point on the robot as the point we care about</p>
<p>And now the <span class="math inline">\(u_1,u_2\)</span> would directly related to <span class="math inline">\(v\)</span> and <span class="math inline">\(w\)</span></p>
<p>Before: Use a Planner and Tracker</p>
<p>After: Use a Planner and Transformer and DO NOT need a PID controller for lower control</p>
<hr />
<p>Can this method applied to other kind of robots? <strong>YES</strong></p>
<p>Car-Like robots, Segway robot, Fixed-Wing aircraft, Underwater glider</p>
<p>Common: all the robots involves POSE:</p>
<ul>
<li>Position</li>
<li>Heading</li>
</ul>
<p>Almost everything with pose is almost a unicycle</p>
<h2 id="further">Further</h2>
<p>Nonlinear system, Optimal Control minimize some specific cost</p>
<p>Machine Learning. good for optimal control</p>
<p>Perception and Mapping</p>
<p>High-Level AI</p>
<h2 id="conclusion">Conclusion</h2>
<p>Punchline</p>
<ol type="1">
<li>We need a <strong>model</strong>, it should be rich enough to be relevant yet simple enough to be useful</li>
<li><strong>Feedback</strong> control should be used to guarantee stability, tracking and robustness</li>
<li><strong>Architectures</strong>: plan for simple systems, execute on the real system</li>
</ol>
]]></content>
      <tags>
        <tag>control</tag>
        <tag>robotics</tag>
      </tags>
  </entry>
  <entry>
    <title>Particle Filter</title>
    <url>/2018/12/01/Robotics/Project/PF/</url>
    <content><![CDATA[<h1 id="粒子滤波算法">粒子滤波算法</h1>
<h2 id="粒子滤波算法过程解析">1 粒子滤波算法过程解析</h2>
<p>粒子滤波定位算法的思想也是贝叶斯规则：</p>
<p><span class="math display">\[
\frac{\text { Likelihood * Prior }}{\text { Marginal }}
\]</span> 以下的解析是结合Matlab代码所作的说明</p>
<a id="more"></a>
<ol type="1">
<li>初始化
<ol type="1">
<li>初始化一堆粒子，在MatLab中的代码显示NP=50，也就是总共有50个<strong>采样粒子</strong>。Estimated State [x y yaw]，可见每个状态有3个数据。px=repmat(xEst,1,NP);，</li>
<li>计算初始权重pw=zeros(1,NP)+<strong>1/NP</strong>; 可见初始权重是均匀的</li>
<li>初始化路标，landMarks=[10 0; 10 10; 0 15; -5 20]; 可见一共有<strong>4个路标</strong></li>
</ol></li>
<li>预测：根据motion model与物体的控制信息u预测下个时刻粒子群中粒子的位置
<ol type="1">
<li>doControl()函数，输入参数time，得到<strong>控制指令u</strong></li>
<li>doMotion()函数，输入初始状态x和控制指令u，得到<strong>下一时刻</strong>的x状态</li>
<li>doObservation()函数，输入参数<strong>xGnd（没有噪声</strong>的里程计位置估计）, <strong>xOdom（有噪声</strong>的里程计位置估计）, u（控制指令）, landMarks, MAX_RANGE，输出参数是z,xGnd,xOdom,u</li>
</ol></li>
<li>更新：根据物体的<strong>观测值</strong>z与<strong>地图值</strong>zl计算出每个粒子的权重ww。更新粒子权重的依据是粒子的观测值与地图标志物<strong>相似度的高低</strong>，越高的话该粒子的权重越大
<ol type="1">
<li>对每个粒子循环操作</li>
<li>doMotion()函数，对每个采样粒子输入初始状态x和控制指令u，得到<strong>下一时刻</strong>的x状态，并加入干扰</li>
<li>计算权重，用各个路标距离的<strong>高斯概率相乘</strong>得到总概率</li>
</ol></li>
<li>重采样：根据粒子的权重w重新采样粒子</li>
</ol>
<h2 id="重要代码tasks">2 重要代码（Tasks）</h2>
<h3 id="观测模型">2.1 观测模型</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% do Observation model </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[z, xGnd, xOdom, u]</span> = <span class="title">doObservation</span><span class="params">(xGnd, xOdom, u, landMarks, MAX_RANGE)</span></span></span><br><span class="line">    <span class="keyword">global</span> Qsigma;</span><br><span class="line">    <span class="keyword">global</span> Rsigma;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% Gnd Truth and Odometry</span></span><br><span class="line">    xGnd=doMotion(xGnd, u);<span class="comment">% Ground Truth 理想状态</span></span><br><span class="line">    u=u+<span class="built_in">sqrt</span>(Qsigma)*<span class="built_in">randn</span>(<span class="number">2</span>,<span class="number">1</span>); <span class="comment">% add noise randomly</span></span><br><span class="line">    xOdom=doMotion(xOdom, u); <span class="comment">% odometry only</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">%Simulate Observation</span></span><br><span class="line">    z=[];</span><br><span class="line">    <span class="keyword">for</span> iz=<span class="number">1</span>:<span class="built_in">length</span>(landMarks(:,<span class="number">1</span>))</span><br><span class="line">        dx = xGnd(<span class="number">1</span>)-landMarks(iz,<span class="number">1</span>);</span><br><span class="line">        dy = xGnd(<span class="number">2</span>)-landMarks(iz,<span class="number">2</span>);</span><br><span class="line">        d=<span class="built_in">sqrt</span>(dx^<span class="number">2</span>+dy^<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> d&lt;MAX_RANGE </span><br><span class="line">            z=[z;[d+<span class="built_in">sqrt</span>(Rsigma)*<span class="built_in">randn</span>(<span class="number">1</span>,<span class="number">1</span>) landMarks(iz,:)]];   <span class="comment">% add observation noise randomly</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="运动模型">2.2 运动模型</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% do Motion Model</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[ x ]</span> = <span class="title">doMotion</span><span class="params">( x, u)</span></span></span><br><span class="line">    <span class="keyword">global</span> dt;</span><br><span class="line">    Delta = [ [dt*<span class="built_in">cos</span>(x(<span class="number">3</span>)),<span class="number">0</span>];</span><br><span class="line">              [dt*<span class="built_in">sin</span>(x(<span class="number">3</span>)),<span class="number">0</span>];</span><br><span class="line">              [<span class="number">0</span>,dt]];</span><br><span class="line"></span><br><span class="line">    x = x+Delta*u;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="高斯函数">2.3 高斯函数</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% Gauss function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span> = <span class="title">Gaussian</span><span class="params">(x,u,sigma)</span></span></span><br><span class="line">    g=<span class="built_in">exp</span>(-((u-x)^<span class="number">2</span>)/(sigma^<span class="number">2</span>)/<span class="number">2.0</span>)/<span class="built_in">sqrt</span>(<span class="number">2.0</span>*<span class="built_in">pi</span>*(sigma^<span class="number">2</span>));</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="粒子归一化">2.4 粒子归一化</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% Normalization </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pw</span>=<span class="title">Normalization</span><span class="params">(pw,NP)</span></span></span><br><span class="line">    pw=pw/sum(pw);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="重采样">2.5 重采样</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[px,pw]</span>=<span class="title">ResamplingStep</span><span class="params">(px,pw,NTh,NP)</span></span></span><br><span class="line">    ww=pw(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> iw=<span class="number">2</span>:NP</span><br><span class="line">        ww=[ww,ww(<span class="keyword">end</span>)+pw(iw)];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    pw1=[]</span><br><span class="line">    pp=[];</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:NP</span><br><span class="line">        r=<span class="built_in">rand</span>();</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:NP</span><br><span class="line">            <span class="keyword">if</span> ww(<span class="built_in">j</span>)&gt;r</span><br><span class="line">                pp=[pp,px(:,<span class="built_in">j</span>)]; </span><br><span class="line">                pw1=[pw1,pw(:,<span class="built_in">j</span>)]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    px=pp;</span><br><span class="line">    pw=pw1;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="参数对比实验">3 参数对比实验</h2>
<h3 id="np数效果实验">3.1 NP数效果实验</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">NP</th>
<th style="text-align: center;">效果</th>
<th style="text-align: center;">运行时间</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;"><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/pf-np3.png" /></td>
<td style="text-align: center;">0.220</td>
</tr>
<tr class="even">
<td style="text-align: center;">5</td>
<td style="text-align: center;">!<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/pf-np5.png" /></td>
<td style="text-align: center;">0.286</td>
</tr>
<tr class="odd">
<td style="text-align: center;">10</td>
<td style="text-align: center;"><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/pf-np10.png" /></td>
<td style="text-align: center;">0.387</td>
</tr>
<tr class="even">
<td style="text-align: center;">25</td>
<td style="text-align: center;"><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/pf-np25.png" /></td>
<td style="text-align: center;">0.640</td>
</tr>
<tr class="odd">
<td style="text-align: center;">50</td>
<td style="text-align: center;"><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/pf-np50.png" /></td>
<td style="text-align: center;">1.131</td>
</tr>
<tr class="even">
<td style="text-align: center;">100</td>
<td style="text-align: center;"><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/pf-np100.png" /></td>
<td style="text-align: center;">2.159</td>
</tr>
</tbody>
</table>
<h3 id="np数对时间的影响">3.2 NP数对时间的影响</h3>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/pf-np-diff.png" /></p>
<p>可见运行时间与NP数成正比关系</p>
<h3 id="np数对误差的影响">3.3 NP数对误差的影响</h3>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/pf-error-diff.png" /></p>
<p>可见误差趋向于0.5，这主要时由高斯噪声造成的</p>
<h2 id="结论与展望">4 结论与展望</h2>
<p>粒子滤波算法是基于概率的定位算法，主要有以下优点：</p>
<ul>
<li>理解简单，一句话就是越相似，存活概率越大</li>
<li>计算量不大（计算量与粒子数线性相关）</li>
</ul>
<p>但也存在以下问题：</p>
<ul>
<li>严重依赖于对初始状态的估计，选择不当可能发散</li>
<li>需要有固定的路标</li>
</ul>
<h2 id="参考文献">参考文献</h2>
<blockquote>
<p>https://en.wikipedia.org/wiki/Particle_filter</p>
<p>["Probabilistic Robotics"][Sebastian Thrun]</p>
</blockquote>
]]></content>
      <categories>
        <category>Robotics</category>
        <category>Project</category>
      </categories>
      <tags>
        <tag>robotics</tag>
        <tag>localization</tag>
      </tags>
  </entry>
  <entry>
    <title>Flight Controller</title>
    <url>/2019/04/13/Robotics/Project/flight-controller/</url>
    <content><![CDATA[<h2 id="introduction">1 Introduction</h2>
<p>This project was brought to make a flight controller from scratch.</p>
<p>I want to learn from the process so the flight controller will be more general. However the model of the flight and selection of controller platform(STM32/Arduino/Linux ) will make the general task more difficult.</p>
<a id="more"></a>
<p>Before the program, I have no experience in flight controller programming. So I would learn from other project shared on Github.com.</p>
<h2 id="learning-from-others">2 Learning from Others</h2>
<h3 id="hackflight">2.1 HackFlight</h3>
<p>As a education oriented project, <em><a href="https://github.com/simondlevy/Hackflight">Hackflight</a> is simple, platform-independent, header-only C++ firmware for multirotor flight controllers and simulators</em></p>
<h4 id="unit">2.1.1 Unit</h4>
<p>First of all, HackFlight defined some standard units to write simpler code.</p>
<ul>
<li>Distance $ m/s $</li>
<li>Time $ s $</li>
<li>Euler angle $ radians $</li>
<li>Stick demand interval $ [-1,1 ] $</li>
<li>Motor demands $ [0,1] $</li>
<li>Quaternions interval $ [-1,1] $</li>
</ul>
<h4 id="programming-structure">2.1.2 Programming Structure</h4>
<p>This project is a practice of C++ for it’s speed and object-oriented features</p>
<p>HackFlight build several separate class to provide basic function of a controller.</p>
<ul>
<li>Board class, specifies 4 abstract method a flight must implement
<ul>
<li>Sending commands to the motors</li>
<li>Getting current quaternion from the IMU</li>
<li>Getting gyrometer rates from the IMU</li>
<li>Getting the current time</li>
</ul></li>
<li>Receiver class perform basic function associate with R/C control</li>
<li>Mixer class that can be subclassed by specific mixer like QuadX / Bicopter</li>
<li>PID_Controller class specific the PID value appropriate for your model</li>
</ul>
<h4 id="design-principle">2.1.3 Design Principle</h4>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/20190419122228.png" alt="hackflight-dataflow" /><figcaption aria-hidden="true">hackflight-dataflow</figcaption>
</figure>
<p>There are 2 basic data type:</p>
<ul>
<li>State: State is updated by sensors which read IMU sensors and calculate <strong>quaternion</strong></li>
<li>Demands</li>
</ul>
<p>There are 2 basic fly mode: All a kind of PID controller</p>
<ul>
<li>Self-Level Mode: Auto mode, hold the angle or keep the level when there is no input. The input is regarded as the <em>distance</em> you want to move</li>
<li>Rate Mode: Manual/Acro mode. The input is taken as the <em>speed</em> you want to move</li>
</ul>
]]></content>
      <categories>
        <category>Robotics</category>
        <category>Project</category>
      </categories>
      <tags>
        <tag>robotics</tag>
        <tag>flight-controller</tag>
      </tags>
  </entry>
  <entry>
    <title>Robotics-BioCopter</title>
    <url>/2019/03/11/Robotics/Project/robotics-bicopoter/</url>
    <content><![CDATA[<h2 id="introduction-prepare">1 Introduction (Prepare)</h2>
<h3 id="goal">1.1 Goal</h3>
<p>Build a bicopter(a kind of frame) like this</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/biocopter.png" alt="biocopter" /><figcaption aria-hidden="true">biocopter</figcaption>
</figure>
<a id="more"></a>
<h3 id="pros-cons">1.2 Pros &amp; Cons</h3>
<ul>
<li>Cheap : only 2 servos and 2 motors</li>
<li>Unstable</li>
<li>Hard to tune</li>
</ul>
<h3 id="hardware">1.3 Hardware</h3>
<ul>
<li>Servo <span class="math inline">\(\times\)</span> 2</li>
<li>Motor <span class="math inline">\(\times\)</span> 2</li>
<li>Flight Controller Board <span class="math inline">\(\times​\)</span> 1 : SP Racing F4 Pro</li>
<li>Transmitter <span class="math inline">\(\times\)</span> 1 : FS-i6
<ul>
<li>Receiver (Rx) <span class="math inline">\(\times\)</span> 1 : FS-iA6</li>
</ul></li>
</ul>
<h3 id="software">1.4 Software</h3>
<ul>
<li>CleanFlight / BeteFlight / iNav (based on similar code)</li>
</ul>
<h2 id="assemble">2 Assemble</h2>
<ul>
<li>电调校准，首先要将油门信号调到最大，然后上电，然后油门信号调到最低。校准完毕</li>
</ul>
<h2 id="software-setup">3 Software Setup</h2>
<h3 id="betaflight">3.1 Betaflight</h3>
<ul>
<li><p>Setup servo pin map <a href="https://github.com/betaflight/betaflight/wiki/Servos-&amp;-SERVO_TILT-for-3.1">MORE</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">resource <span class="comment">#list all avaliable pin map</span></span><br><span class="line">resource motor 3 none <span class="comment">#we just need 2 motor, so we can free motor 3 &amp; 4, remember the pin of motor 3 &amp; 4 </span></span><br><span class="line">resource servo 1 a06 <span class="comment">#setup the pin for servo 1 &amp; 2</span></span><br><span class="line">save <span class="comment">#all the changes will lose if you don&#x27;t save</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="bib">Bib</h2>
<ul>
<li>Receivers Type: PWM(avoid), PPM(main), Serial(advanced) <a href="https://github.com/betaflight/betaflight/blob/master/docs/Rx.md">MORE</a></li>
</ul>
]]></content>
      <categories>
        <category>Robotics</category>
        <category>Project</category>
      </categories>
      <tags>
        <tag>hide</tag>
        <tag>robotics</tag>
      </tags>
  </entry>
  <entry>
    <title>SSL-Collison Avoidance</title>
    <url>/2019/03/04/Robotics/Project/robotics-ssl/</url>
    <content><![CDATA[<h2 id="introduction">1 Introduction</h2>
<h3 id="ssl">1.1 SSL</h3>
<blockquote>
<p>The <strong>Small Size league</strong> or F180 league as it is otherwise known, is one of the oldest RoboCup Soccer leagues. It focuses on the problem of intelligent multi-robot/agent cooperation and control in a highly dynamic environment with a hybrid centralized/distributed system.</p>
<a id="more"></a>
</blockquote>
<h3 id="rule">1.2 Rule</h3>
<ul>
<li>the robot must fit within an <strong>180 mm</strong> diameter circle</li>
<li>and must be no higher than <strong>15 cm</strong></li>
<li>play soccer with an orange golf ball</li>
<li>field is <strong>12 m</strong> long by <strong>9 m</strong> wide</li>
</ul>
<h3 id="how-it-works">1.3 How it Works?</h3>
<ul>
<li><p>All objects on the field are <strong>tracked</strong> by a vision system called <strong>SLL-Vision</strong></p></li>
<li><p>Robots are controlled by <strong>off-field computers</strong></p>
<ul>
<li>Communications is wireless</li>
<li>Uses dedicated commercial radio units</li>
</ul></li>
</ul>
<h2 id="software-enviroments">2 Software Enviroments</h2>
<h3 id="grsim">2.1 GrSim</h3>
<blockquote>
<p>The simulator grSim was contributed to the SSL community by Parsian. It performs a physical simulation of SSL robots and publishes SSL-Vision network packages.</p>
</blockquote>
<ul>
<li>Receiving and Sending data using Protobuf library</li>
<li><a href="https://github.com/RoboCup-SSL/grSim/blob/master/INSTALL.md">Install</a></li>
</ul>
<h3 id="protobuf">2.2 Protobuf</h3>
<blockquote>
<p>Protocol Buffers (a.k.a., protobuf) are Google's language-neutral, platform-neutral, <strong>extensible mechanism for serializing structured data</strong>.</p>
</blockquote>
<ul>
<li><p>Protobuf supports many language <a href="https://github.com/protocolbuffers/protobuf#protobuf-runtime-installation">(C++, Java, Python…)</a></p></li>
<li><p>Python based protobuf programming <strong>maybe</strong> the easiest</p>
<ol type="1">
<li><p>Download binary released <a href="https://github.com/protocolbuffers/protobuf/releases">protoc.exe</a> or <a href="https://github.com/protocolbuffers/protobuf/blob/master/src/README.md">build from source</a></p></li>
<li><p>Define your protocol format</p></li>
<li><p>Compile your protocol buffers</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">protoc -I=<span class="variable">$SRC_DIR</span> --python_out=<span class="variable">$DST_DIR</span> <span class="variable">$SRC_DIR</span>/xxx.proto</span><br><span class="line"><span class="comment">## If you compile &quot;xxx.proto&quot;, the result should be &quot;xxx_pb2.py&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>Install library for your python enviroment</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install protobuf</span><br><span class="line"><span class="comment">## Notice: the version of protobuf library must match the version of the compile tool(protoc.exe)</span></span><br></pre></td></tr></table></figure></li>
<li><p>Start programming</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xxx_pb2</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>For furthur study, read <a href="https://developers.google.com/protocol-buffers/docs/pythontutorial">Google's doc</a></p></li>
</ol></li>
</ul>
<h3 id="packet">2.3 Packet</h3>
<p>protobuf will be used only in simulation. In real enviroments, we need to send a byte-format package to control the robots' speed and action.</p>
<p>And the package is defined below (image lost)</p>
<p>In our project, we just need to specify the speed of robot.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">commands = <span class="string">b&#x27;\xff\x00\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x07\x00\x00\x00&#x27;</span></span><br><span class="line"><span class="comment">## we need to change the value of commands[4],commands[5],commands[6],commands[7]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="project-task-1-collison-avoidance">3 Project Task 1： Collison Avoidance</h2>
<h3 id="background">3.1 Background</h3>
<p>We need to control the robot <strong>move</strong> from one point to another point in the field. There will be moveable and static obstacle (are robots as well), so we need to <strong>avoid the collison</strong></p>
<p>What we know:</p>
<ul>
<li>the position of every robot</li>
<li>the velocity of every robot (but is <strong>NOT</strong> accurate)</li>
</ul>
<p>What we can control:</p>
<ul>
<li>the velocity of every robot</li>
</ul>
<p>The <strong>key problem</strong>:</p>
<ul>
<li>Path planning: in general, we want to find a path <strong>short</strong> but will <strong>avoid</strong> the static obstacle as well.
<ul>
<li>Action and dynamic object will change the optimal path</li>
</ul></li>
<li>Dynamic obstacle: there will be other moveable robot in the field, so we need to <strong>change our path in real time</strong>
<ul>
<li>Action should be quick</li>
</ul></li>
<li>Path Tracking: How to control the robot <strong>follow the path</strong> we generated accurately</li>
</ul>
<h3 id="approach-rrt">3.2 Approach: RRT</h3>
]]></content>
      <categories>
        <category>Robotics</category>
        <category>Project</category>
      </categories>
      <tags>
        <tag>hide</tag>
        <tag>robotics</tag>
        <tag>homework</tag>
      </tags>
  </entry>
  <entry>
    <title>Robotics-Arm Kinematics</title>
    <url>/2019/01/06/Robotics/Robotics,Vison%20and%20Control%20Notes/Robotics-Arm%20Kinematics/</url>
    <content><![CDATA[<h2 id="introduction">1 Introduction</h2>
<blockquote>
<p>Kinematics is the <strong>branch of mechanics</strong> that studies the motion of a body, without considering it's mass or forces.</p>
</blockquote>
<p>A robot arm, a serial-link manipulator, a chain of rigid links and joints. Each joint has one degree of freedom. 2 types:</p>
<ul>
<li>Translational—–prismatic joint</li>
<li>Rotational—–revolute joint</li>
</ul>
<a id="more"></a>
<h2 id="forward-kinematics">2 Forward Kinematics</h2>
<h2 id="inverse-kinematics">3 Inverse Kinematics</h2>
<h2 id="trajectory">4 Trajectory</h2>
<p><strong>Requirement</strong>: move the end-effector smoothly from pose A to pose B.</p>
<p><strong>Approach</strong>:</p>
<ul>
<li>joint-space</li>
<li>Cartesian motion</li>
</ul>
<h3 id="joint-space">4.1 joint-space</h3>
<h3 id="cartesian-motion">4.2 Cartesian motion</h3>
<h2 id="advanced-application">5 Advanced Application</h2>
]]></content>
      <categories>
        <category>Robotics</category>
        <category>Robotics,Vison and Control Notes</category>
      </categories>
      <tags>
        <tag>robotics</tag>
        <tag>Jacobian</tag>
        <tag>Velocity</tag>
      </tags>
  </entry>
  <entry>
    <title>Robotics-Images and Image Processing</title>
    <url>/2019/01/07/Robotics/Robotics,Vison%20and%20Control%20Notes/Robotics-Image/</url>
    <content><![CDATA[<h2 id="introduction">1 Introduction</h2>
<blockquote>
<p>A process that transforms one or more input images into an output image.</p>
</blockquote>
<p>Main purpose: <strong>enhance</strong> an image for <em>human</em> viewing</p>
<a id="more"></a>
<p>A image is just a matrix.</p>
<ul>
<li>Value: <code>uint8</code> ,[0-255] (from darkest to brightest)
<ul>
<li>if use complex algorithms, may use floating-point numbers</li>
</ul></li>
<li>Descibe: width <span class="math inline">\(\times\)</span> height</li>
</ul>
<h2 id="useful-algorithms">2 Useful Algorithms</h2>
<blockquote>
<p>Histogram: the number of times each pixel value occurs.</p>
</blockquote>
<p>If a picture was under-exposed, the histogram would shift to the left.</p>
<p>Find peak in <em>nearby</em> x value:</p>
<h2 id="monadic-diadic-operations">3 Monadic &amp; Diadic Operations</h2>
<h3 id="monadic">3.1 Monadic</h3>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/monadic.png" alt="monadic" /><figcaption aria-hidden="true">monadic</figcaption>
</figure>
<p>A function about single pixel. That is <span class="math inline">\(O [ u , v ] = f ( I [ u , v ] ) , \quad \forall ( u , v ) \in I\)</span></p>
<p>Example:</p>
<ul>
<li>convert a color image to a greyscale image</li>
<li>stretch</li>
<li>normalize hist</li>
</ul>
<h3 id="diadic">3.2 Diadic</h3>
<p>Example:</p>
<ol type="1">
<li><p>chroma-keying: superimpose the image of a person over some background.</p>
<ol type="1">
<li>gamma encoded image to linear tristimulus value.</li>
<li>mask = g&lt;0.45 (just a example)</li>
<li>mask.*image</li>
</ol>
<p>This an important problem in robot vision. But variation is a significant problem in real-world.</p></li>
<li><p>Provess image sequence and <em>estimate</em> the <strong>background</strong></p>
<ol type="1">
<li><p><span class="math inline">\(\hat { \boldsymbol { B } } \langle k + 1 \rangle \leftarrow \hat { \boldsymbol { B } } \langle k \rangle + c ( \boldsymbol { I } \langle k \rangle - \hat { \boldsymbol { B } } \langle k \rangle )\)</span> <span class="math display">\[
c ( x ) = \left\{ \begin{aligned} \sigma , &amp; x &gt; \sigma \\ x , &amp; - \sigma \leq x \leq \sigma \\ - \sigma , &amp; x &lt; - \sigma \end{aligned} \right.
\]</span></p></li>
<li><figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/diadic.png" alt="diadic" /><figcaption aria-hidden="true">diadic</figcaption>
</figure></li>
</ol></li>
</ol>
<h2 id="spatial-operations">4 Spatial Operations</h2>
<p>Each pixel in the output image is a function of all pixels in a region <span class="math display">\[
O [ u , v ] = f ( I [ u + i , v + j ] ) , \quad \forall ( i , j ) \in \mathcal { W } , \quad \forall ( u , v ) \in I
\]</span> Spatial operations are <strong>powerful</strong> for the <strong>variety</strong> of possible function <span class="math inline">\(f ( \cdot )\)</span></p>
<h3 id="linear">4.1 Linear</h3>
<ul>
<li><p>Smoothing</p>
<ul>
<li><p>ones(K)</p></li>
<li><p>gaussian <span class="math inline">\(\mathrm { G } ( u , v ) = \frac { 1 } { 2 \pi \sigma ^ { 2 } } e ^ { - \frac { u ^ { 2 } + v ^ { 2 } } { 2 \sigma ^ { 2 } } }\)</span></p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/gaussian.png" alt="gaussian" /><figcaption aria-hidden="true">gaussian</figcaption>
</figure></li>
</ul></li>
<li><p>Edge Detection</p>
<ul>
<li><span class="math inline">\(p ^ { \prime } [ v ] = p [ v ] - p [ v - 1 ]\)</span></li>
<li><span class="math inline">\(p ^ { \prime } [ v ] = \frac { 1 } { 2 } ( p [ v + 1 ] - p [ v - 1 ] )\)</span></li>
<li>Sobel</li>
<li>Canny</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>Robotics</category>
        <category>Robotics,Vison and Control Notes</category>
      </categories>
      <tags>
        <tag>robotics</tag>
        <tag>vision</tag>
      </tags>
  </entry>
  <entry>
    <title>Robotics-Manipulator Velocity</title>
    <url>/2019/01/05/Robotics/Robotics,Vison%20and%20Control%20Notes/Robotics-Manipulator%20Velocity/</url>
    <content><![CDATA[<h2 id="introduction">1 Introduction</h2>
<p>End-effector moves with a spatial velocity, and it's a consequnece of all individual joint velocities.</p>
<p>Here, we introduce the relationship between <strong>joint</strong> <strong>velocities</strong> and <strong>end-effector</strong>'s <strong>velocity</strong></p>
<p><strong>In kinematics, we care about the pose, now we care about velocity</strong></p>
<a id="more"></a>
<h2 id="manipulator-jacobian">2 Manipulator Jacobian</h2>
<h3 id="overview">2.1 Overview</h3>
<p>Jocabian: <span class="math display">\[
J = \frac { \partial f } { \partial x } = \left( \begin{array} { c c c } { \frac { \partial y _ { 1 } } { \partial x _ { 1 } } } &amp; { \cdots } &amp; { \frac { \partial y _ { 1 } } { \partial x _ { n } } } \\ { \vdots } &amp; { \ddots } &amp; { \vdots } \\ { \frac { \partial y _ { m } } { \partial x _ { 1 } } } &amp; { \cdots } &amp; { \frac { \partial y _ { m } } { \partial x _ { n } } } \end{array} \right)
\]</span> In manipulator, <span class="math inline">\(f\)</span> (end-effector pose) and <span class="math inline">\(x\)</span> (joint variables) are all vector: <span class="math display">\[
\frac { \mathrm { d } p } { \mathrm { d } q } = \mathrm { J } ( q ) \to \mathrm { d } \boldsymbol { p } = \boldsymbol { J } ( \boldsymbol { q } ) \mathrm { d } \boldsymbol { q }
\]</span> and divide through by <span class="math inline">\(dt\)</span> <span class="math display">\[
\begin{aligned} \frac { \mathrm { d } p } { \mathrm { d } t } &amp; = J ( q ) \frac { \mathrm { d } q } { \mathrm { d } t } \to \dot { p }  = J ( q ) \dot { q } \end{aligned}
\]</span> Jocabian is a $J R^{6N} $ (<span class="math inline">\(6\)</span> for enviroment, <span class="math inline">\(N\)</span> for n joints) matrix</p>
<h3 id="under--and-over-actuated-manipulators">2.2 Under- and Over-Actuated Manipulators</h3>
<ul>
<li>Under-Actuated: accepting that some Cartesian degrees of freedom are <strong>not controllable</strong></li>
<li>Over-Actuated: multiple solution, so find a <strong>least-squares</strong> solution</li>
</ul>
<h2 id="jocabian-numerical-properties">3 Jocabian: Numerical Properties</h2>
<p><span class="math display">\[
\dot{p}=J ( q ) \dot { q }\\
\dot { q } = J ( q ) ^ { - 1 } \nu
\]</span></p>
<h3 id="singularities">3.1 Singularities</h3>
<p>Singularities occur when the robot is at maximum reach or when one or more axes become aligned resulting in the loss of degrees of freedom. aka <span class="math inline">\(det(J(q))=0\)</span></p>
<p>If robot is close to a singularity, some end-effector velocities require very high joint rates</p>
<h3 id="manipulability">3.2 Manipulability</h3>
<h2 id="inverse-jocabian-generate-paths">4 Inverse Jocabian: generate paths</h2>
<h3 id="resolved-rate-motion-control">4.1 Resolved-Rate Motion Control</h3>
<blockquote>
<p>Resolved-rate motion control is a simple and elegant algorithm to generate straight line motion</p>
</blockquote>
<p>It make use of <span class="math inline">\(\dot { \boldsymbol { q } } = J ( \boldsymbol { q } ) ^ { - 1 } \boldsymbol { \nu }\)</span> to map <em>resovle</em> desired Cartesian velocity to joint velocity</p>
<p>Control scheme:</p>
<ul>
<li>first <span class="math inline">\(\dot { \boldsymbol { q } } ^ { * } \langle k \rangle = J ( \boldsymbol { q } \langle k \rangle ) ^ { - 1 } \nu ^ { * }\)</span> computes the required <strong>joint velocity</strong> as a function of the manipulator and disired end-effector velocity <span class="math inline">\(\nu ^ { * }\)</span></li>
<li>then <span class="math inline">\(q ^ { * } \langle k + 1 \rangle \leftarrow \boldsymbol { q } \langle k \rangle + \delta _ { t } \dot { \boldsymbol { q } } ^ { * } \langle k \rangle\)</span> perform intergration to give desired joint angle for next step.</li>
</ul>
<h2 id="jocabian-transform-force-from-end-to-joint">5 Jocabian: Transform Force from End to Joint</h2>
<h2 id="jocabian-inverse-kinematics">6 Jocabian: Inverse Kinematics</h2>
<p>If a robot <strong>don't meet</strong> some specification:</p>
<ul>
<li>have 6 joints</li>
<li>have a spherical wrist</li>
</ul>
<p>Then, it's hard to give a explicit solution. So we introduce general numerical solution <strong>based on:</strong></p>
<ul>
<li>forward kinematics</li>
<li>the Jacobian transpose</li>
</ul>
<p>Idea: compute by error</p>
<p>Notation: actual pose <span class="math inline">\(\xi _ { E } = \mathcal { X } ( q )\)</span> , desired pose <span class="math inline">\(\xi _ { E } ^ { * }\)</span> , error between them:<span class="math inline">\(\xi _ { \Delta }\)</span> (also can be described by a spatial displacement)</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/jocabian-inv-kine.png" alt="jocabian-inv-kine" /> <span class="math display">\[
^ { E } \Delta = \Delta \left( \xi _ { E } , \xi _ { E } ^ { * } \right) = ( t , \hat { v } \theta ) \in \mathbb { R } ^ { 6 }
\]</span> How to compute?</p>
<ol type="1">
<li><p>imagine a <em>spring</em> between two pose, which is pulling and twisting (wrench) the end-effector <strong>proportional</strong> to the spatial displacement <span class="math inline">\(\to ^ { E } \boldsymbol { W } = \gamma ^ { E } \boldsymbol { \Delta }\)</span></p></li>
<li><p>the wrench is resolved to generalized joint forces <span class="math inline">\(\to\boldsymbol { Q } = _{}^{E}\textrm{} \boldsymbol { J } ( \boldsymbol { q } ) ^ { T } \boldsymbol { W }\)</span></p></li>
<li><p>assume joint velocity just be <strong>proportional</strong> to the forces <span class="math inline">\(\to \dot { q } = Q / B (a \ coefficient)\)</span></p></li>
<li><p>wrap up: <span class="math inline">\(\dot { \boldsymbol { q } } = \frac { 1 } { B } \boldsymbol { J } ( \boldsymbol { q } ) ^ { T } \Delta \left( \mathcal { K } ( \boldsymbol { q } ) , \xi _ { E } ^ { * } \right)\)</span></p></li>
<li><p>we can solve it interatively by: <span class="math display">\[
\begin{aligned} \delta _ { q } \langle k \rangle = \alpha J ( \boldsymbol { q } \langle k \rangle ) ^ { T } \Delta \left( \mathcal { K } ( \boldsymbol { q } \langle k \rangle ) , \xi _ { E } ^ { * } \right )\\
\boldsymbol { q } \langle k + 1 \rangle  \leftarrow \boldsymbol { q } \langle k \rangle + \delta _ { q } \langle k \rangle \end{aligned}
\]</span></p></li>
<li><p>until the norm of the update <span class="math inline">\(\left\| \delta _ { q } \langle k \rangle \right\|\)</span> is sufficiently</p></li>
</ol>
<p>pratically above algorithm is slow and sensitive to <span class="math inline">\(\alpha\)</span> ,so we imporve it by:</p>
<ul>
<li><p>formulate this as a <strong>least-squares</strong> problem: <span class="math inline">\(\to E = \boldsymbol { \Delta } ^ { T } M \Delta\)</span></p>
<ul>
<li>we want to <strong>minimize</strong> the scalar cost</li>
<li>where <span class="math inline">\(M = \operatorname { diag } ( m ) \in \mathbb { R } ^ { 6 \times 6 }\)</span> and <span class="math inline">\(m\)</span> is the <strong>mask</strong> vector</li>
</ul></li>
<li><p>update becomes :<span class="math inline">\(\delta _ { q } \langle k \rangle = \left( J ( \boldsymbol { q } \langle k \rangle ) ^ { T } \boldsymbol { M } \boldsymbol { J } ( \boldsymbol { q } \langle k \rangle ) \right) ^ { - 1 } \boldsymbol { J } ( \boldsymbol { q } \langle k ) ) ^ { T } \boldsymbol { M } \Delta \left( \mathcal { X } ( \boldsymbol { q } \langle k \rangle ) , \xi _ { E } ^ { * } \right)\)</span></p></li>
<li><p>impove above performance near singularities by introducing a damping constant λ: <span class="math display">\[
\delta _ { q } \langle k \rangle = \left( J ( \boldsymbol { q } \langle k \rangle ) ^ { T } \boldsymbol { M } \boldsymbol { J } ( \boldsymbol { q } \langle k \rangle ) +\lambda I_{N\times N}\right) ^ { - 1 } \boldsymbol { J } ( \boldsymbol { q } \langle k ) ) ^ { T } \boldsymbol { M } \Delta \left( \mathcal { X } ( \boldsymbol { q } \langle k \rangle ) , \xi _ { E } ^ { * } \right)
\]</span></p></li>
</ul>
<p>An effective way to choose <span class="math inline">\(\lambda\)</span> is to test whether or not an iteration reduces the error</p>
]]></content>
      <categories>
        <category>Robotics</category>
        <category>Robotics,Vison and Control Notes</category>
      </categories>
      <tags>
        <tag>robotics</tag>
        <tag>Jacobian</tag>
        <tag>Velocity</tag>
      </tags>
  </entry>
  <entry>
    <title>Robotics-Path Planning</title>
    <url>/2019/03/12/Robotics/Robotics,Vison%20and%20Control%20Notes/Robotics-pathplaning/</url>
    <content><![CDATA[<h2 id="compare-obstacle-avoidance-algorithm">Compare Obstacle Avoidance Algorithm</h2>
<h3 id="bug-algorithms">1 Bug algorithms</h3>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/bug-algorithm.png" alt="bug-algorithm" /><figcaption aria-hidden="true">bug-algorithm</figcaption>
</figure>
<ul>
<li>Simple</li>
<li>Non optimal</li>
<li>May be trapped in maze structures</li>
</ul>
<a id="more"></a>
<h3 id="potential-field">2 Potential Field</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Attractive Potential</th>
<th style="text-align: center;">Repulsive Potential</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/attractive-potential.png" alt="attractive-potential" /></td>
<td style="text-align: center;"><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/repulsive-potential.png" alt="repulsive-potential" /></td>
</tr>
</tbody>
</table>
<p>Combine Attractive Potential and Repulsive Potential</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/combine-att-rep.png" alt="combine" /><figcaption aria-hidden="true">combine</figcaption>
</figure>
<ul>
<li><p>Good for static and completely known environment</p></li>
<li><p>Bad: may lead to a <strong>local minimum</strong> point</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/local-minimum.png" alt="local-minimum" /><figcaption aria-hidden="true">local-minimum</figcaption>
</figure></li>
</ul>
<h3 id="d">3 D*</h3>
<blockquote>
<p>D* is an extension of the A* algorithm for finding <strong>minimum cost paths</strong> through a graph</p>
</blockquote>
<ul>
<li>Support incremental <strong>replanning</strong></li>
</ul>
<h3 id="roadmap-methods">4 Roadmap methods</h3>
]]></content>
      <categories>
        <category>Robotics</category>
        <category>Robotics,Vison and Control Notes</category>
      </categories>
      <tags>
        <tag>robotics</tag>
        <tag>path</tag>
        <tag>planning</tag>
      </tags>
  </entry>
  <entry>
    <title>Robotics-Vision Foundation</title>
    <url>/2019/01/07/Robotics/Robotics,Vison%20and%20Control%20Notes/Rootics-Vison%20foundation/</url>
    <content><![CDATA[<h2 id="introduction">1 Introduction</h2>
<blockquote>
<p>The light that reaches the eye,or the camera, is a function of the illumination impinging on the scene and the material property known as reflectivity.</p>
</blockquote>
<a id="more"></a>
<h2 id="light">2 Light</h2>
<p>Each color is a single frequency or wavelength of electro-magnetic radiation.We perceive the wavelengths between 400 and 700 nm as different colors.</p>
<p>In general, the light we observe can be represented as a function <span class="math inline">\(E(\lambda)\)</span> ,<span class="math inline">\(\lambda\)</span> is the wavelength. This is a function about <strong>power </strong>related to</p>
<ul>
<li>source temperature <span class="math inline">\(T\)</span> (e.g. 4700K)</li>
<li>Planck’s constant <span class="math inline">\(h\)</span> , Boltzmann’s constant <span class="math inline">\(k\)</span>, speed of light <span class="math inline">\(c\)</span></li>
<li>……</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/black-body-power.png" alt="black-body-power" /><figcaption aria-hidden="true">black-body-power</figcaption>
</figure>
<h3 id="absorption">2.1 Absorption</h3>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/earth-spectrum.png" alt="earth-spectrum" /><figcaption aria-hidden="true">earth-spectrum</figcaption>
</figure>
<p>Spectrum will be changed (be absorbed)</p>
<h3 id="luminance">2.2 Luminance</h3>
<p>The light refl ected from a surface, its luminance, has a spectrum given by <span class="math display">\[
L ( \lambda ) = E ( \lambda ) R ( \lambda )  (W  m ^ { - 2 })
\]</span> where <span class="math inline">\(R\)</span> is the reflectance</p>
<h3 id="color">2.3 Color</h3>
<p>How to measure color? Take <span class="math inline">\(red\)</span> for example: <span class="math display">\[
\rho = \int _ { \lambda } L ( \lambda ) M _ { \mathrm { r } } ( \lambda ) \mathrm { d } \lambda
\]</span> where <span class="math inline">\(M _ { r } ( \lambda )\)</span> are the spectral response of the red.</p>
<h2 id="image-formation">3 Image Formation</h2>
<p>Here we introduce how images are <strong>formed and captured</strong>.</p>
<blockquote>
<p>a glass or plastic lens forms an image on the surface of a semiconductor chip with an array of light-sensitive devices to convert light to a digital image.</p>
</blockquote>
<p>However, in an eye or in a camera, the depth information is lost. This is known as <em>projection</em>.</p>
<h3 id="model">3.1 Model</h3>
<h4 id="perspective-camera">3.1.1 Perspective Camera</h4>
<p>convex lens <span class="math inline">\(\frac { 1 } { z _ { 0 } } + \frac { 1 } { z _ { i } } = \frac { 1 } { f }\)</span></p>
<p>In a camera, the image plane (the surface of the sensor chip) is <strong>fixed</strong>. How to solve the problem? <span class="math inline">\(\to\)</span> high-quality camera lens is a compound lens comprising <strong>multiple</strong> glass or plastic lenses.</p>
<ul>
<li><p>central perspective imaging model</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/perspective-camera.png" alt="perspective-camera" /><figcaption aria-hidden="true">perspective-camera</figcaption>
</figure>
<p>Map: <span class="math inline">\(\mathrm { P } = ( X , Y , Z ) \to x = f \frac { X } { Z } , y = f \frac { Y } { Z }\)</span></p>
<ul>
<li><span class="math inline">\(\mathcal { P } : \mathbb { R } ^ { 3 } \mapsto \mathbb { R } ^ { 2 }\)</span></li>
<li>straight line <span class="math inline">\(\to\)</span> straight line</li>
<li>map is not unique</li>
<li>map is not conformal</li>
</ul></li>
</ul>
<h4 id="mathematical-model">3.1.2 Mathematical Model</h4>
<p><strong>world</strong> coordinate <strong>homogeneous</strong> form <span class="math display">\[
\tilde { \boldsymbol { P } } = ( X , Y , Z , 1 ) ^ { T }
\]</span></p>
<p><strong>image-plane</strong> point <strong>coordinate</strong> <span class="math display">\[
\tilde { \boldsymbol { p } } = \left( \begin{array} { l l l l } { f } &amp; { 0 } &amp; { 0 } &amp; { 0 } \\ { 0 } &amp; { f } &amp; { 0 } &amp; { 0 } \\ { 0 } &amp; { 0 } &amp; { 1 } &amp; { 0 } \end{array} \right)  \tilde { \boldsymbol { P } }
\]</span></p>
<h4 id="discrete-model">3.1.3 Discrete Model</h4>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/camera-discrete-model.png" alt="camera-discrete-model" /><figcaption aria-hidden="true">camera-discrete-model</figcaption>
</figure>
<hr />
<p>Notation:</p>
<ul>
<li>Principle point: <span class="math inline">\((u_0,v_0)\)</span></li>
<li>width and height of each pixel <span class="math inline">\(\rho_w , \rho_h\)</span></li>
</ul>
<p>So, the pixel coordinate <span class="math display">\[
u = \frac { x } { \rho _ { w } } + u _ { 0 } , v = \frac { y } { \rho _ { h } } + v _ { 0 }
\]</span> finally, we get <span class="math display">\[
\tilde { \boldsymbol { p } } = \left( \begin{array} { c c c } { f / \rho _ { w } } &amp; { 0 } &amp; { u _ { 0 } } \\ { 0 } &amp; { f / \rho _ { h } } &amp; { v _ { 0 } } \\ { 0 } &amp; { 0 } &amp; { 1 } \end{array} \right) \left( \begin{array} { c c c c } { 1 } &amp; { 0 } &amp; { 0 } &amp; { 0 } \\ { 0 } &amp; { 1 } &amp; { 0 } &amp; { 0 } \\ { 0 } &amp; { 0 } &amp; { 1 } &amp; { 0 } \end{array} \right) \left( ^ { 0 } T _ { C } \right) ^ { - 1 } \tilde { P }
\]</span></p>
<hr />
<p>In conclusion, we can describe a projection as a function <span class="math display">\[
\boldsymbol { p } = \mathcal { P } \left( \boldsymbol { P } , \boldsymbol { K } , \boldsymbol { \xi } _ { \mathrm { C } } \right)
\]</span></p>
<ul>
<li><span class="math inline">\(P​\)</span> is point in the <strong>real world</strong> frame</li>
<li><span class="math inline">\(K\)</span> is the camera <strong>parameter</strong> : <span class="math inline">\(f,\rho_w, \rho_h, u_0, v_0\)</span></li>
<li><span class="math inline">\(\xi_c\)</span> the <strong>pose</strong> of the camera</li>
</ul>
<h3 id="camera-calibration">3.2 Camera Calibration</h3>
<p>In practice, some parameter in <span class="math inline">\(K\)</span> is unclear.(<span class="math inline">\(f, u_0, v_0\)</span>)</p>
<p>So we need to calibrate the camera</p>
]]></content>
      <categories>
        <category>Robotics</category>
        <category>Robotics,Vison and Control Notes</category>
      </categories>
      <tags>
        <tag>robotics</tag>
        <tag>vision</tag>
      </tags>
  </entry>
  <entry>
    <title>基于KNN的花品种分类</title>
    <url>/2019/04/26/CS/Data/Project/KNN/</url>
    <content><![CDATA[<h2 id="目标">1. 目标</h2>
<ul>
<li>问题描述</li>
<li>数据分析</li>
<li>中间结果分析</li>
<li>结果讨论</li>
<li>缺点认识</li>
</ul>
<a id="more"></a>
<h2 id="问题描述及数据定义">2. 问题描述及数据定义</h2>
<h3 id="问题描述">2.1 问题描述</h3>
<p>利用KNN算法对iris数据集进行分类，并用训练集的训练结果对测试集进行预测，观察预测效果。</p>
<p>因为数据集是有标签的，所以这是一个典型的有监督分类问题</p>
<h3 id="数据定义">2.2 数据定义</h3>
<p>数据来源：<a href="http://archive.ics.uci.edu/ml/datasets/Iris">UCI</a></p>
<p>iris数据集中共有3个种类的花，每种花各有50个<em>样本</em>：</p>
<ul>
<li>其中一个样本与另外两个样本线性可分</li>
<li>其中另一个样本与另外两个样本线性不可分</li>
</ul>
<p>每个<em>样本</em>各有4个<em>属性（x）</em>：</p>
<ol type="1">
<li>sepal length in cm</li>
<li>sepal width in cm</li>
<li>petal length in cm</li>
<li>petal width in cm</li>
</ol>
<p>预测结果一共有3种：</p>
<ul>
<li>setosa</li>
<li>versicolor</li>
<li>virginica</li>
</ul>
<h3 id="计划流程">2.3 计划流程</h3>
<ol type="1">
<li>读取、处理数据</li>
<li>实现KNN
<ol type="1">
<li>计算相似性（使用欧几里得距离）</li>
<li>计算最相近的K个邻居</li>
</ol></li>
<li>生成预测</li>
<li>观察结果（预测准确性）</li>
</ol>
<h2 id="代码实现">3 代码实现</h2>
<p>具体代码见<code>notebooks/knn-iris.ipynb</code> 或者<code>notebooks/knn-iris.html</code></p>
<h3 id="读取处理数据">3.1 读取、处理数据</h3>
<p>首先通过读取iris.data可以得到这样的信息</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/knn-info.png" /></p>
<p>通过统计可以发现petal-length的标准差最大，猜测可能含有最多信息</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/knn-info2.png" /></p>
<p>为了验证算法的效果，我们将数据分成训练集和测试集，比例为4:1</p>
<p>之后为了排除数据大小的干扰，再将数据标准化</p>
<figure>
<img src="KNN/pairplot.svg" alt="pairplot" /><figcaption aria-hidden="true">pairplot</figcaption>
</figure>
<p>通过可视化可以看出在二维平面上也能大概分出3种花</p>
<h3 id="实现knn">3.2 实现KNN</h3>
<p>KNN算法有不同的形式</p>
<ul>
<li>无监督学习：
<ul>
<li>聚类</li>
</ul></li>
<li>有监督学习：
<ul>
<li>标签离散：分类</li>
<li>标签连续：回归</li>
</ul></li>
</ul>
<p>我们在这里要实现的有监督学习下的标签离散情况，也就是分类。</p>
<p>K近邻分类器是一个基于样本的分类器，也就是说它并不会训练一个General的模型来预测分类，而是简单地根据样本距离来进行投票确定分类</p>
<p>创建一个类KNN_Classification 有以下函数</p>
<ul>
<li><p>计算欧式距离</p>
<p><span class="math inline">\(d\left(x, x^{\prime}\right)=\sqrt{\left(x_{1}-x_{1}^{\prime}\right)^{2}+\left(x_{2}-x_{2}^{\prime}\right)^{2}+\ldots+\left(x_{n}-x_{n}^{\prime}\right)^{2}}\)</span></p>
<ul>
<li>要注意向量长度，不要将标签值也计算进距离中</li>
<li>可以调用numpy来提高运算速度</li>
</ul></li>
<li><p>计算获取最近邻</p></li>
<li><p>输出预测结果</p></li>
</ul>
<h3 id="预测结果">3.3 预测结果</h3>
<p>因为在KNN算法中只有一个K值是可以改变的变量，因此我改变K值来观察预测效果，但是发现预测结果会不断变化。</p>
<p>测试条件：K取1-90</p>
<p>大部分情况下预测精度随K值的变化规律是这样的</p>
<figure>
<img src="KNN/accuracy2.svg" alt="accuracy2" /><figcaption aria-hidden="true">accuracy2</figcaption>
</figure>
<p>也就是说随着K值的增大，预测精度是不断降低的。</p>
<p>但是在测试过程中也出现过以下情况的变化规律</p>
<figure>
<img src="KNN/accuracy1-1556177038111.svg" alt="accuracy1-1556177038111" /><figcaption aria-hidden="true">accuracy1-1556177038111</figcaption>
</figure>
<p>这种情况比较反常，也即是K稍大时预测结果较好，K偏小或偏大时效果都不佳。</p>
<h2 id="分析">4 分析</h2>
<h3 id="异常测试结果分析">4.1 异常测试结果分析</h3>
<p>在3.3 中出现的问题，经过分析我认为是以下原因造成的</p>
<ul>
<li>样本较少。因为一共只有150个样本，还有分成训练集和测试集，所以效果不好。</li>
<li>随即采样。对于有着很多样本的数据来说，这样采样方式可能没有什么问题，但是因为这个数据集样本太少，导致采样结果不再能反应数据的真是分布。</li>
<li>KNN算法的原理。自己实现过KNN之后我发现，其实对于KNN算法来说，分成测试集和训练集的意义和一般的机器学习算法不同：KNN的模型就是数据本身（训练集），所以数据的多少和分布是否有效（能代表真实分布）会很大程度上影响预测效果。所以因为前两点原因加上KNN自身的算法，导致了预测结果的不稳定</li>
</ul>
<h3 id="k值选取">4.2 K值选取</h3>
<p>在KNN算法中，K是唯一一个超参数(hyper parameter)，因此要想达到好的预测效果，选择一个合适的K是非常重要的。</p>
<p>从图像上看，K控制的是分割平面的边界。比如说当K较小时，这个区间就会较小，直观上理解就是K仅仅观察临近的几个样本，而没有全局意识，哪怕它的旁边有一个异常点，它也把异常当成同类</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/knn-map1.png" /></p>
<p>另一方面，当K较大时，预测值更加关注的是全局的情况，所以这时它就会忽略一些异常值，这使得边界更加平滑</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/knn-map2.png" /></p>
<h3 id="knn算法的优缺点">4.3 KNN算法的优缺点</h3>
<p>优点：</p>
<ul>
<li>容易理解，容易实现(核心代码不足百行)</li>
<li>计算速度快，最耗时的操作也不过是计算距离</li>
<li>适用于多分类问题</li>
</ul>
<p>缺点：</p>
<ul>
<li>对数据集要求较高，在合适的数据集（样本量大，分布均匀，样本平衡）上能狗取得不错的效果，但是一旦数据集不佳，效果会大打折扣</li>
<li>在维数较高的场合效果不佳，因为计算的是欧氏距离，所以距离是平方和，因此无法体现出各个维度的区别</li>
</ul>
<h3 id="改进方法">4.4 改进方法</h3>
<ul>
<li>使用不同的相似性度量，而不是简单的欧氏距离</li>
<li>在高维数据上使用时可以采用<strong>数据降维</strong>，使用PCA等算法降低维数，改善效果</li>
<li>使用K-D tree等方法存储数据，减小计算量</li>
</ul>
<h2 id="总结">5 总结</h2>
<p>在这个项目中，我学习了KNN算法，包括它的工作原理和如何编写KNN算法、如何使用KNN算法。我使用KNN算法对iris数据集进行测试，得到的效果还不错。</p>
<h2 id="参考资料">参考资料</h2>
<p><a href="https://seaborn.pydata.org/generated/seaborn.pairplot.html">Pairplot</a></p>
<p><a href="https://kevinzakka.github.io/2016/07/13/k-nearest-neighbor/">A Complete Guide to K-Nearest-Neighbors with Applications in Python and R</a></p>
<p><a href="https://machinelearningmastery.com/tutorial-to-implement-k-nearest-neighbors-in-python-from-scratch/">Tutorial To Implement k-Nearest Neighbors in Python From Scratch</a></p>
]]></content>
      <categories>
        <category>CS</category>
        <category>Data</category>
        <category>Project</category>
      </categories>
      <tags>
        <tag>data</tag>
        <tag>iris</tag>
      </tags>
  </entry>
  <entry>
    <title>SECOM数据分析与预测</title>
    <url>/2019/04/26/CS/Data/Project/SECOM%E6%95%B0%E6%8D%AE%E9%9B%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="目标">1. 目标</h2>
<ul>
<li>选择一个侧重工业领域的数据集</li>
<li>分析数据</li>
<li>分析问题，分析结果</li>
</ul>
<a id="more"></a>
<h2 id="问题分析">2. 问题分析</h2>
<h3 id="问题">2.1 问题</h3>
<blockquote>
<p>A complex modern semi-conductor manufacturing process is normally under consistent surveillance via the monitoring of signals/variables collected from sensors and or process measurement points. However, not all of these signals are equally valuable in a specific monitoring system. The measured signals contain a combination of useful information, irrelevant information as well as noise. It is often the case that useful information is buried in the latter two. Engineers typically have a much larger number of signals than are actually required. If we consider each type of signal as a feature, then feature selection may be applied to identify the most relevant signals. The Process Engineers may then use these signals to determine key factors contributing to yield excursions downstream in the process. This will enable an increase in process throughput, decreased time to learning and reduce the per unit production costs.</p>
</blockquote>
<p>简单来说，在半导体加工行业中，我们希望通过流水线上各个传感器的信号来预先判断最后产品合格与否。</p>
<p>在过去，一般会采用多元统计的分析方法来进行预测，但是现在的生产实际过程中有相当多的传感器收集了过多的信息，因此并不能使用原来的方法。另外，这些信息的重要程度不同，有一些还参杂了许多噪声，因此我们要进行特征提取，选择合适的模型进行分析</p>
<p>数据来源： <a href="http://archive.ics.uci.edu/ml/datasets/secom">SECOM Data Set</a></p>
<h3 id="数据格式定义">2.2 数据格式定义</h3>
<p>数据来自半导体加工工厂，数据来自半导体生产线上的传感器，整体数据已经经过了脱敏的处理，因此无法得知每个属性数据来自哪种，哪一个传感器。数据按时间点记录，1567条数据代表着1567个时间点上生产线上传感器所记录的数据。</p>
<ul>
<li><a href="http://archive.ics.uci.edu/ml/machine-learning-databases/secom/secom.data">secom.data</a>
<ul>
<li><span class="math inline">\(1567\times961\)</span> 说明有1567个数据样本，961个特征，都是数值</li>
</ul></li>
<li><a href="http://archive.ics.uci.edu/ml/machine-learning-databases/secom/secom_labels.data">secom_labels.data</a>
<ul>
<li><span class="math inline">\(1567\times2\)</span> 有1567个数据标签，其中一个是结果，另一个是获取数据的时间</li>
<li>$-1 $代表通过（PASS），$1 $代表失败（FAIL）</li>
<li>缺失的数据由<code>NaN</code>表示</li>
</ul></li>
</ul>
<blockquote>
<p>实际中的NaN是由什么产生的呢</p>
<p>As with any real life data situations this data contains null values varying in intensity depending on the individuals features. This needs to be taken into consideration when investigating the data either through pre-processing or within the technique applied.</p>
</blockquote>
<h3 id="从数据到问题">2.3 从数据到问题</h3>
<p>在过去，一般会采用多元统计的分析方法来进行预测，但是现在的生产实际过程中有相当多的传感器收集了过多的信息，因此并不能使用原来的方法。另外，这些信息的重要程度不同，有一些还参杂了许多噪声，因此我们要进行特征提取，选择合适的模型进行分析。同时由于数据提供的结果数据是用1和-1代表的质量数据，所以我们要解决的生产质量预测问题可以转化为一个二分类的问题。即利用生产线上的传感器数据来将产品进行质量合格和质量不合格的二分类。</p>
<h3 id="计划流程">2.3 计划流程</h3>
<ol type="1">
<li>加载数据</li>
<li>空缺数据填补</li>
<li>特征选择</li>
<li>尝试不同分类模型</li>
<li>验证模型效果</li>
</ol>
<h2 id="数据预处理">3. 数据预处理</h2>
<h3 id="可视化分析">3.1 可视化分析</h3>
<h3 id="数据清洗">3.2 数据清洗</h3>
<p>首先，961个特征中不能每个特征都对最后的结果都有可观的影响。因此遵从一般的原则，我们可以将其中一些特征删除。这些特征应该满足以下条件：</p>
<ul>
<li>是一个常数</li>
<li>不是常数，但是方差很小，可以认为是一个常数</li>
</ul>
<p>我们首先观察<em>Secom_labels.data</em>中的数据，将两个数据表中质量标签缺失的数据从我们的整体数据中清洗掉。</p>
<p>但是在这一步中我们并没有进行离群点的筛查。一是质量表征的数据过于复杂，二是作为工业生产线上的数据，突变的离群点很大可能是质量不合格的原因。因此在这里我们并没有进行离群点的筛查。</p>
<h3 id="数据填补">3.3 数据填补</h3>
<p>我们研究数据可以发现，许多特征并不是完整的，也就是说他们没有1567个样本，缺少的数据以<code>NaN</code>体现。</p>
<p>我们选择的方法可以是：</p>
<ul>
<li>平均值填补</li>
<li>IN-painting KNN (from paper BDCC)</li>
</ul>
<p>注意到我们的数据几乎都离0值较远，因此我们选用0来对我们的数据进行填补。</p>
<h3 id="特征选择">3.4 特征选择</h3>
<p>在填补了缺失的数据之后，我们还要进行特征选择，来精简掉一些不重要的信息，提高我们算法的运算速度</p>
<p>其中包含的方法有数据降维PCA、通过模型计算各个参数的重要性并排序</p>
<h3 id="数据平衡化">3.5 数据平衡化</h3>
<p>在观察数据的过程中，我们发现SECOM这个数据集是imbalance的：也就是说数据集中的正样本数和负样本数是不匹配的。通过的(-1)的样本数要远远多于不通过的样本数(1)。<em>这在实际生产中是非常常见的，因为一个工厂的良品率肯定是要比较高的，不然生产的产品一大半不合格的话，成本太高了。</em></p>
<p>然而不均衡的样本会导致不均衡的数据分布，这样就会使得各个分类算法的效果大大降低。(from learning from imbalanced data)</p>
<p>那么要使数据平衡有两种方法，一种是对少的那部分样本进行过采样使得样本数量和多的样本接近，或者对多的那种样本进行欠采样。</p>
<p>我们选择的是过采样方法，SMOTE （Synthetic Minority Oversampling Technique），这种方法会根据插值来产生新的数据</p>
<h2 id="使用不同模型进行预测">4. 使用不同模型进行预测</h2>
<h3 id="可用的算法">4.1 可用的算法</h3>
<p>回顾我们的问题，我们要根据所拥有的传感器信息判断这个产品是好还是坏，搜易最后的结果只有两种可能， 这是一个典型的二分类问题。又因为这是一个有标签的有监督学习，所以我们可以将整个问题归纳为<strong>有监督的二分类学习</strong></p>
<p>二分类学习算法有很多，常见的有以下几种</p>
<ul>
<li><p>朴素贝叶斯</p>
<ul>
<li>优点：需要估计的参数少</li>
<li>缺点：需要知道先验概率，假设属性之间相互独立</li>
</ul></li>
<li><p>决策树</p>
<ul>
<li><p>优点：易于理解，适合高维数据</p></li>
<li><p>缺点：容易过拟合，忽略了属性之间的相关性</p></li>
</ul></li>
<li><p>逻辑回归</p>
<ul>
<li>优点：速度快</li>
<li>缺点：需要较多的特征工程</li>
</ul></li>
<li><p>KNN</p>
<ul>
<li>优点：不需要训练，数据即模型</li>
<li>缺点：在高维数据下表现不好</li>
</ul></li>
<li><p>集成学习方法</p>
<ul>
<li>Adaboost</li>
<li>XGBoost</li>
<li>随机森林</li>
</ul></li>
</ul>
<h3 id="需要注意的问题">4.2 需要注意的问题</h3>
<p>因为我们的数据是典型的不平衡数据，也就是说正样本的数量要远远多于负样本，这就导致我们不能用一般的分析方法来观察结果的好坏，比如说<em>准确率</em>，判断正确的占所有判断的比值，这样会造成的问题就是即使我们的算法把所有的样本都判断为正，最后得到的<em>准确率</em>依然很高，因为正样本太多了，所以我们在分析时要使用其他不同的评判标准。</p>
<h3 id="预测结果">4.3 预测结果</h3>
<p>为了让实验结果更加完整，我们对比了不同方法下的预测效果：</p>
<ul>
<li>数据处理上
<ul>
<li>原数据</li>
<li>欠采样</li>
<li>过采样</li>
</ul></li>
<li>模型方法
<ul>
<li>随机森林</li>
<li>决策树</li>
<li>SVM</li>
<li>朴素贝叶斯</li>
<li>AdaBoost</li>
<li>XGBoost</li>
<li>KNN</li>
</ul></li>
</ul>
<h4 id="原数据">4.3.1 原数据</h4>
<p>从准确度角度看，不进行采样直接使用各种算法的预测结果如下</p>
<figure>
<img src="SECOM数据集分析/normal-accu.svg" alt="normal-accu" /><figcaption aria-hidden="true">normal-accu</figcaption>
</figure>
<p>看上去效果还可以，但是仔细思考的话，就会发现这样的准确率是没有什么意义的，因为正样本太多，所以哪怕算法将所有的样本都判断为正样本，最后也能得到非常高的预测准确度。</p>
<p>这一点我们可以从观察算法的混淆矩阵看出来，下面展示的两张混淆矩阵代表了大部分算法的混淆矩阵情况</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/fusematrix5.png" /></p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/fusematrix6.png" /></p>
<p>可以看到正如我们之前所猜测的那样，模型的预测效果很差，将大部分样本呢都标定为正样本</p>
<h4 id="欠采样">4.3.2 欠采样</h4>
<p>既然样本不平衡时会出现这样严重的问题，我们就需要对样本进行平滑化处理，首先我们测试的方法是使用欠采样。</p>
<p>欠采样的方法比较简单直观，我们只需要将数据量多的样本（在这里是正样本）随机的删除掉一些，最后让正负样本量相同即可</p>
<p>这样的情况下，再使用7种算法进行预测得到的结果如下</p>
<figure>
<img src="SECOM数据集分析/under-accu.svg" alt="under-accu" /><figcaption aria-hidden="true">under-accu</figcaption>
</figure>
<p>可以看到，在欠采样的情况下，各个算法的预测准确度大大降低，几乎都只有一半左右，考虑到这是一个二分类问题，接近50%的预测准确度就相当于乱猜了。</p>
<p>混淆矩阵如下</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/fusematrix1.png" /></p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/fusematrix2.png" /></p>
<p>从混淆矩阵可以看出，各个情况下的数据都差不多，也证实了我们的猜想，算法在欠采样的情况下没有了基本的判断能力，判断结果和随机类似。</p>
<p>为什么会出现这样的情况呢？其实从欠采样的工作原理就能大概猜到了，那就是数据量太小，由于本身负样本的数量就很少，只有一百多，现在将正样本的数量缩减到和负样本相同的情况下，总共的样本数也就只有两百多，在这么少的训练样本情况下，训练效果不佳也是可以预见的。</p>
<h4 id="过采样">4.3.3 过采样</h4>
<p>既然不采样和欠采样都没有很好的效果，我们只能使用另外的方法来解决数据不平衡问题，那就是——过采样</p>
<p>我们采样的方法是SMOTE （Synthetic Minority Oversampling Technique），这种方法会根据插值来产生新的数据。</p>
<p>预测效果如下：</p>
<figure>
<img src="SECOM数据集分析/over-accu.svg" alt="over-accu" /><figcaption aria-hidden="true">over-accu</figcaption>
</figure>
<p>可以看到，在过采样的情况下，一部分算法的效果大大提升，而另一些算法仍然保持着较低的预测结果</p>
<p>从混淆矩阵来看，取得较好预测结果的算法混淆矩阵大概如下</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/fusematrix4.png" /></p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/fusematrix3.png" /></p>
<p>可以看到效果还是非常不错的，能够将大部分的正负样本预测出来。</p>
<h3 id="结果分析">4.4 结果分析</h3>
<p>我们最终的目的是要寻找一个优秀的算法能够较好地预测结果，所以我们需要算法</p>
<ul>
<li>能够在所有的故障中尽量将故障选择出来，这是最重要的部分，因为将一部分正常产品检测为故障问题不是特别大，无非是提高一点成本。但是一旦故障检测率太低，就会造成产品有重大缺陷，对于下游厂商来说是不可接受的。</li>
<li>能够将所有的正常产品尽量多地通过，虽然在上一点说过故障检测率是最重要，但是正常产品的检测效果一样重要，因为如果这样检测率太低就有可能导致将许多正常产品都标定为故障，这样的话会大幅提高生产成本和二次检查的成本，对于厂商来说也是不可接受的。</li>
</ul>
<p>首先观察一下各个算法在不同的采样情况下能否正确地将故障从故障中找到</p>
<figure>
<img src="SECOM数据集分析/fail-rate-all.svg" alt="fail-rate-all" /><figcaption aria-hidden="true">fail-rate-all</figcaption>
</figure>
<p>可以看到，这时过采样的效果很好</p>
<p>再来观察一下各个算法在不同的采样情况下能否正确地将正常样本识别出来</p>
<figure>
<img src="SECOM数据集分析/pass-rate-all-1556260861775.svg" alt="pass-rate-all-1556260861775" /><figcaption aria-hidden="true">pass-rate-all-1556260861775</figcaption>
</figure>
<p>可以看到，在这种情况下过采样和不采样的效果是较好的。</p>
<p>那么如何将两种判断标准结合起来呢？我们最终使用的判断标准是将上述两个标准的数值取调和平均，得到的结果如下：</p>
<figure>
<img src="SECOM数据集分析/final-rate-all.svg" alt="final-rate-all" /><figcaption aria-hidden="true">final-rate-all</figcaption>
</figure>
<p>可以看到，在过采样情况下，随机森林和XGBoost这两种算法的效果是最好的，其他的几种情况和算法都不尽如人意。</p>
<p>我们分析这两种取得优秀效果的原因有以下几点：</p>
<ol type="1">
<li>我们的数据是流水线上的传感器信息，而且数量较多，有上千个，因此这样的数据之间一定是有很强的相关性的。比如说一个工艺之后到另一个工艺之间产品的性质并不会发生天翻地覆的变化，一定是慢慢变化的。</li>
<li>表现优秀的几种算法都是基于决策树的，而决策树的优势就在于能够在数据有很强相关性的情况下进行分类，因此这样的算法和我们的数据集比较吻合，达到了较好的效果</li>
<li>其他的一些算法比如朴素贝叶斯则假设的是各个特征之间相互独立，明显和我们的数据不吻合，因此效果很差。</li>
</ol>
<h2 id="总结与展望">5.总结与展望</h2>
<p>我们利用了一般的数据分析流程对半导体加工数据进行了数据填补、数据清理、特征工程、样本平衡化和建模预测，最终结果表明在过采样情况下，随机森林和XGBoost这两种算法的效果是最好的。</p>
<p>后续工作：</p>
<ul>
<li><p>更加细致的特征工程</p>
<ul>
<li>数据进行补全的不同方式效果对比</li>
<li>PCA保留的主成分多寡效果对比</li>
<li>对于异常值的删选</li>
</ul></li>
<li><p>模型的调参</p>
<ul>
<li><p>Grid Search 穷举搜索</p>
<p>目前我们所使用的模型都使用默认的参数，所以最终效果大概率不是最好的，如果使用Grid Search对参数进行遍历搜索，会取得更加优秀的预测效果</p></li>
</ul></li>
<li><p>尝试不同的学习方法</p>
<ul>
<li><p>迁移学习</p>
<p>因为这个数据的样本量较少，因此训练效果不佳，但是迁移学习可以将在其他大数据上所学习到的模型套用在本模型上，获得更好的效果</p></li>
<li><p>故障诊断</p>
<p>现在我们的思路是把问题作为一个二分类问题，但其实也可以作为一个故障诊断问题，也就是从数据出发，不直接对特征建模，而是观察数据的异常。这样的思路也是非常合理的，因为有故障的样本一般会在某些特征上与一般样本不同，所以可以通过检测某些特征的离群点来判断样本是否有故障</p></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>Data</category>
        <category>Project</category>
      </categories>
      <tags>
        <tag>data</tag>
        <tag>secom</tag>
        <tag>imbalance</tag>
      </tags>
  </entry>
  <entry>
    <title>8051 Basics</title>
    <url>/2019/01/10/Robotics/Hardware/Embedded%20System/8051/8051-Basics/</url>
    <content><![CDATA[<h2 id="embedded-system-introduction">1 Embedded System Introduction</h2>
<blockquote>
<p>An embedded system is a microcontroller or microprocessor based system which is designed to perform a specific task</p>
</blockquote>
<a id="more"></a>
<h3 id="architecture">1.1 Architecture</h3>
<ul>
<li><strong>Von Neumann</strong>: data and code lie in the <strong>same</strong> memory blocks</li>
<li><strong>Harvard</strong>: data and code lie in <strong>different</strong> memory blocks</li>
</ul>
<h3 id="instruction-set">1.2 Instruction Set</h3>
<ul>
<li>CISC: Easy to use, higher clock cycle</li>
<li>RISC: Hard to use, lower clock cycle</li>
</ul>
<h2 id="introduction">2 8051 Introduction</h2>
<p>In 1981, Intel introduced an <strong>8-bit</strong> microcontroller called the <strong>8051</strong>.</p>
<ul>
<li>128 bytes of <strong>RAM</strong></li>
<li>4K byte of on-chip <strong>ROM</strong>
<ul>
<li>Max 64K at all because <code>PC</code> is 16-bit : (0000 to FFFF address)</li>
</ul></li>
<li>two <strong>timers</strong></li>
<li>4 <strong>ports</strong> (8-bit wide)</li>
<li>3 internal and 2 external <strong>Interrupts</strong></li>
<li>Family Member
<ul>
<li>8052: 8K ROM, 256 byte RAM, 3 Timer</li>
<li>8031: 0K ROM, 128 byte RAM, 2 Timer</li>
</ul></li>
</ul>
<h3 id="registers">2.1 Registers</h3>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Registers</th>
<th style="text-align: center;">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>A</code>(8-bit)</td>
<td style="text-align: center;">accumulator: quick. Used for all operations</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>R</code>(8-bit)</td>
<td style="text-align: center;">R0,R1 to R7: store values temporarily</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>DPTR</code>(16-bit)</td>
<td style="text-align: center;">Data Pointer: access external memory</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>PC</code>(16-bit)</td>
<td style="text-align: center;">Program Counter: where the next instruction to execute can be found in the memory./starts at 0000h</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>SP</code>(8-bit)</td>
<td style="text-align: center;">Stack Pointer: the location of the stack's tail. Initially, the SP register contains value <strong>07</strong> to point to location 08 as the first location being used for the stack by the 8051</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>PSW</code>(8-bit)</td>
<td style="text-align: center;">program status word:<strong>4 conditional flags</strong> + <strong>RS0、RS1</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>CY</code>(1-bit)</td>
<td style="text-align: center;">there is a carry out from the D7 bit</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>AC</code>(1-bit)</td>
<td style="text-align: center;">there is a carry from D3 and D4</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>P</code>(1-bit)</td>
<td style="text-align: center;">odd number of 1's in <code>A</code> register, then P = 1</td>
</tr>
</tbody>
</table>
<h3 id="addressing-modes">2.2 Addressing Modes</h3>
<ul>
<li><p>Immediate</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/address-Immediate.png" alt="address-Immediate" /><figcaption aria-hidden="true">address-Immediate</figcaption>
</figure></li>
<li><p>Direct</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/address-direct.png" alt="address-direct" /><figcaption aria-hidden="true">address-direct</figcaption>
</figure></li>
<li><p>Register Direct</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/register-direct.png" alt="register-direct" /><figcaption aria-hidden="true">register-direct</figcaption>
</figure></li>
<li><p>Register Indirect</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/register-indirect.png" alt="register-indirect" /><figcaption aria-hidden="true">register-indirect</figcaption>
</figure></li>
<li><p>Indexed</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/index-address.png" alt="index-address" /><figcaption aria-hidden="true">index-address</figcaption>
</figure></li>
</ul>
<h3 id="hardware">2.3 Hardware</h3>
<p>Totally 40 pins</p>
<ul>
<li><span class="math inline">\(4\times8\)</span> ports</li>
<li><span class="math inline">\(8\)</span> : <code>Vcc</code> ,<code>GND</code>, <code>XTAL1</code>, <code>XTAL2</code>, <code>EA</code>, <code>ALE</code>, <code>PSEN</code></li>
<li>default: input. 0 written to a port <span class="math inline">\(\to\)</span> output; 1 written to a port <span class="math inline">\(\to\)</span> input</li>
</ul>
<h4 id="port-0">2.3.1 Port 0</h4>
<p>An open drain:</p>
<ul>
<li>we normally connect P0 to 10K-ohm <strong>pull-up resistors</strong> to use it as an <strong>input or outpu</strong>t port</li>
<li>be used as both address and data, designated as AD0-AD7</li>
</ul>
<h4 id="port-1">2.3.2 Port 1</h4>
<p>Can be used either as input or output</p>
<ul>
<li>It <strong>doesn't require</strong> pull-up resistors because they are <strong>already</strong> connected internally</li>
</ul>
<h4 id="port-2">2.3.3 Port 2</h4>
<p>Similar to Port 1</p>
<ul>
<li>It must be used <strong>along with P0</strong> to provide the 16-bit address for the external memory. Port 2 is used for upper 8-bit of the 16 bits address</li>
</ul>
<h4 id="port-3">2.3.4 Port 3</h4>
<p>Similar to Port 1</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">P3 Bit</th>
<th style="text-align: center;">Function</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">P3.0</td>
<td style="text-align: center;">RxD</td>
</tr>
<tr class="even">
<td style="text-align: center;">P3.1 &lt;</td>
<td style="text-align: center;">TxD</td>
</tr>
<tr class="odd">
<td style="text-align: center;">P3.2 &lt;</td>
<td style="text-align: center;">Complement of INT0</td>
</tr>
<tr class="even">
<td style="text-align: center;">P3.3 &lt;</td>
<td style="text-align: center;">INT1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">P3.4 &lt;</td>
<td style="text-align: center;">T0</td>
</tr>
<tr class="even">
<td style="text-align: center;">P3.5 &lt;</td>
<td style="text-align: center;">T1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">P3.6 &lt;</td>
<td style="text-align: center;">WR</td>
</tr>
<tr class="even">
<td style="text-align: center;">P3.7 &lt;</td>
<td style="text-align: center;">Complement of RD</td>
</tr>
</tbody>
</table>
<h4 id="other">2.3.5 Other</h4>
<ul>
<li><p><code>RST</code>: <strong>Power-On Reset</strong> To ensure a valid input of Reset, the high pulse must be <strong>high</strong> for a <strong>minimum of two machine cycles</strong></p></li>
<li><p><code>EA</code>: (<strong>External Access</strong>) Applying a <strong>low pulse</strong>, it gets activated</p></li>
<li><p><code>PSEN</code>: (<strong>Program store Enable</strong>) Applying a <strong>low pulse</strong>, it gets activated</p></li>
<li><p>Single-Bit Instructions</p>
<ul>
<li>SETB</li>
</ul></li>
</ul>
<h3 id="timers">2.4 Timers</h3>
<p>8051 has 2 timers, <code>Timer 0</code> and <code>Timer 1</code></p>
<ul>
<li>Both <code>Timer 0 and 1</code> are 16-bit wide</li>
<li>2 separate 8-bit registers <code>TH0\1</code> and <code>TL0\1</code></li>
</ul>
<h4 id="tmod">2.4.1 TMOD</h4>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/tmod.png" alt="tmod" /><figcaption aria-hidden="true">tmod</figcaption>
</figure>
<ul>
<li><p><code>Gate</code>: the timer only runs while INT(0,1) is high. Control the onof the timers</p>
<ul>
<li>Software: SETB TR0  CLR TR0</li>
<li>Hardware: <code>Gate</code>=1</li>
</ul></li>
<li><p><code>C/T</code> : Counter/Timer select bit.</p>
<ul>
<li>=0: Timers .Be incremented with every <strong>machine cycle</strong></li>
<li>=1: Counter</li>
</ul></li>
<li><p>Mode</p>
<p><code>TF0\1</code> will be set 1 if Timer has overflowed.</p>
<ul>
<li>0: <strong>13-bit</strong> timer mode (8 bits of TH1 and 5 bits of TL1)</li>
<li>1: <strong>16-bit</strong> timer mode</li>
<li>2: <strong>8-bit Auto Reload</strong> : Overflow form <code>TL1</code> set <code>TF1</code>(1) and reload <code>TL1</code> with <code>TH1</code></li>
</ul></li>
</ul>
<h3 id="interrupts">2.5 Interrupts</h3>
<p>For every interrupt, there must be an interrupt service routine (ISR), or <strong>interrupt handler</strong></p>
<h4 id="process">2.5.1 Process</h4>
<ol type="1">
<li><strong>Close</strong> currently executing instruction and <strong>save</strong> the PC in stack</li>
<li><strong>Jump</strong> to memory location of the interrupt vector table and <strong>execute</strong> ISR</li>
<li><strong>Get</strong> PC from stack, <strong>execute</strong> from that address</li>
</ol>
<h4 id="priority">2.5.2 Priority</h4>
<p>We can alter the priority by programming a register called <code>IP</code> (8-bit)(interrupt priority).</p>
<p>default:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Interrupt</th>
<th style="text-align: center;">Priority</th>
<th style="text-align: center;">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">PT1</td>
<td style="text-align: center;">IP.3</td>
<td style="text-align: center;">Defines the Timer 1 interrupt priority level.</td>
</tr>
<tr class="even">
<td style="text-align: center;">PX1</td>
<td style="text-align: center;">IP.2</td>
<td style="text-align: center;">Defines the External Interrupt 1 priority level.</td>
</tr>
<tr class="odd">
<td style="text-align: center;">PT0</td>
<td style="text-align: center;">IP.1</td>
<td style="text-align: center;">Defines the Timer 0 interrupt priority level.</td>
</tr>
<tr class="even">
<td style="text-align: center;">PX0</td>
<td style="text-align: center;">IP.0</td>
<td style="text-align: center;">Defines the External Interrupt 0 priority level.</td>
</tr>
</tbody>
</table>
<h4 id="enabling">2.5.3 Enabling</h4>
<p>We can enable interrupt by programming a register called <code>IE</code>(8-bit)(interrupt enable).</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">EA</th>
<th style="text-align: center;">-</th>
<th style="text-align: center;">ET2</th>
<th style="text-align: center;">ES</th>
<th style="text-align: center;">ET1</th>
<th style="text-align: center;">EX1</th>
<th style="text-align: center;">ET0</th>
<th style="text-align: center;">EX0</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Global</td>
<td style="text-align: center;">Undefined</td>
<td style="text-align: center;">Timer 2</td>
<td style="text-align: center;">Serial port</td>
<td style="text-align: center;">Timer 1</td>
<td style="text-align: center;">External 1</td>
<td style="text-align: center;">Timer 0</td>
<td style="text-align: center;">External 0</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Robotics</category>
        <category>Hardware</category>
        <category>Embedded System</category>
        <category>8051</category>
      </categories>
      <tags>
        <tag>8051</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32-ADC</title>
    <url>/2018/12/27/Robotics/Hardware/Embedded%20System/STM32/STM32-ADC/</url>
    <content><![CDATA[<h2 id="introduction">1 Introduction</h2>
<p>STM32 have one of the most advanced ADCs on microcontroller market.</p>
<p>This note provide users to understand some modes offered in STM32</p>
<a id="more"></a>
<h2 id="independent-mode">2 Independent Mode</h2>
<ul>
<li><p>Single Channel, <strong>single</strong> conversion</p>
<p>Example: Check if the battery voltage is succulent or not</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/single-conversion.png" alt="single-conversion" /><figcaption aria-hidden="true">single-conversion</figcaption>
</figure></li>
<li><p>Multichannel, single conversion</p>
<p>Example: Can be used when starting system depends on some <strong>parameters</strong></p></li>
<li><p>Single Channel, continuous conversion</p>
<p>Example: Run in <strong>background</strong>, so can be used as a monitor to check something all the time</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/continuous-conversion.png" alt="continuous-conversion" /><figcaption aria-hidden="true">continuous-conversion</figcaption>
</figure></li>
<li><p>Injected conversion</p>
<p>Intended for use when conversion is triggered by an <strong>external event</strong> or by software.</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/Injected-conversion.png" alt="Injected-conversion" /><figcaption aria-hidden="true">Injected-conversion</figcaption>
</figure></li>
</ul>
<h2 id="example-code">3 Example Code</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIOINIT_ADC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">  GPIO_InitStructure.GPIO_Pin=GPIO_Pin_0;<span class="comment">//ADC</span></span><br><span class="line"> GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AIN; <span class="comment">//模拟输入</span></span><br><span class="line">   GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">   GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RCCINIT_ADC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   SystemInit();</span><br><span class="line"> RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);</span><br><span class="line">   RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);</span><br><span class="line">   RCC_ADCCLKConfig(RCC_PCLK2_Div6);<span class="comment">//12M  最大14M 设置ADC时钟（ADCCLK）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADCINIT_ADC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  ADC_InitTypeDef ADC_InitStructure;</span><br><span class="line">    ADC_InitStructure.ADC_Mode = ADC_Mode_Independent; </span><br><span class="line">   ADC_InitStructure.ADC_ScanConvMode = DISABLE; </span><br><span class="line">    ADC_InitStructure.ADC_ContinuousConvMode = DISABLE; </span><br><span class="line">  ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None; </span><br><span class="line">  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right; </span><br><span class="line">   ADC_InitStructure.ADC_NbrOfChannel = <span class="number">1</span>; </span><br><span class="line">  ADC_Init(ADC1, &amp;ADC_InitStructure);</span><br><span class="line">   ADC_TempSensorVrefintCmd(ENABLE);</span><br><span class="line"> ADC_Cmd(ADC1,ENABLE);   </span><br><span class="line"></span><br><span class="line">    ADC_ResetCalibration(ADC1);<span class="comment">//重置指定的ADC的校准寄存器</span></span><br><span class="line">  <span class="keyword">while</span>(ADC_GetResetCalibrationStatus(ADC1));<span class="comment">//获取ADC重置校准寄存器的状态</span></span><br><span class="line">    </span><br><span class="line">  ADC_StartCalibration(ADC1);<span class="comment">//开始指定ADC的校准状态</span></span><br><span class="line">    <span class="keyword">while</span>(ADC_GetCalibrationStatus(ADC1));<span class="comment">//获取指定ADC的校准程序</span></span><br><span class="line">    ADC_RegularChannelConfig(ADC1,ADC_Channel_8,<span class="number">1</span>,ADC_SampleTime_239Cycles5);<span class="comment">//设置指定ADC的规则组通道，设置它们的转化顺序和采样时间</span></span><br><span class="line">  ADC_SoftwareStartConvCmd(ADC1, ENABLE);<span class="comment">//使能或者失能指定的ADC的软件转换启动功能</span></span><br><span class="line">   <span class="keyword">while</span>(ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) == RESET);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Robotics</category>
        <category>Hardware</category>
        <category>Embedded System</category>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>ADC</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32 Basics</title>
    <url>/2019/01/12/Robotics/Hardware/Embedded%20System/STM32/STM32-Basics/</url>
    <content><![CDATA[<h2 id="命名规则">1 命名规则</h2>
<p><strong>STM32F103C8T6</strong></p>
<ul>
<li>STM：基于ARM®的32位微控制器</li>
<li>F：通用类型</li>
<li>103：增强型</li>
<li>C：48脚</li>
</ul>
<a id="more"></a>
<ul>
<li>8：64K字节的闪存存储器</li>
<li>T：LQFP封装</li>
<li>6：工业级温度范围，-40°C~85°C</li>
</ul>
<h2 id="rcc">2 RCC</h2>
<p><strong>R</strong>eset and <strong>C</strong>lock <strong>C</strong>ontrol——复位和时钟控制</p>
<h3 id="复位">2.1 复位</h3>
<p>三种不同方式，影响的区域不同</p>
<ul>
<li>系统复位：除时钟控制器寄存器中的复位标志位和备份区域</li>
<li>上电复位：除备份区域</li>
<li>备份区域复位：只影响备份区域</li>
</ul>
<h3 id="时钟">2.2 时钟</h3>
<p>三种不同的时钟来源，用来驱动系统时钟</p>
<ul>
<li>HSI(高速内部时钟信号)：由内部8MHz的RC振荡器产生</li>
<li>HSE(高速外部时钟信号)：在这个模式里，必须提供外部时钟。它的频率最高可达25MHz</li>
<li><strong>PLL</strong>(锁相环倍频输出)：用来倍频HSI RC的输出时钟或HSE晶体输出时钟
<ul>
<li>实验因为使用USB模块，其需要一个48MHz的时钟源，只能从PLL输出端获取，因此我们实验时只能使用此模式</li>
</ul></li>
</ul>
<p>编程时，要使用<em>某个IO口</em>或者<em>外设</em>时就必须要对相应的时钟进行<em>使能</em></p>
<h2 id="gpio">3 GPIO</h2>
<h3 id="模式">3.1 模式</h3>
<p>有三种模式</p>
<ul>
<li>通用输出
<ul>
<li>推挽(有上拉电阻)</li>
<li>开漏(直接输出)</li>
</ul></li>
<li>复用功能输出
<ul>
<li>推挽</li>
<li>开漏</li>
</ul></li>
<li>输入</li>
</ul>
<h3 id="复用功能输出">3.2 复用功能输出</h3>
<p>因为板子上有很多外设（<code>ADC</code>  <code>DAC</code>  <code>UART</code> 等），为了节省引脚，所以将一些GPIO口作为这些外设的输出引脚。比如说，为了实现电脑和STM32的通信，<code>PA9</code>和<code>PA10</code>就被复用作为<code>UART1</code>的发送接收引脚了</p>
<p>3.3 重映射</p>
<blockquote>
<p>每个内置外设都有若干个输入输出引脚，一般这些引脚的输出端口都是固定不变的，为了让设计工程师可以更好地安排引脚的走向和功能，在STM32中引入了外设引脚重映射的概念，即一个外设的引脚除了具有默认的端口外，还可以通过设置重映射寄存器的方式，把这个外设的引脚映射到其它的端口。</p>
</blockquote>
<p>比如，<code>UART1</code> 的 <code>Tx</code> , <code>Rx</code> 引脚在 <code>PA9</code> 和 <code>PA10</code> 上，但是同时它有两个映射端口<code>PB6</code> ，<code>PB7</code>。开启重映射，<code>PB6</code> 和<code>PB7</code> 同样可以使用UART11。</p>
<h2 id="中断和事件">4 中断和事件</h2>
<h3 id="nvic">4.1 NVIC</h3>
<p>嵌套的向量式中断控制器</p>
<h3 id="exti">4.2 EXTI</h3>
<p>外部中断/事件控制器</p>
<p>能产生事件/中断请求的边沿检测器。每个输入线可以独立地配置输入类型(脉冲或挂起)和对应的触发事件(上升沿或下降沿或者双边沿都触发)。</p>
<h2 id="定时器">5 定时器</h2>
<h3 id="普通定时器timx2345">5.1 普通定时器TIMx(2\3\4\5)</h3>
<p>通用定时器是一个通过<strong>可编程预分频</strong>器驱动的16位自动装载<strong>计数器</strong>构成。可以用来测量输入信号的脉冲长度或者产生输出波形。</p>
<p>对定时器的修改主要通过改变3个定时器来实现</p>
<ul>
<li>计数器寄存器(<code>TIMx_CNT</code>)</li>
<li>预分频器寄存器 (<code>TIMx_PSC</code>)
<ul>
<li>1-65536</li>
</ul></li>
<li>自动装载寄存器 (<code>TIMx_ARR</code>)</li>
</ul>
<h2 id="usart">6 USART</h2>
<p><em>通用同步异步收发器</em> 支持全双工同步异步数据交换，使用多缓冲配置器的DMA方式，可以实现高速数据通信。</p>
<p>任何USART双向通信至少需要两个脚：接收数据输入(<code>RX</code>)和发送数据输出(<code>TX</code>)。</p>
]]></content>
      <categories>
        <category>Robotics</category>
        <category>Hardware</category>
        <category>Embedded System</category>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>8051 Instructions</title>
    <url>/2019/01/11/Robotics/Hardware/Embedded%20System/8051/8051-Instructions/</url>
    <content><![CDATA[<h2 id="overall">1 Overall</h2>
<p>共性：</p>
<ol type="1">
<li>立即数不能作为<strong>目的操作数</strong></li>
<li>以<code>A</code>为目的操作数的指令会影响<code>Parity</code></li>
<li><code>Rn</code>与<code>Rn</code>、<code>Rn</code>与<code>@Ri</code>、<code>@Ri</code>与<code>@Ri</code>不能同时出现在指令的源、目的操作数中。</li>
</ol>
<a id="more"></a>
<p>操作数的表现形式</p>
<ul>
<li><strong>内部RAM：<code>A</code>、<code>Rn</code>、<code>@Ri</code>、<code>direct</code>、<code>#data</code></strong></li>
<li><strong>外部RAM：<code>@DPTR</code>、<code>@Ri</code></strong></li>
<li><strong>ROM：<code>@A+DPTR</code>、<code>@A+PC</code></strong></li>
</ul>
<h2 id="数据传送指令">2 数据传送指令</h2>
<p>除以累加器<code>A</code>为目的操作数的数据传送指令对P标志位有影响外，其余数据传送指令均不影响标志位。</p>
<h3 id="内部ram">2.1 内部RAM</h3>
<ul>
<li><strong>MOV</strong></li>
<li>在<code>A</code>、<code>Rn</code>、<code>@Ri</code>、<code>direct</code>、<code>#data</code>之间互传
<ul>
<li>除了<em><code>Rn</code>之间</em>、<em><code>Rn</code>与<code>@Ri</code>之间</em>、<em><code>@Ri</code>之间</em></li>
<li><code>direct</code>可以自己传自己</li>
</ul></li>
</ul>
<h3 id="外部ram">2.2 外部RAM</h3>
<ul>
<li><strong>MOVX</strong></li>
<li>其中必有一个为<code>A</code></li>
<li>另外一个操作数（在片外）：
<ul>
<li><code>@Ri</code>，片外低256字节</li>
<li><code>@DPTR</code>，片外64K</li>
</ul></li>
</ul>
<h3 id="rom">2.3 ROM</h3>
<ul>
<li><strong>MOVC</strong></li>
<li>都是读入<code>A</code>中</li>
<li>只有两种
<ul>
<li><code>@A+DPTR</code> ：<code>DPTR</code>相当于表的位置，<code>A</code>=欲查数值距离表首地址的值</li>
<li><code>@A+PC</code>：<code>PC</code>相当于表的位置，<code>A</code>=表首地址－当前指令的<code>PC</code>值－1</li>
</ul></li>
</ul>
<h2 id="算术运算">3 算术运算</h2>
<p>除了<code>++</code>和<code>--</code>以外都影响标志位</p>
<ol type="1">
<li><strong>INC</strong>  <strong>DEC</strong>：只有<code>DPTR</code>不能--</li>
<li><strong>ADD</strong>  <strong>ADDC</strong>  <strong>SUBB</strong>
<ul>
<li>都存入<code>A</code>，只有<code>DPTR</code>不能进行运算</li>
<li><strong>ADDC</strong>：(A)<span class="math inline">\(\leftarrow\)</span>(A)+(Cy)+(第二操作数)</li>
<li><strong>SUBB</strong>: (A)<span class="math inline">\(\leftarrow\)</span> (A)－(Cy)－(第二操作数)</li>
</ul></li>
<li><strong>MUL</strong>   <strong>DIV</strong>
<ol type="1">
<li><strong>MUL</strong>: 低八位进<code>A</code>，高8位进<code>B</code></li>
<li><strong>DIV</strong>：整数进<code>A</code>，余数进<code>B</code></li>
</ol></li>
</ol>
<h2 id="逻辑运算">4 逻辑运算</h2>
<p>目的操作数是A时影响P标志位。除了两条带进位的循环移位指令影响C标志外，其余均不影响PSW中的各标志位。</p>
<ol type="1">
<li><p><strong>ANL</strong>  <strong>ORL</strong>  <strong>XRL</strong></p></li>
<li><p><strong>RL</strong>  <strong>RR</strong>  <strong>RLC</strong>  <strong>RRC</strong></p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/logical-op.png" alt="logical-operation" /><figcaption aria-hidden="true">logical-operation</figcaption>
</figure></li>
<li><p><strong>CLR</strong>  <strong>CPL</strong></p></li>
</ol>
]]></content>
      <categories>
        <category>Robotics</category>
        <category>Hardware</category>
        <category>Embedded System</category>
        <category>8051</category>
      </categories>
      <tags>
        <tag>8051</tag>
      </tags>
  </entry>
  <entry>
    <title>RRT ROS implementation</title>
    <url>/2018/11/25/Robotics/Project/RRT-ROS/</url>
    <content><![CDATA[<h1 id="rrt-ros">RRT-ROS</h1>
<h2 id="rrt算法简介与实现">1 RRT算法简介与实现</h2>
<h3 id="基本思想">1.1 基本思想</h3>
<p>​ RRT，即<strong>rapidly exploring random tree</strong>是一种在可以高维空间中有效搜索路径的方法，它的主要思想是通过在空间中随机取点，以取样点为依据增量式扩展路径搜索树直到终点和起点都包含在搜索树中。</p>
<a id="more"></a>
<h3 id="伪代码">1.2 伪代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Algorithm BuildRRT</span><br><span class="line">  Input: Initial configuration qinit, number of vertices in RRT K, incremental distance Δq)</span><br><span class="line">  Output: RRT graph G</span><br><span class="line"></span><br><span class="line">  G.init(qinit)</span><br><span class="line">  for k &#x3D; 1 to K</span><br><span class="line">    qrand ← RAND_CONF()</span><br><span class="line">    qnear ← NEAREST_VERTEX(qrand, G)</span><br><span class="line">    qnew ← NEW_CONF(qnear, qrand, Δq)</span><br><span class="line">    G.add_vertex(qnew)</span><br><span class="line">    G.add_edge(qnear, qnew)</span><br><span class="line">  return G</span><br></pre></td></tr></table></figure>
<h3 id="代码实现">1.3 代码实现</h3>
<h4 id="ros-navigation实现架构">1.3.1 ROS-navigation实现架构</h4>
<p>总的来说，navigation导航包的输入是<code>里程计和传感器数据流</code>，输出是<code>速度命令</code>给机器人。</p>
<p>我们要修改的是其中的路径规划部分，即global_planner，只需要给出一串<strong>从起点到终点的点序列</strong>即可。</p>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/nav-global-planner.png" /></p>
<p>我们只需要做好其中红色线围起来的一部分，也就是说输入是起始点，终点，costmap（地图），输出是Path</p>
<h4 id="rrt-c实现架构">1.3.2 RRT-C++实现架构</h4>
<p>思考步骤：</p>
<ol type="1">
<li><p>在planner_core.cpp中找到得到path的函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!path_maker_-&gt;getPath(potential_array_, costmap_-&gt;getCharMap(), start_x, start_y, goal_x, goal_y, path))</span><br><span class="line">&#123;</span><br><span class="line">    ROS_ERROR(<span class="string">&quot;NO PATH!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>发现path_maker_ 在源程序中是<code>GridPath(p_calc_)</code> 或<code>GradientPath(p_calc_)</code>，都是输入势场，得到路径，而RRT不需要势场，所以仿照GridPath写RRT实现并修改</p></li>
<li><p>在rrt.h中定义<code>rrtPlannerC</code>类继承<code>Traceback</code>，在rrt.cpp中实现主体<code>getPath</code>函数</p></li>
</ol>
<h4 id="rrt-c实现思路">1.3.3 RRT-C++实现思路</h4>
<p>RRT的实现不难，要考虑的问题主要有3个：</p>
<ol type="1">
<li><p><strong>如何进行随机采样</strong></p>
<ul>
<li><p>为了使RRT具有广泛的通用性，不受障碍物的过多干扰，所以采样应尽可能多方向采样</p></li>
<li><p>但如果采样范围太广，会使得距离最近的计算失去意义</p></li>
<li><p>如果采样范围太小，RRT树就会只朝着几乎一个方向运动，或者让机器人在一个范围内绕圈</p></li>
<li><p>所以我测量了有效地图的大小， 并按分辨率还原坐标</p></li>
<li><p>Xl:94.65/0.05=1893</p>
<p>Xr:108.90/0.05=2178</p>
<p>Yb:90.65/0.05=1813</p>
<p>Yu:101.484/0.05=2029</p>
<p>为了让边界的点也能被运动到，所以还要再放宽一点。最后我选择了 (1873,1793) to (2213,2053)</p></li>
</ul></li>
<li><p><strong>如何定义最近点</strong></p>
<p>欧式距离， <span class="math display">\[
\sqrt{dx^{2}+dy^{2}}
\]</span></p></li>
<li><p><strong>如何进行树的扩展</strong></p>
<p>树的扩展是RRT算法中最重要的一部分：</p>
<ul>
<li>数据结构：树的数据结构是由定义的rrt_point组成的一维vector，其中rrt_point是一个struct，有3个变量，坐标（double x，double y）和父节点在数组中的位置（int parent）。</li>
<li>随机采样之后，遍历树中的所有点，找到最近点，然后将不在墙中的有效随机点加入到树中，parent设为最近点的位置，这样，当最后到达终点后就能反推出一整条线路，push进path</li>
</ul></li>
</ol>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/rrt-tree.png" /></p>
<p>具体实现参考附件中的rrt.cpp及rrt.h中的代码及注释</p>
<h2 id="实验结果">2 实验结果</h2>
<h3 id="dijkstra">2.1 Dijkstra</h3>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/nav-dij.png" /></p>
<h3 id="a">2.2 A*</h3>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/nav-astar.png" /></p>
<h3 id="rrt">2.3 RRT</h3>
<p><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/nav-rrt.png" /></p>
<h2 id="rrt对比实验包含改进算法">3 RRT对比实验（包含改进算法）</h2>
<p>由于单纯RRT没有利用终点和墙壁信息，所以改进算法由2部分组成</p>
<ul>
<li>利用终点，让随机采样的点更加趋向于终点，这种方法类似于人工势场法</li>
<li>利用墙壁信息，在生成路径后将一些多余的点删除，也就是说尽量走直线，只有遇到墙时才拐弯</li>
</ul>
<h3 id="概览">3.1 概览</h3>
<p>在本项目中，可改变的参数有4个，分别是：</p>
<table>
<thead>
<tr class="header">
<th>变量名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>step</td>
<td>每次增加的步长</td>
</tr>
<tr class="even">
<td>use_potential</td>
<td>是否使用势场法改进RRT</td>
</tr>
<tr class="odd">
<td>k</td>
<td>改进RRT中势能所占的比值</td>
</tr>
<tr class="even">
<td>smooth</td>
<td>是否使用算法减少路径中无用的点，达到光滑效果</td>
</tr>
</tbody>
</table>
<h3 id="实验设计">3.2 实验设计</h3>
<p>路径规划算法所要考虑的主要是时间以及距离。</p>
<ul>
<li>时间可以通过ROS的计时工具得到</li>
<li>距离可以通过点的数量来计算（因为两点之间的距离都是step）</li>
<li>如果使用smooth，则距离通过勾股定理计算距离和</li>
</ul>
<p>所以我的实验步骤如下：</p>
<ol type="1">
<li>考察step值对算法的影响</li>
<li>考察potential势场法对算法的影响</li>
<li>考察不同k值对改进算法的影响</li>
<li>考察smooth对算法的影响</li>
</ol>
<h3 id="实验过程">3.3 实验过程</h3>
<h4 id="考察step值对算法的影响">3.3.1 考察step值对算法的影响</h4>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">step</th>
<th style="text-align: center;">效果</th>
<th style="text-align: center;">用时(s)</th>
<th style="text-align: center;">距离</th>
<th style="text-align: center;">采样点</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;"><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/rrt-step-1.png" /></td>
<td style="text-align: center;">14.082</td>
<td style="text-align: center;">408</td>
<td style="text-align: center;">12623</td>
</tr>
<tr class="even">
<td style="text-align: center;">3</td>
<td style="text-align: center;"><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/rrt-step-3.png" /></td>
<td style="text-align: center;">0.134</td>
<td style="text-align: center;">348</td>
<td style="text-align: center;">388</td>
</tr>
<tr class="odd">
<td style="text-align: center;">7</td>
<td style="text-align: center;"><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/rrt-step-7.png" /></td>
<td style="text-align: center;">0.149</td>
<td style="text-align: center;">420</td>
<td style="text-align: center;">470</td>
</tr>
<tr class="even">
<td style="text-align: center;">15</td>
<td style="text-align: center;"><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/rrt-step-15.png" /></td>
<td style="text-align: center;">0.175</td>
<td style="text-align: center;">420</td>
<td style="text-align: center;">100</td>
</tr>
</tbody>
</table>
<p>通过对比可以发现，step的选择应该要适中</p>
<ul>
<li>如果step太小，会耗费大量的时间，实时性非常差</li>
<li>如果step太大，路径的扩展步子太大，就有可能如7、15这样的情况，在终点处有超过终点的意思，造成距离的增加</li>
<li>适当的step不仅耗时少，距离也短</li>
</ul>
<h4 id="考察potential势场法对算法的影响k0.8">3.3.2 考察potential势场法对算法的影响（k=0.8）</h4>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">地点</th>
<th style="text-align: center;">普通</th>
<th style="text-align: center;">势场</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;"><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/rrt-normal-1.png" /></td>
<td style="text-align: center;"><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/rrt-potential-1.png" /></td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;"><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/rrt-normal-2.png" /></td>
<td style="text-align: center;"><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/rrt-potential-2.png" /></td>
</tr>
</tbody>
</table>
<p>通过相同地点的不同算法可以看出，由于势场法加入了终点的信息，所以在路径生成的过程中更加平坦。</p>
<ul>
<li><p>优点：</p>
<ul>
<li>路径平坦</li>
<li>距离更短</li>
</ul></li>
<li><p>缺点</p>
<ul>
<li>当起点与终点中存在墙时，采样的点更加多，因为大量点由于被终点吸引而进入墙中而导致的</li>
</ul></li>
<li><p>总结：</p>
<p>适合于路径弯折不多的情况</p></li>
</ul>
<h4 id="考察不同k值对改进算法的影响">3.3.3 考察不同k值对改进算法的影响</h4>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">k值</th>
<th style="text-align: center;">效果</th>
<th style="text-align: center;">算法计算时间</th>
<th style="text-align: center;">距离(绿线)</th>
<th style="text-align: center;">采样点数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0.1</td>
<td style="text-align: center;"><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/rrt-k-01.png" /></td>
<td style="text-align: center;">0.273</td>
<td style="text-align: center;">321</td>
<td style="text-align: center;">1003</td>
</tr>
<tr class="even">
<td style="text-align: center;">0.5</td>
<td style="text-align: center;"><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/rrt-k-05.png" /></td>
<td style="text-align: center;">0.258</td>
<td style="text-align: center;">357</td>
<td style="text-align: center;">1048</td>
</tr>
<tr class="odd">
<td style="text-align: center;">0.8</td>
<td style="text-align: center;"><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/rrt-k-08.png" /></td>
<td style="text-align: center;">0.107</td>
<td style="text-align: center;">426</td>
<td style="text-align: center;">862</td>
</tr>
<tr class="even">
<td style="text-align: center;">1.0</td>
<td style="text-align: center;"><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/rrt-k-10.png" /></td>
<td style="text-align: center;">16.161</td>
<td style="text-align: center;">1002</td>
<td style="text-align: center;">10272</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1.0</td>
<td style="text-align: center;"><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/rrt-k-101.png" /></td>
<td style="text-align: center;">1.431</td>
<td style="text-align: center;">213</td>
<td style="text-align: center;">4965</td>
</tr>
</tbody>
</table>
<p>对比可以发现，k值的选择同样很tricky</p>
<ul>
<li>如果k太小，则几乎没有效果</li>
<li>如果k太大，则会在一些特殊情况下造成采样点的大量增加</li>
<li>如果k适中，则能够使路径更加平滑，更加趋向于最短距离</li>
</ul>
<h4 id="考察smooth对算法的影响">3.3.4 考察smooth对算法的影响</h4>
<table>
<thead>
<tr class="header">
<th>算法</th>
<th>效果</th>
<th>时间</th>
<th>距离</th>
<th>点数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>RRT</td>
<td><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/rrt-rrt.png" /></td>
<td>0.134</td>
<td>348</td>
<td>388</td>
</tr>
<tr class="even">
<td>potential</td>
<td><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/rrt-potential.png" /></td>
<td>0.258</td>
<td>357</td>
<td>1048</td>
</tr>
<tr class="odd">
<td>smooth</td>
<td><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/rrt-smooth.png" /></td>
<td>0.1700</td>
<td>300</td>
<td>1061</td>
</tr>
</tbody>
</table>
<p>通过对比可以看出，使用smooth可以减少距离，大量的直线也减少了local_planner的工作量</p>
<h4 id="与dijkstraa算法比较">3.3.5 与Dijkstra、A*算法比较</h4>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">算法</th>
<th style="text-align: center;">效果</th>
<th style="text-align: center;">计算用时s</th>
<th style="text-align: center;">实际用时s</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">A*</td>
<td style="text-align: center;"><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/rrt-compare-astar.png" /></td>
<td style="text-align: center;">0.152</td>
<td style="text-align: center;">85</td>
</tr>
<tr class="even">
<td style="text-align: center;">Dijkstra</td>
<td style="text-align: center;"><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/rrt-compare-dij.png" /></td>
<td style="text-align: center;">0.141</td>
<td style="text-align: center;">90</td>
</tr>
<tr class="odd">
<td style="text-align: center;">RRT</td>
<td style="text-align: center;"><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/rrt-compare-rrt.png" /></td>
<td style="text-align: center;">0.134</td>
<td style="text-align: center;">89</td>
</tr>
<tr class="even">
<td style="text-align: center;">smooth-rrt</td>
<td style="text-align: center;"><img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/rrt-compare-smoothrrt.png" /></td>
<td style="text-align: center;">0.145</td>
<td style="text-align: center;">93</td>
</tr>
</tbody>
</table>
<p>可以看到，几种算法都没有特别显著的区别。</p>
<h2 id="四-结论与展望">四 结论与展望</h2>
<p>RRT算法在全局路径规划中主要有以下优点：</p>
<ul>
<li>简单：结构简单、思想简单、实现简单</li>
<li>易优化：非常容易加入一些额外信息来提高算法的表现</li>
<li>通用性：RRT算法几乎在所有情况下都有不错的表现，就因为他利用了强大的扩展能力</li>
</ul>
<p>但是也存在一些缺点：</p>
<ul>
<li>不是最优解：由于只是随机的扩展，所以RRT和最优扯不上什么关系</li>
<li>没有在扩展时充分利用信息。如：终点位置、墙壁位置等，如果都考虑的话，就用不着RRT了</li>
</ul>
<p>可以说，RRT可以作为在较为复杂地图中的默认路径规划算法，虽然没有最优的表现，但是经过简单优化也能有不错的表现，可以作为和其他算法对比的基准。</p>
<h1 id="参考文献">参考文献</h1>
<blockquote>
<p>https://en.wikipedia.org/wiki/RRT</p>
<p>http://msl.cs.uiuc.edu/rrt/</p>
<p>[Incremental Sampling-based Algorithms for Optimal Motion Planning][Steve Lavalle]</p>
<p>http://wiki.ros.org/navigation/</p>
<p>http://wiki.ros.org/global_planner?distro=indigo</p>
</blockquote>
]]></content>
      <categories>
        <category>Robotics</category>
        <category>Project</category>
      </categories>
      <tags>
        <tag>robotics</tag>
        <tag>navigation</tag>
        <tag>rrt</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2020/08/08/Math/math-for-cs/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>爱</title>
    <url>/2020/08/06/Philosophy/love/</url>
    <content><![CDATA[<h2 id="intro">Intro</h2>
<p>我们要如何分析个人的爱？</p>
<ul>
<li>对妻子的爱与对父母、孩子、朋友之间的爱的区别</li>
<li>爱情能被证明是正当的吗</li>
<li>个人爱情的价值与意义</li>
</ul>
<h2 id="区分">区分</h2>
<p>不同的爱之间显然是不同的。古希腊先贤们已经有了一些划分</p>
<ul>
<li>Eros，来自于本能，对物体的一种强烈欲望的爱。典型的有性爱，这种爱是自私的，这种反应应该发展为对人的灵魂之美的反应<br />
</li>
<li>Agape，宗教意味浓厚的爱，上帝对我们，我们对上帝的爱。这是一种兄弟般的爱，“自发的而没有动机的”</li>
<li>Philia，对某个好的品质做出的反应。与Eros之间的区别主要在于性的参与</li>
</ul>
<p>当代，我们所主要关注的爱主要是Eros和Philia。</p>
<p>另一个重要的问题在于我们要如何区分<strong>爱</strong>与<strong>喜欢</strong>，直觉上看，两者似乎只是程度上的区别，那么如何区分<strong>程度</strong>呢？有的分析将程度理解为<strong>欲望的多少</strong>，或者说对象所具有的<strong>工具价值</strong>。然而这种分析是<strong>不充分的</strong>，因为我们可以关心或者爱一个人而不关注其工具价值。</p>
<p>另一种常见的区分方式是<strong>认同</strong>，<strong>爱</strong>一个人是在某种程度上认同他，而<strong>喜欢</strong>不涉及认同的概念。Whiting认为对认同概念的诉求扭曲了我们对爱的动机的理解，因为如果是认同，那么这种动机更像是自我利益。Whiting主张爱的中心是<strong>可能性</strong>——被所爱之人的兴趣所感动而暂时忘却自我。</p>
<p>还有一种区分方式是<strong>评估</strong>，爱情本质上是不是属于一种独特的评价？这是一个讨论激烈的话题。与之密切相关的问题是：我们能否证明爱的正当性</p>
<h2 id="爱作为联合">爱——作为联合</h2>
<p>关键在于理解一个联合，“我们”，如何定义我们，是一个具体表现还是仅仅是一种比喻</p>
<p>总的来说就是我想和你在一起，因为你身上有某些特质，我举得我和你在一起能够受益。虽然这种受益已经是最终的目的而不是通向其他欲望的手段。</p>
<p>在这样的理解中，爱会使人失去一些自主性，但是这可能是爱的一个可接受的后果</p>
<h2 id="爱作为稳定关怀">爱——作为稳定关怀</h2>
<p>这一派认为对心爱之人的关注是爱的中心和定义特征。爱既不是情感，也不是认知，而是意志。</p>
<p>Frankfurt：一个人关心某事物，是因为他的背景塑造了他的偏好，引导和限制了他的行为</p>
<h2 id="爱作为价值">爱——作为价值</h2>
<p>爱是一种独特的评价一个人的方式</p>
<h3 id="作为价值的评估">作为价值的<strong>评估</strong></h3>
<p>爱是一种独特的方式承认和回应所爱之人的价值的问题。为了理解这个问题，我们需要知道什么是价值</p>
<h3 id="作为价值的赋予">作为价值的<strong>赋予</strong></h3>
<p>Singer认为喜欢本质上是目的性的，而爱是没有明确目标的态度，因此爱也无法被准确定义。</p>
<p>通过关心被爱者的需要和利益，通过希望造福或者保护，通过为她的成就而感到高兴等。与稳定关怀的区别在于这种关心并不构成爱的本身，而只是一种手段，让对方变得更有价值。</p>
<h2 id="爱作为情绪">爱——作为情绪</h2>
<p>情感只是对对象的评估、动机和现象，这些都是爱的中心特征。</p>
<p>然而这种说法的问题在于情感这个词包含的含义太复杂，和爱一样没有解释什么</p>
<h3 id="作为情绪本身">作为<strong>情绪</strong>本身</h3>
<p>这种描述方式类似于评价</p>
<p>情绪是一种含蓄的评价，比如说，生气时评价为冒犯，害怕时评价为危险。情绪时激情的，是受外界环境干扰的</p>
<h3 id="作为情绪混合体">作为情绪混合体</h3>
<p>爱不仅是人对于其他人的一种情感，也是两个人或者几个人之间的复杂联系</p>
<h2 id="为什么要爱">为什么要爱？</h2>
<p>一种方式：问我们从中得到了什么。亚里士多德的答案：所爱之人充当一面镜子，看出自己的性格，拥有爱的关系能够促进自我认识。从这个层面来说，所爱之人应该与我们相似；Brink的答案：与多样化的其他人互动可以帮助我们认识生活的其他可能性，从而更好地评估这些可能性的相对优点。</p>
<p>另一种方式：从心理学来解释。爱增加了我们的幸福感，提升了我们的自我价值感，有助于发展我们的性格。可以降低压力和血压，增加寿命。</p>
<ul>
<li><p>有什么理由让我爱这个人而不是不爱他呢？</p>
<p>这个问题是可以有答案的</p></li>
<li><p>有什么理由让我爱这个人而不是其他人呢？</p>
<p>这个问题可能没有理性的解答</p></li>
<li><p>在环境发生了变化中之后，有什么理由继续爱这个人呢？</p>
<p>这个问题可能没有理性的解答</p></li>
</ul>
<p>如果爱可以是被证明的（合理化的），那么就会产生一些担忧</p>
<ol type="1">
<li>我们所爱之人只是一堆优点的对象化，这实际上是对财产的爱</li>
<li>第二个担忧是爱的对象的可替换性。如果另一个人展示了更好的属性，我们似乎可以升级一下，然而显然（？）我们的爱是不可替代的，爱似乎涉及到对某特特定人的深深的个人承诺。</li>
</ol>
<p>这两种担忧可以被<strong>联合</strong>所解释，爱情的目的是形成一个我们，并将其视为一个延申的自我。</p>
]]></content>
      <categories>
        <category>Philosophy</category>
      </categories>
      <tags>
        <tag>Philosophy</tag>
      </tags>
  </entry>
  <entry>
    <title>labuladong学习笔记</title>
    <url>/2020/07/13/CS/DS%20&amp;%20Algorithm/labuladong/</url>
    <content><![CDATA[<h2 id="why">Why</h2>
<p>我从一个礼拜左右前开始刷题，到目前刷了三十几道，感觉逐渐有点上手，但没有一个系统的框架。在刷一道二分法的题目时，看到了labuladong的笔记，感觉思路清晰，值得学习。之后还发现他总结了一系列的算法框架并写了文章，所以在这里记录下阅读时的收获</p>
<h2 id="动态规划">动态规划</h2>
<p>目标：<strong>求最值</strong>。动态规划是运筹学中的最优化方法，在CS中应用较多</p>
<p>核心思想：<strong>穷举</strong>。把所有的可行答案穷举并找最值</p>
<p>难点：存在“重叠子问题”，直接暴力穷举效率低下。需要记<strong>录下一些中间过程</strong>节省计算量</p>
<p>方法：找到<strong>最优子结构</strong>，并列出正确的<strong>状态转移方程</strong>。</p>
<ul>
<li>技巧：状态压缩，每次只记录必要的数据</li>
</ul>
<h2 id="回溯法">回溯法</h2>
<p>实际上是决策树的遍历过程，要考虑三个问题</p>
<ol type="1">
<li>路径</li>
<li>选择列表</li>
<li>结束条件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result &#x3D; []</span><br><span class="line">def backtrack(路径, 选择列表):</span><br><span class="line">    if 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    for 选择 in 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure>
<p>在全排列问题中</p>
<ol type="1">
<li>路径就是已经用掉的数字</li>
<li>选择列表就是还剩下的数字</li>
<li>结束条件就是列表为空</li>
</ol>
<h2 id="数组">数组</h2>
<p>数组主要就是考察插入、删除和搜索</p>
<p>为了节省内存空间，利用in-place操作可以达到<span class="math inline">\(O(1)\)</span>的空间复杂度</p>
<ul>
<li>为了实验in-place的操作，往往会使用<strong>双指针</strong></li>
</ul>
<h2 id="链表">链表</h2>
<p>单向链表：遍历、插入、删除</p>
<p>双向链表：相比于单向链表，在插入和删除时要更加小心。但是在删除时会更加容易，不需要<span class="math inline">\(O(N)\)</span>的时间复杂度去找到上一个结点</p>
<p>在知道<strong>前一个</strong>结点的情况下，链表的插入和删除都是非常快的</p>
<p>双指针技巧同样非常有用。相比数组更加容易出错</p>
<ul>
<li>要多检查是否结点为空</li>
<li>多检查几遍确保循环能够正确结束
<ul>
<li>多尝试一些边界条件</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>DS &amp; Algorithm</category>
      </categories>
      <tags>
        <tag>DS</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象编程</title>
    <url>/2020/06/12/CS/Python/oop-python/</url>
    <content><![CDATA[<h2 id="overview">Overview</h2>
<p>主要分成四个部分</p>
<ol type="1">
<li>面向对象的准则
<ul>
<li>面向对象设计，抽象、类、封装、继承</li>
<li>对象</li>
<li>对象相似时</li>
<li>异常捕获</li>
</ul></li>
<li>这些准则如何应用到Python内置函数中、
<ul>
<li>何时使用面向对象</li>
<li>Python数据结构</li>
<li>面向对象的捷径</li>
<li>字符串与序列化</li>
</ul></li>
<li>设计模式
<ul>
<li>迭代器模式</li>
<li>装饰器模式、观察者模式</li>
<li>适配器模式、门面模式</li>
</ul></li>
<li>有趣的主题
<ul>
<li>测试面向对象程序</li>
<li>并发</li>
</ul></li>
</ol>
<hr />
<p>在现实中，<strong>设计</strong>并不会在<strong>编程</strong>之前就完成，实际上，分析、编程、设计是相互重叠的。</p>
<p>什么是对象？对象是<strong>数据</strong>与相关<strong>行为</strong>的集合。<em>增查删改？</em></p>
<p>什么是面向对象？用<strong>数据</strong>和<strong>行为</strong>来描述真实事物。在实现的过程中分为三个阶段</p>
<ol type="1">
<li><p>面向对象分析，输出是一系列需求</p>
<p>确定所需的对象的对象之间的相互关系。内容包括客户访问、消除不必要的可能性</p></li>
<li><p>面向对象设计，输出是实现方案</p>
<p>将需求转化为实现方案。命名对象、定义其行为。此阶段关注的是如何完成，将需求转化为一系列类和接口，从而使得整个系统可以使用编程语言实现（<strong>理论上</strong>）</p></li>
<li><p>面向对象编程，输出是可以运行的程序</p>
<p>将设计转化为可以运行的程序的过程</p></li>
</ol>
<p>如果现实中也能向上面这样理想就好了。但是真实世界是更加黑暗的。在设计阶段有了更多的需求、在编程的时候设计发生了变化等。因此21世纪的开发都遵循迭代开发的模型。</p>
<ul>
<li><p>对象与类</p>
<p>利用UML图，我们可以描述类之间的关系</p></li>
<li><p>指定属性和行为</p>
<ul>
<li><p>数据代表着属性，或者说特性</p>
<p>在设计阶段，不需要过度担心数据类型的问题</p></li>
<li><p>行为就是在对象上的动作，或者叫方法。</p>
<p>分析与设计就是为了弄清楚这些对象之间如何交互</p></li>
</ul></li>
<li><p>隐藏细节，创建<strong>公共接口</strong></p>
<p>公共接口需要仔细设计，因为在未来很难更改。</p>
<p>不要设计未来可能有用的对象或者建模，<strong>只建模当下的需求</strong></p></li>
<li><p>设计<strong>抽象的层级</strong>有不同的方法或者说设计模式，大部分都依赖于两个基本的原则：</p>
<ol type="1">
<li>组合。物理对象通常很容易分解为零件对象</li>
<li>继承。最有名但也是被过度使用的一种关系，<strong>需要满足”是一个“这种关系</strong>，而不能为了减少代码而在两个关系很小的类之间继承。</li>
</ol></li>
<li><p>多态，不同的参数排列不同的实现方式。</p>
<p>Python是动态语言，所以是鸭子类型，不需要严格规定类，只需要类的方法一样即可</p></li>
<li><p>多重继承，棘手但是很有用</p>
<p>避免出现拥有相同方法的情况。</p></li>
</ul>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>oop</tag>
      </tags>
  </entry>
  <entry>
    <title>Python对象</title>
    <url>/2020/06/17/CS/Python/python-object/</url>
    <content><![CDATA[<h2 id="python类">Python类</h2>
<p>Python有风格指南PEP8，类命名使用驼峰格式，大写字母开头，任意后续单词都以大写字母开头</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoPoint</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reset</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.x=<span class="number">0</span></span><br><span class="line">        self.y=<span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,x=<span class="number">0</span>,y=<span class="number">0</span></span>):</span></span><br><span class="line">        self.x=x</span><br><span class="line">        self.y=y</span><br></pre></td></tr></table></figure>
<ul>
<li><p>添加属性，直接在实例中添加属性</p>
<ul>
<li>点标记法，<em>对象.属性=值</em></li>
</ul></li>
<li><p>添加方法，以def关键词开头</p>
<p>函数与方法之间的区别之一是，所有的方法都有一个必要的参数，按照<strong>惯例</strong>，这个参数命名为self</p></li>
<li><p>初始化，开头和结尾的双下划线表示特殊方法，可以提供默认参数</p></li>
<li><p>注释，通过docstring的方式来支持文档注释</p>
<p>在每个类、函数的定义语句（冒号结尾的那一行）添加标准字符串作为第一行</p></li>
</ul>
<h2 id="模块和包">模块和包</h2>
<p>通过import语句可以导入模块或者模块中特定的类、函数。</p>
<ul>
<li>永远不要用 from database import *这种语法，因为不利于后期的代码维护</li>
</ul>
<p><strong>包</strong>是模块的集合，方便我们管理模块。导入的方式有两种</p>
<ul>
<li>绝对导入，from ecommerce.products import Product。用这种语法时，需要将包的搜索目录加入到环境变量中</li>
<li>相对导入，在处理同一个包下的相关模块时，用相对导入 from .database import Database
<ul>
<li>..上一级，.当前级</li>
</ul></li>
</ul>
<h2 id="权限">权限</h2>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>oop</tag>
      </tags>
  </entry>
  <entry>
    <title>自由平等正义</title>
    <url>/2020/06/28/Philosophy/Great%20Ideas/Justice/</url>
    <content><![CDATA[<h2 id="自由">自由</h2>
<p>在三种主要的自由形式</p>
<ul>
<li>天生的选择自由</li>
<li>后天的道德自由</li>
<li>环境制约的行为自由（政治相关）</li>
</ul>
<p>只有社会中的<strong>行动自由</strong>是未被实际否认的。（法无禁止即可为）</p>
<p>自由意志和自由选择是在哲学中被长期讨论的。关键点在于</p>
<ul>
<li>人性是否超越自然？</li>
</ul>
<h2 id="平等">平等</h2>
<p>关键点：是否同意<strong>共同人性</strong></p>
<p>如果肯定人性上人人平等，那么就可以接着考虑</p>
<ul>
<li>环境条件平等</li>
<li>机会平等</li>
</ul>
<p>如何评价平等？将平等分级，先要满足种类上的平等（指大家都处于类似的水平上），然后才能考虑程度上的平等（指大家都有相同的量化结果）</p>
<h2 id="正义">正义</h2>
<p>自古以来有三种关于正义的争辩</p>
<ul>
<li>有权势则有理，权威就是正义</li>
<li>自然正义先于法律正义</li>
<li>功利主义</li>
</ul>
<p>作者认为这三种正义都是有一定道理的。</p>
<p>关于正义还有两个难以解决的问题</p>
<ul>
<li>我们为什么要做到正义？正义和幸福有关吗，表面上看是否定的。但是如果仔细考虑，为了达到善这个终极目的，为了整个一生过上好日子，我必须以正义待人，以正义处理与我所在社区的关系</li>
<li>当别人以不正义的行为做事，我们要怎么办？忍受还是同样不正义？如果我的不正义行为会改变我的习惯气质，并使我最终丧失美德，那么就不应该同样不正义，但其实是不太可能的。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>真善美</title>
    <url>/2020/06/26/Philosophy/Great%20Ideas/Real/</url>
    <content><![CDATA[<h2 id="什么是真">什么是真？</h2>
<blockquote>
<p>第一遍看书时仔细看过，这里就简单摘一些观点</p>
</blockquote>
<p>按照排除法排除那些显然不合理的答案</p>
<ul>
<li>极端怀疑论者：我们无法获得任何知识。如果接受这种观点，我们的生活就很难协调</li>
<li>主观主义怀疑论</li>
<li>相对主义怀疑论</li>
<li>说谎者：说的和自己所想的不一样</li>
</ul>
<h2 id="善">善</h2>
<ul>
<li><p>实然的善是主观的，喜欢的就是善，憎恨的就是恶，因而对每个人来说善是不同的</p>
<p>但这种说法并不会给我们任何新的信息，属于文字游戏。亚里士多德的观点是我们可以从本能出发，寻找天生的欲求。</p></li>
</ul>
<p>于是我们将善和追求联系在一起。我们可以沿用伊比鸠鲁的分析观点，将追求分成必须的和非必须的</p>
<p>我们应该<strong>想要</strong>我们<strong>需要</strong>的，而不应该想要我们不需要的</p>
<p>善也可以分为不同的善吗？</p>
<ul>
<li>想得到的善
<ul>
<li>财产：外在的善，朋友、所爱、外在环境</li>
<li>完美特质：内在的善，健康、感官快乐、美的享受、知识、技巧</li>
<li>选择的善：完全在自愿参加的活动中得到的善</li>
<li>机遇的善：一切外在的善</li>
</ul></li>
</ul>
<p>从表面来看，只要一个人获得了自己想要的东西，那么这个人就可以说是幸福的。然而，每个人所追求的东西是不同的，有的善是实在的，有的善是表观的。守财奴、花花公子所获得幸福是一个幸福的假象，而不是实在的幸福。</p>
<p><strong>如果</strong>幸福对所有的人来说都是一样的，那么这就是终极的善。生活中，人追求幸福的过程可能由于不幸而遭受挫折或者个人的错误选择导致幸福破灭。</p>
<h2 id="美">美</h2>
<p>对于美，有没有道理可以遵循是我们在考虑美时主要考虑的问题</p>
<ul>
<li><p>从<strong>纯粹感官快活</strong>上来说，每个人的审美都是不同的。</p></li>
<li><p>但是我们从纯粹感官快活转向<strong>可享用美的情趣差异</strong>时，某一领域内专家对研究对象美的价值判断比一般人要好</p>
<p>为什么呢？因为专家因为某些因素（经常接触、经验丰富、对成分了解、对生产技术了解）而获得了较高的鉴赏力。</p></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>六大观念</title>
    <url>/2020/06/26/Philosophy/Great%20Ideas/six-great-ideas/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>第一次读这本书是在大二的时候，我在马原老师提供的参考书目中看到了这本书的名字，图书馆上一查还在架上，下了课马上就去图书馆取了书开始看。一开始看的还是很开心的，把<strong>真</strong>这部分看完了，感觉收获许多。后来其他课程过于繁忙就没继续看下去了。这段时间看了西方哲学史，希望再完整看一遍。</p>
<p>在阅读西方哲学史的时候我就感觉概念实在太多，不同时期不同的哲学家都会提出自己的一些新概念新想法，对于我这样的入门者来说很容易失去辩论的焦点。艾德勒的这本六大观念属于哲学范畴史的研究范围，他从整个哲学史中归纳了120个观念，浓缩成64个，最后又精简成6个，可以说是最重要的一些点了。</p>
<h2 id="大观念">大观念</h2>
<p>真善美、公平正义平等，我们日常生活中都会用到这些词，但是我们真的明白这些词意味着什么吗？不是每个人都能对这些观念进行仔细的思考。我也想搞明白这些观念背后意味着什么，那么这本书可以提供<strong>探索答案这个过程的指导</strong></p>
<p>读这本书可以获得的结果</p>
<ul>
<li>对这些观念的意义有所了解</li>
<li>了解关于这些观念背后哲学家们已经进行过的讨论</li>
<li>知道这些观念和其他观念之间的联系</li>
</ul>
<p>首先我们需要思考我们所说的<strong>观念到底是什么东西</strong>，在日常语境中，观念的定义有两种</p>
<ul>
<li><p>主观的，只有自己能体会到的，比如说某人正在经历的疼痛</p></li>
<li><p>客观的，同时存在于不同人心中的概念。</p>
<p>比如说正义，虽然我们对正义的概念可能是不同的，但我们思考的是同一对象。</p>
<blockquote>
<p>真的吗，我觉得如果概念不同，可能就不是同一个东西，这是语言上的陷阱？</p>
<p>语言是递归的，我们总能用其他的词语来解释某一个词语，最后我们真的能在某一点上达成一致吗？我很怀疑，持悲观态度</p>
</blockquote></li>
</ul>
<p>在这个程度上，我们讨论的就是类似柏拉图的观念，在我们讨论时是客观的，但脱离了人类的范畴，所谓的观念就是不存在的。</p>
<p>本书作者阿德勒曾经整理过西方的大观念，多达120个或者64个，这本书只选择了其中6个</p>
<ul>
<li><p>真善美。<strong>真</strong>占主导。我们用来做判断的观念。</p>
<p>前提：在人类社会。</p></li>
<li><p>自由平等正义。<strong>正义</strong>占主导。指导着我们如何做，如何生活</p>
<p>前提：在共同合作与互相竞争的人类社会中生存。这三个观念所代表的理想是绝大多数的人类为自己及下一代而努力实现的目标</p></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>前苏格拉底哲学家</title>
    <url>/2020/06/21/Philosophy/History/1-pre-Socrates/</url>
    <content><![CDATA[<h2 id="总">总</h2>
<p>由于那时候记录的遗失，其实我们并不能很好地去还原那个时候哲学家的思想，只能通过苏格拉底时代哲学家的评注等来了解，然而信息经过转述必然导致变化，因此准确性大大降低了</p>
<p>但是总的来说，那个时候的哲学家们更加关注于</p>
<ul>
<li>创建关于世界的一般性理论</li>
<li>都来自于希腊的外围</li>
</ul>
<h2 id="米利都学派">米利都学派</h2>
<p>这一学派的一些思想成为了西方科学传统的一部分，比如说渴望简明的解释，相信观察可以为理论提供支持。</p>
<h3 id="泰勒斯还原论">泰勒斯：还原论</h3>
<p>泰勒斯相信万物最终都能被还原成<strong>水</strong>。虽然世界在一直变化，但他相信一定有什么不变的东西，那就是水</p>
<p>虽然泰勒斯的结论在今天看来显然是错误的，但是他的命题背后的<strong>假设</strong>是我们所重视的。</p>
<p>还原论：我们所分析的对象总可以被还原成更为基本的一类事物。</p>
<h3 id="阿那克西曼德熵">阿那克西曼德：熵</h3>
<p>泰勒斯学生， 不同意万物都是水，因为如果这样的话就不应该有火。如果这是他的想法，那么阿那克西曼德的基本假设就是<strong>熵</strong>原理，万物都有寻求均衡状态的倾向。</p>
<h3 id="毕达哥拉斯万物皆数">毕达哥拉斯：万物皆数</h3>
<p>奇特观点：万物皆数，对实在的准确描述必须借助数学公式来表达。</p>
<p>毕达哥拉斯学派持续了近400年，影响深远，对柏拉图影响很大。</p>
<h2 id="赫拉克利特杂念">赫拉克利特：杂念</h2>
<p>虽然留下了文字片段，但是都是散文体的写作，不容易理解其中的内涵。名言</p>
<ul>
<li>战争是万物之父，也是万物之王</li>
<li>斗争即正义</li>
<li>你不能两次踏入同一条河流</li>
</ul>
<h3 id="巴门尼德无非存在">巴门尼德：无<strong>非存在</strong></h3>
<p>认为存在是理性的，只有能被思想的东西才能够存在。不存在无，只存在存在</p>
<p>存在不可毁灭，不可分割，是球形的；运动是不可能的</p>
<h3 id="芝诺">芝诺</h3>
<p>提出了许多悖论为巴门尼德的各种观点进行辩护。</p>
<p>因为如果我们相信数学的确定性，那么就会导致出现和我们感官相悖的结论，所以我们只有两种选择</p>
<ul>
<li>相信存在是不可分的（巴门尼德）（一元论）</li>
<li>放弃一元论</li>
</ul>
<h2 id="多元论者">多元论者</h2>
<p>不接受巴门尼德的存在这样一元论的静止的观点。被迫认为终极实在是由多种事物而不是一种事物构成</p>
<h3 id="恩培多克勒">恩培多克勒</h3>
<p>第一位多元论者</p>
<p>面对芝诺对运动的反驳，他提出两种能解释变化和运动的两种力：爱和恨。</p>
<blockquote>
<p>这种理论后续被弗洛伊德所接受，将其称为爱欲和死欲</p>
</blockquote>
<h3 id="阿那克萨哥拉">阿那克萨哥拉</h3>
<p>认为恩培多克勒的理论过于简单，因此提出“无限种子”的概念，和现代化学的概念非常像。</p>
<p>他认为世界上每一件事物都包含所有元素的种子，并且区分了生命和非生命</p>
<h3 id="留基波和德谟克利特">留基波和德谟克利特</h3>
<p>原子论。虚空和运动都是实在的，不能做进一步的分析。要解释的是不运动而不是运动</p>
]]></content>
  </entry>
  <entry>
    <title>雅典时期</title>
    <url>/2020/06/22/Philosophy/History/2-Athens/</url>
    <content><![CDATA[<h2 id="智者智术">智者：智术</h2>
<p>由于社会转向的问题，一些哲学家并不是真正意义上的哲学家，而是修辞学家或者说演讲者。</p>
<p>流行的思潮是怀疑主义和犬儒主义</p>
<h3 id="普罗泰戈拉">普罗泰戈拉</h3>
<p>认为成功之道是理解和运用传统习俗。他认为万事万物都是相对于人的主观性而言的。</p>
<p>名言：“人是尺度”</p>
<h3 id="卡里克勒斯和克里提亚">卡里克勒斯和克里提亚</h3>
<p>传统的道德不过是弱势大众束缚强势个体的一种聪明手段。证明：权力是好的，因为权力有助于生存，而生存是好的，因为它能让我们快乐（动物性的快乐）。</p>
<h2 id="苏格拉底">苏格拉底</h2>
<p>苏格拉底不认同智者们的观点，但还是受到影响，开始专注于人类本身的事务。</p>
<ul>
<li><p>想要把所有的论证都建立在客观有效的定义上，因此对“人”、“意义”等事件的定义就很重要</p></li>
<li><p>他的讨论向两个方向推进</p>
<ul>
<li>向外：客观定义</li>
<li>向内：探索人格（灵魂）</li>
</ul>
<p>苏格拉底对自己的问题都没能做出解答，但是提出了非常重要的追问。</p></li>
</ul>
<p>典型的苏格拉底对话：</p>
<ol type="1">
<li>提出一个问题，比如：什么是美德</li>
<li>在同伴的解答中发现瑕疵，迫使对方承认自己是无知的</li>
<li>为了追求真理，两者都达成一致：自己是无知的</li>
</ol>
<p>为了不违反法律，喝毒酒死去</p>
<h3 id="柏拉图">柏拉图</h3>
<p>柏拉图是苏格拉底的门徒，相比于苏格拉底，柏拉图更加形而上学，更加系统，更加超脱世俗</p>
<h4 id="本体论">本体论</h4>
<p>《理想国》：囚徒们更愿意相信舒适的幻象而不是令人感到痛苦的真相</p>
<p>线段比喻：认识、存在等这些对象的等级制本性：</p>
<figure>
<img src="https://raw.githubusercontent.com/hujunhan/cloudimage/master/img/20200623230727.png" alt="image-20200623230727242" /><figcaption aria-hidden="true">image-20200623230727242</figcaption>
</figure>
<ul>
<li>最低层次的是影像、想象。相当于洞穴中的囚徒们观看影子</li>
<li>下一层次是信念，有具体的事物作为其对象。比如马或者某个行为。这一层级任然不包含知识，只是意见。</li>
<li>为了让意见变成知识，就需要将对象提升到<strong>理论</strong>的层次，比如说<em>怎么样的算是马？可驯养的四足动物，拥有坚硬的蹄子和32对染色体</em>
<ul>
<li>一般来看，理论是实际经验的一般化，来自下一层级（Particular Objects）</li>
<li>但是柏拉图认为理论是理念的投影，是上一层级（The Forms）的投影</li>
<li>当人开始关注Forms时，他其实就是在用Pure Reason，纯粹理性在思考了</li>
</ul></li>
<li>柏拉图认为，可感世界和对可感世界的意识依赖于<strong>太阳</strong>，理念和理念的知识依赖于<strong>善</strong>的理念
<ul>
<li>对于<strong>善</strong>的争议颇多，一般认为所起的作用就像上帝在神学体系中一样。</li>
</ul></li>
</ul>
<h4 id="认识论">认识论</h4>
<p>我们要如何认识真理？</p>
<p>柏拉图认为人天生知道所有的真理，真理来自内部——灵魂。<strong>一切知识都是回忆</strong>。</p>
<p>所以柏拉图创立了<strong>学园</strong>，来帮助学生回忆知识</p>
<p>这种观点的一个现代形式是弗洛伊德的<strong>无意识记忆理论</strong></p>
<h4 id="社会哲学">社会哲学</h4>
<p>人的灵魂拥有三个方面的品德。城邦也与其类似，形成了独特的阶级</p>
<ul>
<li>理性，代表智慧。在城邦中是统治者，知道什么是善，训练军事阶层来帮助天性难以自控的劳动者。过禁欲、共产的生活</li>
<li>血气，代表勇敢。在城邦中是军事阶层，帮助天性难以自控的劳动者。过禁欲、共产的生活</li>
<li>欲望，代表节制。在城邦中是劳动者，可以拥有金钱财产</li>
</ul>
<p>城邦的作用是使公民的<strong>幸福最大化</strong></p>
<h4 id="艺术">艺术</h4>
<p>在理想国中，成员可以演唱爱国的、振奋人心的歌曲，但是大部分艺术家却被驱逐，因为</p>
<ul>
<li>从本体论角度：艺术与影像打交道，是对模仿的模仿，在最底层</li>
<li>从认识论角度：艺术处于想象的阶段，一无所知却声称有所知</li>
<li>从美学角度：艺术通过影像来表现自身，但是美是纯粹理性的，因此艺术不利于我们追寻美</li>
<li>从道德角度：艺术要么是色情要么是暴力，或者兼而有之。是对无政府状态的一种煽动</li>
</ul>
<h3 id="亚里士多德">亚里士多德</h3>
<h4 id="认识论-1">认识论</h4>
<p>柏拉图最优秀的学生。相比于柏拉图来说亚里士多德更加实际。</p>
<p>两者分歧的根本点在于</p>
<ul>
<li>柏拉图认为存在两个世界，理念世界和事物世界。二元论</li>
<li>亚里士多德认为只有一个世界。多元论</li>
</ul>
<p>亚里士多德认为事物的本质和实体是统一的，并不割裂。但是在纯粹理性的活动中将本质抽象出来是可能的。对本质的抽象主要是靠目的，根据<strong>目的</strong>的不同来区分不同事物。</p>
<blockquote>
<p>有些事物在定义时很难用目的来定义</p>
</blockquote>
<p>事物的运动变化在亚里士多德的世界观中就是事物向着“<strong>第一推动者</strong>”前进的过程</p>
<ul>
<li>第一推动者是宇宙万物的原因，就像是宗教中的上帝</li>
</ul>
<h4 id="社会哲学-1">社会哲学</h4>
<p>反映到生活中，亚里士多德认为人类生命的终极目的是追求一种“终极的善”，否则人生就是一串无意义目的的追求，浪费生命（吃喝拉撒工作睡循环）</p>
<blockquote>
<p>运用排除法做出了选择，真的没有其他选择了吗？</p>
</blockquote>
<p>伦理和政治的目标都是幸福</p>
<p>为了追求终极的善，我们需要对此有一个明确的定义。在他的世界观中，人类也是有目的，或者说功用的。根据他的论证，这个功用是</p>
<ul>
<li><p>合乎<strong>德性</strong>的灵魂的活动。</p>
<ul>
<li><p>理智德性：通过遗传和教育的结合而获得</p>
<p>与纯粹理性有关的哲学智慧，是科学性、无私利和沉思性的。</p></li>
<li><p>道德德性：通过后天养成的各种习惯获得。不要过度，也不要不足</p>
<ul>
<li>通过实践获得</li>
<li>无法精确地做出判断，因此要不断试错</li>
</ul></li>
</ul>
<p>在这种前提下，人类就是通过沉思才能获得幸福，但也不是僧侣式的生活，而是存在社会活动的</p></li>
</ul>
<h4 id="艺术-1">艺术</h4>
<p>亚里士多德认同柏拉图的“艺术是模仿”</p>
<p>但是他认为艺术再现了更高一级的真理，因此艺术是有益处的</p>
<h4 id="逻辑学">逻辑学</h4>
<p>亚里士多德发展了逻辑学，并且在很长一段时间内保持着正确。</p>
]]></content>
  </entry>
  <entry>
    <title>希腊化时期和罗马时期</title>
    <url>/2020/06/24/Philosophy/History/3-Greece-Roma/</url>
    <content><![CDATA[<p>这个时期的哲学家不够深刻、复杂、敏锐。是一个哲学衰退的时期</p>
<p>大部分哲学家主要关心苏格拉底的问题：我们应该如何生活</p>
<h2 id="伊比鸠鲁派">伊比鸠鲁派</h2>
<p>认为生活的目标是幸福==快乐。对快乐可以进行分类</p>
<ul>
<li>自然的欲望
<ul>
<li>必须的：饮食、睡眠、安宁</li>
<li>不必须的：性欲</li>
</ul></li>
<li>无意义的欲望：虚荣</li>
</ul>
<p>他认为人应该尽量减少不必要的欲望，满足必须的欲望，将时间留给安宁。</p>
<h2 id="斯多葛主义廊下派">斯多葛主义（廊下派）</h2>
<p>由芝诺创立。对自然科学不感兴趣，更多地关心人类行为问题。</p>
<p>如何让人生幸福？以合乎实在的神圣安排来生活。应该把欲望放在我们所得到的东西上。</p>
<p>但是如果在这种情况下还是会有残酷的现实损害人心中的平衡，那么斯多葛派提倡自杀。</p>
<h2 id="怀疑主义">怀疑主义</h2>
<p>鼻祖：高尔吉亚</p>
<ul>
<li>无物存在</li>
<li>即使有物存在，我们也无法认识它</li>
<li>即使我们能认识它，我们也不能传达</li>
</ul>
<p>激进的怀疑主义者怀疑几乎所有宣称有知识的论断</p>
]]></content>
  </entry>
  <entry>
    <title>中世纪和文艺复兴时期哲学</title>
    <url>/2020/06/24/Philosophy/History/4-Middle-Age-Renaissance/</url>
    <content><![CDATA[<p>地中海周围的沙漠地区诞生了西方世界的三大宗教</p>
<p>最早出现的是犹太教，后来其中一些小团体分离出来建立了基督教并向更多的希腊语、拉丁语地区传播。</p>
<p>在罗马帝国时期得到了广泛传播，并被罗马皇帝<strong>君士坦丁</strong>设为帝国的官方信仰</p>
<p>这一段时间的哲学被宗教所支配</p>
<h1 id="中世纪">中世纪</h1>
<h2 id="圣奥古斯丁">圣奥古斯丁</h2>
<p>一开始耽于肉欲，于是信仰摩尼教，把自己违反道德的罪行归因于<strong>外在于自身</strong>的原因</p>
<p>但是这种思想不够深刻。在经过一次神秘体验之后，奥古斯丁皈依了基督教</p>
<p>他的思想中有很大一部分关注于人类的自由</p>
<ul>
<li>如果上帝是全知的，那么人就没有自由，人就不需要对自己的行为负责</li>
</ul>
<p>这样会得出奇怪的结论：要么上帝是全知却不道德的，要么上帝是仁慈却无知的。</p>
<h2 id="圣安瑟尔谟">圣安瑟尔谟</h2>
<p>通过<strong>本体论证明</strong>的方式来证明上帝存在</p>
<p>通过完全的思辨进行了证明：在心中想象一个最完满的存在，如果这个存在仅仅存在于心中，那么它就不是最完满的，因为存在心中和存在与心外的更加完满</p>
<h2 id="伊斯兰教">伊斯兰教</h2>
<p>伊斯兰教关键人物：默罕默德，将天使的启示记录下来，成为了《古兰经》。<strong>伊斯兰和穆斯林</strong>这两个词都出自于服从、屈服的那个阿拉伯语。</p>
<p>伊斯兰有极大的吸引力因为它在神学上非常简单，可以满足混乱时期的人类的精神和物质需求。</p>
<h2 id="阿威罗伊和麦蒙尼德">阿威罗伊和麦蒙尼德</h2>
<p>通过给亚里士多德的著作进行翻译、注释，在宗教和哲学之间进行交互，要么否定亚里士多德或者让两者可以互相解释。</p>
<h2 id="奥卡姆的威廉">奥卡姆的威廉</h2>
<p>奥卡姆是英格兰的一个小镇，<strong>奥卡姆的威廉</strong>在牛津大学学习神学，他的哲学是赤裸裸的经验主义。</p>
<p>他认为所有知识都直接来源于对具体事物和事件的感觉、观察。因而不存在所谓的形而上学（超越于物理事物的知识）</p>
<h1 id="文艺复兴时期">文艺复兴时期</h1>
<p>1450-1600</p>
<p>文艺复兴时期的艺术家、科学家、政治家更加出名。但还是有一些哲学进展值得了解</p>
<h2 id="人文主义">人文主义</h2>
<p>兴趣在于研究人性。</p>
<ul>
<li>更关注道德哲学而非形而上学</li>
<li>反对经院哲学的枯燥迂腐</li>
</ul>
<h2 id="柏拉图-vs.-亚里士多德">柏拉图 vs. 亚里士多德</h2>
<p>文艺复兴时期的哲学家大豆相信基督教，他们会讨论柏拉图和亚里士多德哪一位的哲学体系可以更好地为基督教教义辩护</p>
]]></content>
  </entry>
  <entry>
    <title>大陆理性主义和英国经验主义</title>
    <url>/2020/06/24/Philosophy/History/5-Rationalism-Empiricism/</url>
    <content><![CDATA[<h1 id="理性主义">理性主义</h1>
<h2 id="笛卡尔">笛卡尔</h2>
<p>法国人笛卡尔为了构建自己的客观知识体系，他需要一个<strong>绝对确定</strong>的牢固基础。</p>
<p>寻找的方式是“<strong>怀疑一切</strong>”笛卡尔将一切可能被怀疑的东西通过怀疑排除，直到找到一种在逻辑上不容置疑的命题。这样的命题就是一切知识的绝对确定的基础</p>
<ol type="1">
<li><p>一开始，笛卡尔通过这种方式发现我们全部信息的来源都是<strong>我们的感官</strong></p></li>
<li><p>然而我们的感官并不是完全可信的，因此笛卡尔发现他的怀疑方法走得太远了</p></li>
<li><p>笛卡尔意识到我们需要将一些基础的<strong>常识判断</strong>作为我们知识的合法基础</p>
<p>笛卡尔发现我们无法确定自己是否在梦中，甚至是数学，也可能是由一个“邪恶天才”操纵我们所得出的。但是思考本身说明了什么</p></li>
<li><p>最终，笛卡尔得到了“我思故我在”</p></li>
</ol>
<p>笛卡尔相信上帝存在，证明过程可以简单归纳为以下四步</p>
<ol type="1">
<li>完满的存在应该知道所有，我有所怀疑，所以我不完满</li>
<li>除非我理解完满，否则我不知道自己是不完满的</li>
<li>完满的观念只能通过完满的东西才能在心中产生</li>
<li>因此，一个完满的存在是存在的</li>
</ol>
<p>一些问题：</p>
<ul>
<li><p>将可以知觉到的属性（颜色、味道等）归之于人的心里，而只留给外部世界数学上可衡量的量</p>
<blockquote>
<p>我自己一直也是这样想的</p>
</blockquote></li>
<li><p>心灵和现实世界是完全分开的，极端二元论体系。二者之间如何发生作用？</p></li>
</ul>
<h2 id="斯宾诺莎">斯宾诺莎</h2>
<p>荷兰人斯宾诺莎沿着笛卡尔所展开的理性主义传统来解决遗留困境。理性主义者认为：知识来源于理性，而不是感觉。</p>
<p>斯宾诺莎一直在实践自己的哲学。</p>
<p>如何解决笛卡尔的极端二元论？斯宾诺莎推断只存在一个实体（避免了二元论），而将原来笛卡尔所认为的两个实体作为斯宾诺莎的实体的属性之二。</p>
<p>无论对于上帝还是人类来说，都不存在自由意志。欲望和激情都是负面情绪，之所以对人影响很大是因为我们没有把握实在的理性结构。有了知识，这些情感可以被转化为清楚明白的概念</p>
<h2 id="莱布尼茨">莱布尼茨</h2>
<p>德国人莱布尼茨想要回到笛卡尔体系的同时纠正笛卡尔的错误。他的哲学体系主要可以阐述为三条原理</p>
<ul>
<li><p>同一律</p>
<p>所有（真）命题都可以分为两类：分析的（按照定义为真、必然的、先天的）和综合的（与分析相对的）</p>
<p><strong>莱布尼茨认为所有综合句实际上都是分析的</strong></p></li>
<li><p>充足理由律</p>
<p>莱布尼茨认为对所有存在的事物来说，都有它为何存在以及为何恰好如此存在的理由。</p>
<p>一切存在的理由：一个其存在本身是必然的全然完满的上帝。</p></li>
<li><p>预定和谐律</p>
<p>这个世界是上帝经过一系列考虑之后最完满的存在。虽然某些方面看可能是不好的，但如果从全局来看，是全局的最优解</p></li>
</ul>
<h2 id="霍布斯">霍布斯</h2>
<p>英国的霍布斯是坚定的唯物主义者，他认为现实中唯一的存在物就是运动中的物体，所谓的思维也只是大脑活动的“影像”，只是单纯的附带现象。</p>
<p>霍布斯的心理学也是比较悲观的，他认为人类所有的行为都是利己的，所谓的利他是不存在的。</p>
<p>利维坦的政治哲学：他认为国家是一个人造的怪兽（利维坦）。前提：自然资源是不足的。因为在无政府状态下，没有道德、好坏、正确错误的观念，每个人天赋的权利只有“生命”。大家都无法互相信任并进行合作共赢，因此虽然国家会滥用权力，但任是一个比无政府状态更好的选择。</p>
<h1 id="经验主义">经验主义</h1>
<h2 id="洛克">洛克</h2>
<p>英国古典经验主义第一人。他认为心灵是一张白纸，所有的观念都是从经验中来的</p>
<p>知识论：区分了第一性的质和第二性的质。他的认识论成为了实体形而上学终结的开端。</p>
<p>洛克的政治哲学：前提：自然资源是充足的。每个人天赋的（自然）权利有“生命、健康、自由和财产”，一个好的政府就是对这些权利给予保障并使之最大化的政权。</p>
<blockquote>
<p>美国很好地实践了洛克的哲学，可以看成是一个伟大的洛克主义实验。</p>
</blockquote>
<h2 id="休谟">休谟</h2>
<p>休谟的哲学承接着莱布尼茨的分析命题、综合命题论。然而如果接受这种区分，那么就要承认存在<strong>先天必然为真的事物</strong>，这有悖于经验主义的纲领。休谟对此的解释是：<strong>分析命题只是单纯的文字游戏，它并不能告诉我们任何关于现实的知识。因此只有综合命题才是有意义的，符合了经验主义的纲领</strong>。</p>
<p>休谟式的分析方法，来检验任何一条断言</p>
<ol type="1">
<li><p>是分析的吗：否定句是否会导致自相矛盾？</p>
<ul>
<li>是，那么这个断言是真的，但是没有价值</li>
<li>不是，继续2</li>
</ul></li>
<li><p>是综合的吗：可以追溯到经验吗？（来自于感官的感觉材料）</p>
<ul>
<li>是：Good</li>
<li>不是：这个断言是无意义的</li>
</ul></li>
</ol>
<p>通过这种分析方式，我们可以分析出</p>
<ul>
<li><p>“上帝存在”是没有意义的</p></li>
<li><p>“因果性”这个概念和“上帝”一样。无法预测未来是否还有这个规律，因此因果知识一个心理学事实而没有哲学解释</p>
<p>这个问题后来被称为“归纳问题”：因果性要求“必然联系”，然而无论是理性主义还是经验主义都无法解释或者证明“必然联系”</p></li>
</ul>
<p>休谟的经验主义带来的严重后果就是它将我们的理性压缩的如此之小：我们只能在<strong>言辞上的真理</strong>和对<strong>感觉材料的描述</strong>上能够获得理性。休谟还指出，<strong>我们的生活与理性是不一致的</strong>，我们的活动是在哲学证明之外的。</p>
<h1 id="康德">康德</h1>
<p>德国的康德一开始接受的是理性主义教育，并且一直深信不疑。直到有一天他在阅读了休谟的某本著作之后发现只有反驳休谟的怀疑论，哲学才有可能进步。</p>
<p>是对理性主义和经验主义的一种综合</p>
<h2 id="知识论">知识论</h2>
<p>休谟认为，</p>
<ul>
<li>所有分析命题都是先天的，<strong>所有的先天命题都是分析的</strong></li>
<li><strong>所有综合命题都是后天的</strong>，所有的后天命题都是综合的</li>
</ul>
<p>康德不同意休谟观点中加粗的部分。也就是说康德认为<strong>无需依赖观察即可认识其真理性</strong> AKA <strong>先天综合真理</strong></p>
<p>证明方式：表明休谟说的知识实际上是以<strong>先天综合真</strong>理为基础的。</p>
<h2 id="本体论">本体论</h2>
<p>康德的解决方案给我们留下了两个世界</p>
<ul>
<li>现象世界：人类心灵认识的世界</li>
<li>本体世界：人类心灵无法洞悉的世界</li>
</ul>
<h2 id="行为准则">行为准则</h2>
<p>康德称之为：绝对命令。总是按照这样的准则行动，你可以同时意愿他成为普遍的法则。</p>
<blockquote>
<p>这也可以称之为道德了吧，对大家都好的行为。</p>
</blockquote>
<p>但是这会导致道德极端主义，比如即便为了拯救一个人的性命也不能撒谎时</p>
]]></content>
  </entry>
  <entry>
    <title>康德之后的英国和大陆哲学</title>
    <url>/2020/06/26/Philosophy/History/6-After-Kant/</url>
    <content><![CDATA[<blockquote>
<p>在阅读到这一章的时候，我已经有点烦躁了，我逐渐无法忍受那时候哲学家们对与语言的运用，各种新创造的词汇却没有精确的定义，对我来说仿佛就是一段段的文字游戏，无法理解。</p>
</blockquote>
<h2 id="黑格尔">黑格尔</h2>
<p>将理性等同于神。</p>
<p>黑格尔是绝对的唯心主义：世界历史是理念的历史</p>
<p>辩证法</p>
<h2 id="叔本华">叔本华</h2>
<p>目标：回到康德</p>
<p>两个世界</p>
<ul>
<li>作为表象的世界：我们不能直接认识终极实在；</li>
<li>作为意志的世界：表象世界中的线索表明<strong>终极实在</strong>是非理性力量</li>
</ul>
<p>人类文明只不过是意志的升华</p>
<h2 id="克尔凯郭尔">克尔凯郭尔</h2>
<p>目标：通过描绘严酷的严苛场景来攻击他那个时代索然无味的基督教徒</p>
<h2 id="马克思">马克思</h2>
<p>目标：不要对世界进行哲学解释，而是要改造他</p>
<p>继承黑格尔的学说，将辩证唯心主义改造成辩证唯物主义。</p>
<p>将社会分析为基础和上层建筑</p>
<ul>
<li>控制了基础就控制了社会</li>
<li>上层建筑是由“意识形态“所发动的</li>
</ul>
<h2 id="尼采">尼采</h2>
<p>目标：教导一种全新的主体性形式，这种主体性会破坏以前的所有思想和语言形式</p>
<p>权力意志：一切活动都是权力意志，无论是身体活动还是语言活动</p>
<p>上帝之死：新人类解除了所有传统的权威形式的束缚，因而解除了所有形式的心理和情感暴政的束缚</p>
<h2 id="功利主义">功利主义</h2>
<p>目标：把伦理学建立在一个稳固的、客观的经验基础之上</p>
<p>边沁：最大多数人的最大幸福、一人一票</p>
<p>密尔：将边沁功利主义做的更加周密，不同的快乐质量是不一样的</p>
]]></content>
  </entry>
  <entry>
    <title>现象学传统及其余续</title>
    <url>/2020/06/26/Philosophy/History/7-phenomenolog/</url>
    <content><![CDATA[<h2 id="现象学">现象学</h2>
<p>胡塞尔</p>
<p>假设：关于世界的一切知识都是以意识为基础的</p>
<p>要求：对意识及其所面对的世界进行研究。</p>
<p>方式：通过清除一切预设来进行意识研究</p>
<h2 id="存在主义现象学">存在主义现象学</h2>
<h3 id="海德格尔">海德格尔</h3>
<p>认为<strong>存在</strong>被语言学和形而上学所遮蔽了</p>
<p>呼吁回到前苏格拉底的精神</p>
<h3 id="萨特">萨特</h3>
<h2 id="结构主义">结构主义</h2>
<p>语言学：索绪尔：语言是一个符号系统，符号是能指和所指的结合</p>
<p>人类学：斯特劳斯：人类思维的普遍性在社会制度的总体结构中明显显示出来</p>
<ul>
<li>一切人类思维都是有逻辑的</li>
<li>各个时期的社会在某些方面还是存在共性的</li>
</ul>
<h2 id="后结构主义">后结构主义</h2>
<p>何为<strong>后</strong>？对某些结构主义主体的极端化和尖锐化</p>
<p>拉康：通过语言学而不是生物学为精神分析进行辩护</p>
<ul>
<li>潜意识和语言一样是有结构的</li>
<li>欲望是转喻</li>
</ul>
<p>德里达：解构，讥讽传统哲学为逻各斯中心主义</p>
]]></content>
  </entry>
  <entry>
    <title>哲学史之总览</title>
    <url>/2020/06/21/Philosophy/History/overview/</url>
    <content><![CDATA[<h2 id="why">Why</h2>
<p>在看这本书之前我已经看过了许多哲学书，但当我回顾起来，总觉得缺少一种宏观的思维路径，各个学说是如何发展起来并和其他理论联系在一起的。我希望像学习一本数学书或者工科的书一样以公理化的方式来重新构思我脑中的哲学。</p>
<p>这本书是一位哲学教授Donald Palmer的教材，这位仁兄有着丰富的教学经验，善于利用欢乐的方式教授哲学。在受够了其他哲学书繁杂难懂的文本之后，我选择这本书来进行学习。</p>
<p>这本书介绍了从公元前6世纪到21世纪早期的<strong>西方哲学</strong>，并用图文并茂的方式来阐述各个思想。</p>
<h2 id="目录">目录</h2>
<p>这次阅读的版本是第六版，较之前几版有了一些变化</p>
<p>全书一共分为8章，分别是</p>
<ol type="1">
<li>前苏格拉底哲学家</li>
<li>雅典时期</li>
<li>希腊化时期和罗马时期</li>
<li>中世纪和文艺复兴时期的哲学</li>
<li>大陆理性主义和英国经验主义</li>
<li>康德之后的英国和大陆哲学</li>
<li>现象学传统及其余续</li>
<li>实用主义及分析传统</li>
</ol>
<p>从目录看起来，分割的原则不是很明确，有的时候是根据时间，有的是根据人物，还有根据地点的。不过各章的小标题基本都是哲学家的名字，大概就是根据不同哲学家的思想及贡献进行了分类。</p>
<h2 id="导言">导言</h2>
<p>希腊是西方哲学的起源。现在各个学科英文单词后缀的<em>logy</em>都是从希腊语单词的logos中来的，logos表示理论、研究或者对某事物的理性解释，表示着一种特定的思考方式，或者说逻辑分析。一旦成为学科，就是利用纯粹的思想的力量来解释他们</p>
<blockquote>
<p>方法论？不同的学科其实代表着不同的方法论，用不同的方式来看待这个世界</p>
</blockquote>
<h3 id="哲学之前">哲学之前</h3>
<p>在有哲学之前，人类通过其他的方式来理解世界：神话。将所有的事情、事物解释追溯到神话中的行为。</p>
<p>这些神话故事提供了2种不同的作用</p>
<ul>
<li>解释世界万物</li>
<li>为人类的行为提供了一些规范。如果大家都遵守的话</li>
</ul>
<p>为什么最早的哲学出现在希腊？没有明确的理论，但还是有一些可能的解释，比如说：希腊民族是善于游历的民族，在游历过程中希腊人借鉴了不同文明的思想、文明和艺术形式。</p>
<p>希腊人的悲观主义：对万物的短暂本性的敏感；希腊人的乐观主义：要求一种<strong>非宗教</strong>的解释，通过<strong>纯粹的人类理性力量</strong>所获得正确的解释。</p>
<blockquote>
<p>想起了李白诗词，东方哲学的产生有着怎么样的背景呢</p>
</blockquote>
<h3 id="哲学与科学">哲学与科学</h3>
<p>西方哲学与西方科学似乎有着相同的起源，虽然在那个时候可能还没有明确的区分，大致来说，</p>
<ul>
<li>科学处理的问题可以通过<strong>实验</strong>的方式解决</li>
<li>哲学要处理的问题更加注重<strong>思辨</strong></li>
</ul>
<p>哲学的追问从很早就已经开始了，但是并没有提供明确的答案。就算是今天也没有哲学家声称理论得到了绝对的确定性。更多的实际上是表达一种希望，希望理论比先前的理论更<strong>好</strong>，更接近真理。</p>
]]></content>
  </entry>
  <entry>
    <title>扩展卡尔曼滤波</title>
    <url>/2020/07/17/Robotics/Localization/EKF/</url>
    <content><![CDATA[<h2 id="why">Why</h2>
<p>因为卡尔曼滤波有两个重要假设，其中的<strong>线性假设</strong>在现实环境中是不能够满足的。</p>
<p>大部分现实环境中的问题都包含非线性函数。如果还是使用卡尔曼滤波，那么更新状态之后就不再是高斯分布了。也就不满足卡尔曼滤波的条件了</p>
<h2 id="how">How</h2>
<p>通过泰勒展开，在均值附近线性近似。保留一阶</p>
<h2 id="example传感器融合">Example：传感器融合</h2>
<p>自动驾驶同时使用激光雷达和雷达两种传感器，其中</p>
<ul>
<li>激光雷达：给出px，py两个</li>
<li>雷达：距离、转向、转向速度</li>
</ul>
<figure>
<img src="https://miro.medium.com/max/541/1*EEuBSPnR-JykUz-5patCGg.png" alt="Image for post" /><figcaption aria-hidden="true">Image for post</figcaption>
</figure>
<p>回忆卡尔曼滤波的两个步骤</p>
<ol type="1">
<li><p>预测部分。和普通的卡尔曼滤波是完全一样的，因为这里并不涉及到观测 <span class="math display">\[
\bar x=Fx+Bu\\
\bar P=FPF^T+Q
\]</span> 其中x是状态，P也是状态是方差（也可以理解成<strong>误差</strong>），F是状态转移矩阵，Q是过程协方差，也可以理解为在行动过程中引入的<strong>噪声</strong>，B是输入矩阵，u是系统的控制输入</p></li>
<li><p>矫正部分。利用传感器观测到并使用贝叶斯估计计算新的状态</p>
<ol type="1">
<li><p>$ y=z-H(x)$，因为我们想要的状态是在笛卡尔坐标系下的，但是观测的却是有极坐标的，因此H做了个转换 <span class="math display">\[
h\left(x^{\prime}\right)=\left(\begin{array}{c}
\rho \\
\phi \\
\dot{\rho}
\end{array}\right)=\left(\begin{array}{c}
\sqrt{p_{x}^{\prime 2}+p_{y}^{\prime 2}} \\
\arctan \left(p_{y}^{\prime} / p_{x}^{\prime}\right) \\
\frac{p_{x}^{\prime} v_{x}^{\prime}+p_{y}^{\prime} v_{y}^{\prime}}{\sqrt{p^{\prime} 2+p^{\prime 2}}}
\end{array}\right)
\]</span></p></li>
<li><p><span class="math inline">\(K=\bar P H{_j}^T(H_j\bar P H_j{^T}+R)^{-1}\)</span></p>
<p>其中<span class="math inline">\(H_j\)</span>是一阶雅可比矩阵 <span class="math display">\[
H_{j}=\left[\begin{array}{llll}
\frac{\partial \rho}{\partial p_{x}} &amp; \frac{\partial \rho}{\partial p_{y}} &amp; \frac{\partial \rho}{\partial v_{x}} &amp; \frac{\partial \rho}{\partial v_{y}} \\
\frac{\partial \varphi}{\partial p_{x}} &amp; \frac{\partial \varphi}{\partial p_{y}} &amp; \frac{\partial \varphi}{\partial v_{x}} &amp; \frac{\partial \varphi}{\partial v_{y}} \\
\frac{\partial \dot{p}}{\partial p_{x}} &amp; \frac{\partial \dot{\rho}}{\partial p_{y}} &amp; \frac{\partial \dot{\rho}}{\partial v_{x}} &amp; \frac{\partial \dot{\rho}}{\partial v_{y}}
\end{array}\right]
\]</span></p></li>
</ol></li>
</ol>
<p>所以说重点就是在矫正部分使用雅可比矩阵代替普通的H</p>
<h2 id="ref">Ref</h2>
<p>https://towardsdatascience.com/extended-kalman-filter-43e52b16757d</p>
]]></content>
      <tags>
        <tag>robotics</tag>
      </tags>
  </entry>
  <entry>
    <title>卡尔曼滤波</title>
    <url>/2020/07/17/Robotics/Localization/Kalmanfilter/</url>
    <content><![CDATA[<h2 id="why">Why</h2>
<p>为什么用概率来描述？因为机器人的环境是不确定的，所使用的传感器也是有误差的</p>
<ul>
<li>某个随机变量的期望：<span class="math inline">\(E [X]=\sum_{i=1}^{n} p_{i} x_{i}\)</span></li>
<li>为什么只使用单峰模型？因为机器人在某一时间的位置是固定的，并不会出现在不同位置</li>
</ul>
<h2 id="高斯">高斯</h2>
<p>中心极限定理：样本数够多，就会出现正态分布</p>
<p>使用单峰分布处理起来非常困难。</p>
<p>状态的更新（两个正态分布的相乘）可以用贝叶斯来计算 <span class="math display">\[
\begin{array}{c}
\mu_{\text {new }}=\frac{\mu_{1} \sigma_{2}^{2}+\mu_{2} \sigma_{1}^{2}}{\sigma_{1}^{2}+\sigma_{2}^{2}} \\
\sigma_{\text {new }}=\frac{\sigma_{1}^{2} \sigma_{2}^{2}}{\sigma_{1}^{2}+\sigma_{2}^{2}}
\end{array}
\]</span> 有的时候状态更新只是两个正态分布的相加，那么新的期望和方差就是两个期望和方差的简单相加</p>
<h2 id="概率生成定理">概率生成定理</h2>
<p><span class="math inline">\(z\)</span>表示测量，<span class="math inline">\(u\)</span>表示指令，<span class="math inline">\(x\)</span>表示状态</p>
<p>第一定理：<span class="math inline">\(p\left(x_{t} \mid x_{0: t-1}, z_{1: t-1}, u_{1: t}\right)=p\left(x_{t} \mid x_{t-1}, u_{t}\right)\)</span></p>
<ul>
<li>也就是说，当前状态只和<strong>上一时刻状态</strong>以及<strong>此刻的指令</strong>有关</li>
</ul>
<p>第二定理：<span class="math inline">\(p\left(z_{t} \mid x_{0: t}, z_{1: t-1}, u_{1: t}\right)=p\left(z_{t} \mid x_{t}\right)\)</span></p>
<ul>
<li>如果<span class="math inline">\(x_t\)</span>是完整的，那么当前的测量概率只和<strong>当前的状态</strong>有关</li>
</ul>
<h2 id="贝叶斯法则">贝叶斯法则</h2>
<p><span class="math display">\[
后验概率=\frac{可能性*先验概率}{边界概率}=\frac{观测*上一时刻概率}{1}
\]</span></p>
<p>利用贝叶斯法则估算状态：</p>
<ol type="1">
<li>预测步骤：计算先验概率，不考虑观测，只考虑指令会带来的变化：利用模型
<ul>
<li>这一步会引入误差，包括传感器、执行器上的</li>
</ul></li>
<li>矫正步骤：利用上一步计算出的先验概率，加上观测，计算后验概率（贝叶斯法则）</li>
</ol>
<h2 id="卡尔曼滤波">卡尔曼滤波</h2>
<p>两个重要假设：</p>
<ul>
<li>线性</li>
<li>高斯</li>
</ul>
<p>主体框架和贝叶斯估计是一样的，最大的区别是数学表达：</p>
<ul>
<li>卡尔曼滤波使用了高斯概率</li>
</ul>
<p>也就是说在卡尔曼滤波中，无论是先验还是后验抑或是置信，都是一个高斯分布 <span class="math display">\[
\mu_{\text {new }}=\frac{\mu_{1} \sigma_{2}^{2}+\mu_{2} \sigma_{1}^{2}}{\sigma_{1}^{2}+\sigma_{2}^{2}}
\]</span> 回想我们之前是如何计算新的期望的，显然可以拆成两个 <span class="math display">\[
\mu=W_1\mu_1+W_2\mu_2
\]</span> 我们是根据两个的权重线性叠加的。且<span class="math inline">\(W_1+W_2=1\)</span>，因此我们引入新的变量<span class="math inline">\(K\)</span>——<strong>卡尔曼增益</strong></p>
<p>卡尔曼增益在卡尔曼滤波中起着重要的作用。令<span class="math inline">\(K=W_1\)</span></p>
<p>则有： <span class="math display">\[
\begin{aligned}
\mu &amp;=K \mu_{z}+(1-K) \bar{\mu} \\
&amp;=\bar{\mu}+K\left(\mu_{z}-\bar{\mu}\right)
\end{aligned}
\]</span> 和 <span class="math display">\[
\sigma^2=K\sigma_{z}^{2}
\]</span></p>
<h2 id="卡尔曼滤波框架">卡尔曼滤波框架</h2>
<ol type="1">
<li><p>预测部分。执行器模型一般是线性的，在目前的状态下直接相加一些变量，期望和方差都是相加 <span class="math display">\[
\bar x=Fx+Bu\\
\bar P=FPF^T+Q
\]</span> 其中x是状态，P也是状态是方差（也可以理解成<strong>误差</strong>），F是状态转移矩阵，Q是过程协方差，也可以理解为在行动过程中引入的<strong>噪声</strong>，B是输入矩阵，u是系统的控制输入</p></li>
<li><p>矫正部分。利用传感器观测到并使用贝叶斯估计计算新的状态 <span class="math display">\[
y=z-H\bar z\\
K=\bar P H^T(H\bar P H^T+R)^{-1}\\
x=\bar x+Ky\\
P=(I-KH)\bar P
\]</span> 其中y是误差，K是卡尔曼增益，x和P是新的状态</p></li>
</ol>
<h2 id="卡尔曼增益">卡尔曼增益</h2>
<p>卡尔曼增益的更新 <span class="math display">\[
K=\bar P H^T(H\bar P H^T+R)^{-1}
\]</span></p>
<ul>
<li>R是测量噪声，由传感器的制造商给出</li>
<li><span class="math inline">\((H\bar P H^T+R)\)</span>总的噪声，是预测噪声+测量噪声</li>
<li>为什么K如此复杂？因为矩阵的除法是没有定义的，因此计算总的噪声再取逆</li>
</ul>
]]></content>
      <tags>
        <tag>robotics</tag>
      </tags>
  </entry>
  <entry>
    <title>无迹卡尔曼滤波</title>
    <url>/2020/07/18/Robotics/Localization/UKF/</url>
    <content><![CDATA[<h2 id="why">Why</h2>
<p>既然扩展卡尔曼滤波可以解决非线性问题，为什么还要提出无迹卡尔曼滤波呢？</p>
<p><strong>性能</strong>：在扩展卡尔曼滤波中，我们只使用了<strong>一个点</strong>展开来线性化，这就导致了这种估计方法的效果不佳</p>
<p><strong>更好的方法</strong>：用许多点来近似</p>
<p><strong>Trade-Off</strong>： 如果使用所有的点来近似，那就又会要求太多的计算资源，因此我们只用少量的计算资源获取大大提高的精度</p>
<h2 id="how">How</h2>
<p>选择Sigma Points：用少数几个点来表示整个分布，用的点越多，近似就越精确</p>
<p>高斯分布在经过一个非线性变换之后就不再是高斯分布了，所以在这里引入一个Unscented Transform来完成这个变换任务</p>
<ol type="1">
<li><p>计算一个Sigma Point的集合</p>
<p>通常来说，如果系统是N维的，那么Sigma Point的个数选择<span class="math inline">\(2N+1\)</span> <span class="math display">\[
\begin{aligned}
X ^{[0]} &amp;=\mu \\
X ^{[i]} &amp;=\mu+(\sqrt{(n+\lambda) \Sigma})_{i} \text { for } i=1, \ldots, n \\
X ^{[i]} &amp;=\mu-(\sqrt{(n+\lambda) \Sigma})_{i-n} \quad \text { for } i=n+1, \ldots, 2 n
\end{aligned}
\]</span> 其中<span class="math inline">\(\Sigma\)</span>是协方差矩阵，<span class="math inline">\(\lambda\)</span>是一个扩张系数（一般选择<span class="math inline">\(3-n\)</span>），<span class="math inline">\(X\)</span>是Sigma Point矩阵，每一行都是Sigma Point的集合。</p>
<p>如果系统是2维的，那么<span class="math inline">\(X\)</span>就是<span class="math inline">\(2\times5\)</span>的大小</p></li>
<li><p>给每个Sigma Point赋予不同的权重 <span class="math display">\[
\begin{aligned}
w^{[0]} &amp;=\frac{\lambda}{n+\lambda} \\
w^{[i]} &amp;=\frac{1}{2(n+\lambda)} \quad \text { for } i=1, \ldots, 2 n
\end{aligned}
\]</span></p></li>
<li><p>将这些点做一个非线性变换<span class="math inline">\(g(x)\)</span></p></li>
<li><p>变换后的点计算高斯</p></li>
<li><p>计算新分布的均值和方差 <span class="math display">\[
\begin{aligned}
\mu^{\prime} &amp;=\sum_{i=0}^{2 n} w^{[i]} g\left( X ^{[i]}\right) \\
\Sigma^{\prime} &amp;=\sum_{i=0}^{2 n} w^{[i]}\left(g\left( X ^{[i]}\right)-\mu^{\prime}\right)\left(g\left( X ^{[i]}\right)-\mu^{\prime}\right)^{T}
\end{aligned}
\]</span></p></li>
</ol>
<h2 id="卡尔曼滤波框架">卡尔曼滤波框架</h2>
<ol type="1">
<li>预测步骤：用上一节提到的几个公式计算新的期望和方差</li>
<li>更新步骤：我们可以选择采用之前生成的Sigma Point</li>
</ol>
<h2 id="ref">Ref</h2>
<p>https://towardsdatascience.com/the-unscented-kalman-filter-anything-ekf-can-do-i-can-do-it-better-ce7c773cf88d</p>
]]></content>
      <tags>
        <tag>robotics</tag>
      </tags>
  </entry>
  <entry>
    <title>机器人建图技术（位置已知）</title>
    <url>/2020/07/23/Robotics/Mapping/map/</url>
    <content><![CDATA[<h2 id="背景知识">背景知识</h2>
<p>为什么要建图：</p>
<ul>
<li>学习地图是基本任务</li>
<li>有了地图可以方便其他任务</li>
<li>其他任务依赖正确的地图</li>
</ul>
<p>基本问题：环境是怎么样的</p>
<p>已知的：环境数据和状态数据 <span class="math inline">\(d={u_1,z1,u_2,z2,...u_t,z_t}\)</span></p>
<p>要计算的<span class="math inline">\(m^*=argmax_mP(m|d)\)</span></p>
<h2 id="地图种类">地图种类</h2>
<ul>
<li><p>Grid Maps</p>
<p>世界离散化，结构是固定的，每个cell可以是被占据或者free的，这个模型是没有参数的，不需要识别特征</p>
<ul>
<li>每个cell的状态用概率来描述</li>
<li>每个cell之间都是相互独立的</li>
</ul>
<p>更新同样是用贝叶斯滤波</p></li>
</ul>
<p>利用上述工具，可以使用Occupancy Grid Mapping技术，最早是为了解决传感器噪声问题，根据传感器的数据来判断是障碍物的距离</p>
<p>或者也可以使用反射概率波形，根据统计次数来生成最大似然模型</p>
]]></content>
      <tags>
        <tag>maps</tag>
      </tags>
  </entry>
</search>
